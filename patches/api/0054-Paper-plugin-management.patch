From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: xVorttex <sigamatute@gmail.com>
Date: Sat, 28 Sep 2024 23:58:05 +0300
Subject: [PATCH] Paper plugin management


diff --git a/pom.xml b/pom.xml
index 73d078d7f704a7d99bd8da8e347319ff2a0f6e5a..641d8bc732ad0299975e450ceac2e302fa28f9c2 100644
--- a/pom.xml
+++ b/pom.xml
@@ -67,6 +67,26 @@
             <version>${lang3.version}</version>
         </dependency>
 
+        <!-- testing -->
+        <dependency>
+            <groupId>org.junit.jupiter</groupId>
+            <artifactId>junit-jupiter</artifactId>
+            <version>5.10.2</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.hamcrest</groupId>
+            <artifactId>hamcrest-library</artifactId>
+            <version>2.2</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.ow2.asm</groupId>
+            <artifactId>asm-tree</artifactId>
+            <version>9.7</version>
+            <scope>test</scope>
+        </dependency>
+
         <!-- Paper start -->
         <dependency>
             <groupId>net.kyori</groupId>
@@ -203,26 +223,6 @@
             <artifactId>asm-commons</artifactId>
             <version>9.7</version>
         </dependency>
-
-        <!-- testing -->
-        <dependency>
-            <groupId>junit</groupId>
-            <artifactId>junit</artifactId>
-            <version>4.13.1</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>org.hamcrest</groupId>
-            <artifactId>hamcrest-library</artifactId>
-            <version>1.3</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>org.ow2.asm</groupId>
-            <artifactId>asm-tree</artifactId>
-            <version>9.7</version>
-            <scope>test</scope>
-        </dependency>
     </dependencies>
 
     <build>
diff --git a/src/main/java/com/destroystokyo/paper/utils/PaperPluginLogger.java b/src/main/java/com/destroystokyo/paper/utils/PaperPluginLogger.java
index 76f2cb9cd99cad2a9484eab2becd8c36f1dd91b3..2548ae126954e6b20775b316304cfc5e653c8c4c 100644
--- a/src/main/java/com/destroystokyo/paper/utils/PaperPluginLogger.java
+++ b/src/main/java/com/destroystokyo/paper/utils/PaperPluginLogger.java
@@ -1,5 +1,6 @@
 package com.destroystokyo.paper.utils;
 
+import io.papermc.paper.plugin.configuration.PluginMeta;
 import org.bukkit.plugin.PluginDescriptionFile;
 
 import java.util.logging.Level;
@@ -24,6 +25,22 @@ public class PaperPluginLogger extends Logger {
         return logger;
     }
 
+    @NotNull
+    public static Logger getLogger(@NotNull PluginMeta meta) {
+        Logger logger = new PaperPluginLogger(meta);
+        if (!LogManager.getLogManager().addLogger(logger)) {
+            // Disable this if it's going to happen across reloads anyways...
+            //logger.log(Level.WARNING, "Could not insert plugin logger - one was already found: {}", LogManager.getLogManager().getLogger(this.getName()));
+            logger = LogManager.getLogManager().getLogger(meta.getLoggerPrefix() != null ? meta.getLoggerPrefix() : meta.getName());
+        }
+
+        return logger;
+    }
+
+    private PaperPluginLogger(@NotNull PluginMeta meta) {
+        super(meta.getLoggerPrefix() != null ? meta.getLoggerPrefix() : meta.getName(), null);
+    }
+
     private PaperPluginLogger(@NotNull PluginDescriptionFile description) {
         super(description.getPrefix() != null ? description.getPrefix() : description.getName(), null);
     }
diff --git a/src/main/java/io/papermc/paper/plugin/PermissionManager.java b/src/main/java/io/papermc/paper/plugin/PermissionManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..cdbc93b317b3bab47bf6552c29cfbb2c27846933
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/PermissionManager.java
@@ -0,0 +1,171 @@
+package io.papermc.paper.plugin;
+
+import org.bukkit.permissions.Permissible;
+import org.bukkit.permissions.Permission;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+import java.util.Set;
+
+/**
+ * A permission manager implementation to keep backwards compatibility partially alive with existing plugins that used
+ * the bukkit one before.
+ */
+@ApiStatus.Experimental
+public interface PermissionManager {
+
+    /**
+     * Gets a {@link Permission} from its fully qualified name
+     *
+     * @param name Name of the permission
+     * @return Permission, or null if none
+     */
+    @Nullable
+    Permission getPermission(@NotNull String name);
+
+    /**
+     * Adds a {@link Permission} to this plugin manager.
+     * <p>
+     * If a permission is already defined with the given name of the new
+     * permission, an exception will be thrown.
+     *
+     * @param perm Permission to add
+     * @throws IllegalArgumentException Thrown when a permission with the same
+     *                                  name already exists
+     */
+    void addPermission(@NotNull Permission perm);
+
+    /**
+     * Removes a {@link Permission} registration from this plugin manager.
+     * <p>
+     * If the specified permission does not exist in this plugin manager,
+     * nothing will happen.
+     * <p>
+     * Removing a permission registration will <b>not</b> remove the
+     * permission from any {@link Permissible}s that have it.
+     *
+     * @param perm Permission to remove
+     */
+    void removePermission(@NotNull Permission perm);
+
+    /**
+     * Removes a {@link Permission} registration from this plugin manager.
+     * <p>
+     * If the specified permission does not exist in this plugin manager,
+     * nothing will happen.
+     * <p>
+     * Removing a permission registration will <b>not</b> remove the
+     * permission from any {@link Permissible}s that have it.
+     *
+     * @param name Permission to remove
+     */
+    void removePermission(@NotNull String name);
+
+    /**
+     * Gets the default permissions for the given op status
+     *
+     * @param op Which set of default permissions to get
+     * @return The default permissions
+     */
+    @NotNull
+    Set<Permission> getDefaultPermissions(boolean op);
+
+    /**
+     * Recalculates the defaults for the given {@link Permission}.
+     * <p>
+     * This will have no effect if the specified permission is not registered
+     * here.
+     *
+     * @param perm Permission to recalculate
+     */
+    void recalculatePermissionDefaults(@NotNull Permission perm);
+
+    /**
+     * Subscribes the given Permissible for information about the requested
+     * Permission, by name.
+     * <p>
+     * If the specified Permission changes in any form, the Permissible will
+     * be asked to recalculate.
+     *
+     * @param permission  Permission to subscribe to
+     * @param permissible Permissible subscribing
+     */
+    void subscribeToPermission(@NotNull String permission, @NotNull Permissible permissible);
+
+    /**
+     * Unsubscribes the given Permissible for information about the requested
+     * Permission, by name.
+     *
+     * @param permission  Permission to unsubscribe from
+     * @param permissible Permissible subscribing
+     */
+    void unsubscribeFromPermission(@NotNull String permission, @NotNull Permissible permissible);
+
+    /**
+     * Gets a set containing all subscribed {@link Permissible}s to the given
+     * permission, by name
+     *
+     * @param permission Permission to query for
+     * @return Set containing all subscribed permissions
+     */
+    @NotNull
+    Set<Permissible> getPermissionSubscriptions(@NotNull String permission);
+
+    /**
+     * Subscribes to the given Default permissions by operator status
+     * <p>
+     * If the specified defaults change in any form, the Permissible will be
+     * asked to recalculate.
+     *
+     * @param op          Default list to subscribe to
+     * @param permissible Permissible subscribing
+     */
+    void subscribeToDefaultPerms(boolean op, @NotNull Permissible permissible);
+
+    /**
+     * Unsubscribes from the given Default permissions by operator status
+     *
+     * @param op          Default list to unsubscribe from
+     * @param permissible Permissible subscribing
+     */
+    void unsubscribeFromDefaultPerms(boolean op, @NotNull Permissible permissible);
+
+    /**
+     * Gets a set containing all subscribed {@link Permissible}s to the given
+     * default list, by op status
+     *
+     * @param op Default list to query for
+     * @return Set containing all subscribed permissions
+     */
+    @NotNull
+    Set<Permissible> getDefaultPermSubscriptions(boolean op);
+
+    /**
+     * Gets a set of all registered permissions.
+     * <p>
+     * This set is a copy and will not be modified live.
+     *
+     * @return Set containing all current registered permissions
+     */
+    @NotNull
+    Set<Permission> getPermissions();
+
+    /**
+     * Adds a list of permissions.
+     * <p>
+     * This is meant as an optimization for adding multiple permissions without recalculating each permission.
+     *
+     * @param perm permission
+     */
+    void addPermissions(@NotNull List<Permission> perm);
+
+    /**
+     * Clears the current registered permissinos.
+     * <p>
+     * This is used for reloading.
+     */
+    void clearPermissions();
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/bootstrap/BootstrapContext.java b/src/main/java/io/papermc/paper/plugin/bootstrap/BootstrapContext.java
new file mode 100644
index 0000000000000000000000000000000000000000..37dfdcfcbd14947e0550e7528aca68f452e53eb6
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/bootstrap/BootstrapContext.java
@@ -0,0 +1,25 @@
+package io.papermc.paper.plugin.bootstrap;
+
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventManager;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Represents the context provided to a {@link PluginBootstrap} during both the bootstrapping and plugin
+ * instantiation logic.
+ * A boostrap context may be used to access data or logic usually provided to {@link org.bukkit.plugin.Plugin} instances
+ * like the plugin's configuration or logger during the plugins bootstrap.
+ */
+@ApiStatus.Experimental
+@ApiStatus.NonExtendable
+public interface BootstrapContext extends PluginProviderContext, LifecycleEventOwner {
+
+    /**
+     * Get the lifecycle event manager for registering handlers
+     * for lifecycle events allowed on the {@link BootstrapContext}.
+     *
+     * @return the lifecycle event manager
+     */
+    @NotNull LifecycleEventManager<BootstrapContext> getLifecycleManager();
+}
diff --git a/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrap.java b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrap.java
new file mode 100644
index 0000000000000000000000000000000000000000..288c078da3d3ca78d02caa4e3565ac7cf89f9f9f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrap.java
@@ -0,0 +1,41 @@
+package io.papermc.paper.plugin.bootstrap;
+
+import io.papermc.paper.plugin.provider.util.ProviderUtil;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A plugin boostrap is meant for loading certain parts of the plugin before the server is loaded.
+ * <p>
+ * Plugin bootstrapping allows values to be initialized in certain parts of the server that might not be allowed
+ * when the server is running.
+ * <p>
+ * Your bootstrap class will be on the same classloader as your JavaPlugin.
+ * <p>
+ * <b>All calls to Bukkit may throw a NullPointerExceptions or return null unexpectedly. You should only call api methods that are explicitly documented to work in the bootstrapper</b>
+ */
+@ApiStatus.OverrideOnly
+@ApiStatus.Experimental
+public interface PluginBootstrap {
+
+    /**
+     * Called by the server, allowing you to bootstrap the plugin with a context that provides things like a logger and your shared plugin configuration file.
+     *
+     * @param context the server provided context
+     */
+    void bootstrap(@NotNull BootstrapContext context);
+
+    /**
+     * Called by the server to instantiate your main class.
+     * Plugins may override this logic to define custom creation logic for said instance, like passing addition
+     * constructor arguments.
+     *
+     * @param context the server created bootstrap object
+     * @return the server requested instance of the plugins main class.
+     */
+    @NotNull
+    default JavaPlugin createPlugin(@NotNull PluginProviderContext context) {
+        return ProviderUtil.loadClass(context.getConfiguration().getMainClass(), JavaPlugin.class, this.getClass().getClassLoader());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/bootstrap/PluginProviderContext.java b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginProviderContext.java
new file mode 100644
index 0000000000000000000000000000000000000000..a74f4ee323b592b7b84473e01298190084718e38
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginProviderContext.java
@@ -0,0 +1,43 @@
+package io.papermc.paper.plugin.bootstrap;
+
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.nio.file.Path;
+
+/**
+ * Represents the context provided to a {@link PluginBootstrap} during both the bootstrapping and plugin
+ * instantiation logic.
+ * A boostrap context may be used to access data or logic usually provided to {@link org.bukkit.plugin.Plugin} instances
+ * like the plugin's configuration or logger during the plugins bootstrap.
+ */
+@ApiStatus.NonExtendable
+@ApiStatus.Experimental
+public interface PluginProviderContext {
+
+    /**
+     * Provides the plugin's configuration.
+     *
+     * @return the plugin's configuration
+     */
+    @NotNull
+    PluginMeta getConfiguration();
+
+    /**
+     * Provides the path to the data directory of the plugin.
+     *
+     * @return the previously described path
+     */
+    @NotNull
+    Path getDataDirectory();
+
+    /**
+     * Provides the path to the originating source of the plugin, such as the plugin's JAR file.
+     *
+     * @return the previously described path
+     */
+    @NotNull
+    Path getPluginSource();
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/configuration/PluginMeta.java b/src/main/java/io/papermc/paper/plugin/configuration/PluginMeta.java
new file mode 100644
index 0000000000000000000000000000000000000000..bcf91d048d84144f6acf9bfd2095df9ada2e585f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/configuration/PluginMeta.java
@@ -0,0 +1,203 @@
+package io.papermc.paper.plugin.configuration;
+
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionDefault;
+import org.bukkit.plugin.PluginLoadOrder;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+
+/**
+ * This class acts as an abstraction for a plugin configuration.
+ */
+@ApiStatus.NonExtendable
+@ApiStatus.Experimental // Subject to change!
+public interface PluginMeta {
+
+    /**
+     * Provides the name of the plugin. This name uniquely identifies the plugin amongst all loaded plugins on the
+     * server.
+     * <ul>
+     * <li>Will only contain alphanumeric characters, underscores, hyphens,
+     *     and periods: [a-zA-Z0-9_\-\.].
+     * <li>Typically used for identifying the plugin data folder.
+     * <li>The name also acts as the token referenced in {@link #getPluginDependencies()},
+     * {@link #getPluginSoftDependencies()}, and {@link #getLoadBeforePlugins()}.
+     * </ul>
+     * <p>
+     * In the plugin.yml, this entry is named <code>name</code>.
+     * <p>
+     * Example:<blockquote><pre>name: MyPlugin</pre></blockquote>
+     *
+     * @return the name of the plugin
+     */
+    @NotNull
+    String getName();
+
+    /**
+     * Returns the display name of the plugin, including the version.
+     *
+     * @return a descriptive name of the plugin and respective version
+     */
+    @NotNull
+    default String getDisplayName() {
+        return this.getName() + " v" + this.getVersion();
+    }
+
+    /**
+     * Provides the fully qualified class name of the main class for the plugin.
+     * A subtype of {@link JavaPlugin} is expected at this location.
+     *
+     * @return the fully qualified class name of the plugin's main class.
+     */
+    @NotNull
+    String getMainClass();
+
+    /**
+     * Returns the phase of the server startup logic that the plugin should be loaded.
+     *
+     * @return the plugin load order
+     * @see PluginLoadOrder for further details regards the available load orders.
+     */
+    @NotNull
+    PluginLoadOrder getLoadOrder();
+
+    /**
+     * Provides the version of this plugin as defined by the plugin.
+     * There is no inherit format defined/enforced for the version of a plugin, however a common approach
+     * might be semantic versioning.
+     *
+     * @return the string representation of the plugin's version
+     */
+    @NotNull
+    String getVersion();
+
+    /**
+     * Provides the prefix that should be used for the plugin logger.
+     * The logger prefix allows plugins to overwrite the usual default of the logger prefix, which is the name of the
+     * plugin.
+     *
+     * @return the specific overwrite of the logger prefix as defined by the plugin. If the plugin did not define a
+     *     custom logger prefix, this method will return null
+     */
+    @Nullable
+    String getLoggerPrefix();
+
+    /**
+     * Provides a list of dependencies that are required for this plugin to load.
+     * The list holds the unique identifiers, following the constraints laid out in {@link #getName()}, of the
+     * dependencies.
+     * <p>
+     * If any of the dependencies defined by this list are not installed on the server, this plugin will fail to load.
+     *
+     * @return an immutable list of required dependency names
+     */
+    @NotNull
+    List<String> getPluginDependencies();
+
+    /**
+     * Provides a list of dependencies that are used but not required by this plugin.
+     * The list holds the unique identifiers, following the constraints laid out in {@link #getName()}, of the soft
+     * dependencies.
+     * <p>
+     * If these dependencies are installed on the server, they will be loaded first and supplied as dependencies to this
+     * plugin, however the plugin will load even if these dependencies are not installed.
+     *
+     * @return immutable list of soft dependencies
+     */
+    @NotNull
+    List<String> getPluginSoftDependencies();
+
+    /**
+     * Provides a list of plugins that should be loaded before this plugin is loaded.
+     * The list holds the unique identifiers, following the constraints laid out in {@link #getName()}, of the
+     * plugins that should be loaded before the plugin described by this plugin meta.
+     * <p>
+     * The plugins referenced in the list provided by this method are not considered dependencies of this plugin and
+     * are hence not available to the plugin at runtime. They merely load before this plugin.
+     *
+     * @return immutable list of plugins to load before this plugin
+     */
+    @NotNull
+    List<String> getLoadBeforePlugins();
+
+    /**
+     * Returns the list of plugins/dependencies that this plugin provides.
+     * The list holds the unique identifiers, following the constraints laid out in {@link #getName()}, for each plugin
+     * it provides the expected classes for.
+     *
+     * @return immutable list of provided plugins/dependencies
+     */
+    @NotNull
+    List<String> getProvidedPlugins();
+
+    /**
+     * Provides the list of authors that are credited with creating this plugin.
+     * The author names are in no particular format.
+     *
+     * @return an immutable list of the plugin's authors
+     */
+    @NotNull
+    List<String> getAuthors();
+
+    /**
+     * Provides a list of contributors that contributed to the plugin but are not considered authors.
+     * The names of the contributors are in no particular format.
+     *
+     * @return an immutable list of the plugin's contributors
+     */
+    @NotNull
+    List<String> getContributors();
+
+    /**
+     * Gives a human-friendly description of the functionality the plugin
+     * provides.
+     *
+     * @return description or null if the plugin did not define a human readable description.
+     */
+    @Nullable
+    String getDescription();
+
+    /**
+     * Provides the website for the plugin or the plugin's author.
+     * The defined string value is <b>not guaranteed</b> to be in the form of a url.
+     *
+     * @return a string representation of the website that serves as the main hub for this plugin/its author.
+     */
+    @Nullable
+    String getWebsite();
+
+    /**
+     * Provides the list of permissions that are defined via the plugin meta instance.
+     *
+     * @return an immutable list of permissions
+     */
+    // TODO: Do we even want this? Why not just use the bootstrapper
+    @NotNull
+    List<Permission> getPermissions();
+
+    /**
+     * Provides the default values that apply to the permissions defined in this plugin meta.
+     *
+     * @return the bukkit permission default container.
+     * @see #getPermissions()
+     */
+    // TODO: Do we even want this? Why not just use the bootstrapper
+    @NotNull
+    PermissionDefault getPermissionDefault();
+
+    /**
+     * Gets the api version that this plugin supports.
+     * Nullable if this version is not specified, and should be
+     * considered legacy (spigot plugins only)
+     *
+     * @return the version string made up of the major and minor version (e.g. 1.18 or 1.19). Minor versions like 1.18.2
+     * are unified to their major release version (in this example 1.18)
+     */
+    @Nullable
+    String getAPIVersion();
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/configuration/package-info.java b/src/main/java/io/papermc/paper/plugin/configuration/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..ddb3076124365d0d1a5caa32d4dcb1f4314dd7ae
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/configuration/package-info.java
@@ -0,0 +1,8 @@
+/**
+ * The paper configuration package contains the new java representation of a plugins configuration file.
+ * While most values are described in detail on {@link io.papermc.paper.plugin.configuration.PluginMeta}, a full
+ * entry on the paper contains a full and extensive example of possible configurations of the paper-plugin.yml.
+ * @see <a href="https://docs.papermc.io/paper">Extensive documentation and examples of the paper-plugin.yml</a>
+ * <!--TODO update the documentation link once documentation for this exists and is deployed-->
+ */
+package io.papermc.paper.plugin.configuration;
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEvent.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..0b8eafd3e79494d4a750cd9182387fbaead24011
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEvent.java
@@ -0,0 +1,17 @@
+package io.papermc.paper.plugin.lifecycle.event;
+
+import io.papermc.paper.plugin.lifecycle.event.types.LifecycleEvents;
+import org.jetbrains.annotations.ApiStatus;
+
+/**
+ * Base type for all Lifecycle Events.
+ * <p>
+ * Lifecycle events are generally fired when the older
+ * event system is not available, like during early
+ * server initialization.
+ * @see LifecycleEvents
+ */
+@ApiStatus.Experimental
+@ApiStatus.NonExtendable
+public interface LifecycleEvent {
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventManager.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..3626ce3da17f20ec44f0c15baa13f40e1dc2bc9c
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventManager.java
@@ -0,0 +1,52 @@
+package io.papermc.paper.plugin.lifecycle.event;
+
+import io.papermc.paper.plugin.lifecycle.event.handler.LifecycleEventHandler;
+import io.papermc.paper.plugin.lifecycle.event.handler.configuration.LifecycleEventHandlerConfiguration;
+import io.papermc.paper.plugin.lifecycle.event.types.LifecycleEventType;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Manages a plugin's lifecycle events. Can be obtained
+ * from {@link org.bukkit.plugin.Plugin} or {@link io.papermc.paper.plugin.bootstrap.BootstrapContext}.
+ *
+ * @param <O> the owning type, {@link org.bukkit.plugin.Plugin} or {@link io.papermc.paper.plugin.bootstrap.BootstrapContext}
+ */
+@ApiStatus.Experimental
+@ApiStatus.NonExtendable
+public interface LifecycleEventManager<O extends LifecycleEventOwner> {
+
+    /**
+     * Registers an event handler for a specific event type.
+     * <p>
+     * This is shorthand for creating a new {@link LifecycleEventHandlerConfiguration} and
+     * just passing in the {@link LifecycleEventHandler}.
+     * <pre>{@code
+     * LifecycleEventHandler<RegistrarEvent<Commands>> handler = new Handler();
+     * manager.registerEventHandler(LifecycleEvents.COMMANDS, handler);
+     * }</pre>
+     * is equivalent to
+     * <pre>{@code
+     * LifecycleEventHandler<RegistrarEvent<Commands>> handler = new Handler();
+     * manager.registerEventHandler(LifecycleEvents.COMMANDS.newHandler(handler));
+     * }</pre>
+     *
+     * @param eventType the event type to listen to
+     * @param eventHandler the handler for that event
+     * @param <E> the type of the event object
+     */
+    default <E extends LifecycleEvent> void registerEventHandler(final @NotNull LifecycleEventType<? super O, ? extends E, ?> eventType, final @NotNull LifecycleEventHandler<? super E> eventHandler) {
+        this.registerEventHandler(eventType.newHandler(eventHandler));
+    }
+
+    /**
+     * Registers an event handler configuration.
+     * <p>
+     * Configurations are created via {@link LifecycleEventType#newHandler(LifecycleEventHandler)}.
+     * Event types may have different configurations options available on the builder-like object
+     * returned by {@link LifecycleEventType#newHandler(LifecycleEventHandler)}.
+     *
+     * @param handlerConfiguration the handler configuration to register
+     */
+    void registerEventHandler(@NotNull LifecycleEventHandlerConfiguration<? super O> handlerConfiguration);
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventOwner.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventOwner.java
new file mode 100644
index 0000000000000000000000000000000000000000..1160474f94476b580426cec29756c4699e163bf7
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventOwner.java
@@ -0,0 +1,24 @@
+package io.papermc.paper.plugin.lifecycle.event;
+
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Implemented by types that are considered owners
+ * of registered handlers for lifecycle events. Generally
+ * the types that implement this interface also provide
+ * a {@link LifecycleEventManager} where you can register
+ * event handlers.
+ */
+@ApiStatus.Experimental
+@ApiStatus.NonExtendable
+public interface LifecycleEventOwner {
+
+    /**
+     * Get the plugin meta for this plugin.
+     *
+     * @return the plugin meta
+     */
+    @NotNull PluginMeta getPluginMeta();
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/LifecycleEventHandler.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/LifecycleEventHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..8239ba3c0147c0e8e8d28987d3f543a67641892a
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/LifecycleEventHandler.java
@@ -0,0 +1,18 @@
+package io.papermc.paper.plugin.lifecycle.event.handler;
+
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEvent;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A handler for a specific event. Can be implemented
+ * in a concrete class or as a lambda.
+ *
+ * @param <E> the event
+ */
+@ApiStatus.Experimental
+@FunctionalInterface
+public interface LifecycleEventHandler<E extends LifecycleEvent> {
+
+    void run(@NotNull E event);
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/LifecycleEventHandlerConfiguration.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/LifecycleEventHandlerConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..0831794fad1f6eb8960225909d40f4a3b20a2a3b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/LifecycleEventHandlerConfiguration.java
@@ -0,0 +1,18 @@
+package io.papermc.paper.plugin.lifecycle.event.handler.configuration;
+
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import io.papermc.paper.plugin.lifecycle.event.handler.LifecycleEventHandler;
+import org.jetbrains.annotations.ApiStatus;
+
+/**
+ * Base type for constructing configured event handlers for
+ * lifecycle events. Usually created via {@link io.papermc.paper.plugin.lifecycle.event.types.LifecycleEventType#newHandler(LifecycleEventHandler)}
+ * from event types in {@link io.papermc.paper.plugin.lifecycle.event.types.LifecycleEvents}
+ *
+ * @param <O>
+ */
+@SuppressWarnings("unused")
+@ApiStatus.Experimental
+@ApiStatus.NonExtendable
+public interface LifecycleEventHandlerConfiguration<O extends LifecycleEventOwner> {
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/MonitorLifecycleEventHandlerConfiguration.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/MonitorLifecycleEventHandlerConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..d307ede51a66279f2eeef4e5b41c71779503f0d4
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/MonitorLifecycleEventHandlerConfiguration.java
@@ -0,0 +1,25 @@
+package io.papermc.paper.plugin.lifecycle.event.handler.configuration;
+
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Contract;
+
+/**
+ * Handler configuration for event types that allow "monitor" handlers.
+ *
+ * @param <O> the required owner type
+ */
+@ApiStatus.Experimental
+@ApiStatus.NonExtendable
+public interface MonitorLifecycleEventHandlerConfiguration<O extends LifecycleEventOwner> extends LifecycleEventHandlerConfiguration<O> {
+
+    /**
+     * Sets this handler configuration to be considered a "monitor".
+     * These handlers will run last and should only be used by plugins
+     * to observe changes from previously run handlers.
+     *
+     * @return this configuration for chaining
+     */
+    @Contract("-> this")
+    MonitorLifecycleEventHandlerConfiguration<O> monitor();
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/PrioritizedLifecycleEventHandlerConfiguration.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/PrioritizedLifecycleEventHandlerConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..1c404df0be359ceac7fb52fec03027c771395e07
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/PrioritizedLifecycleEventHandlerConfiguration.java
@@ -0,0 +1,39 @@
+package io.papermc.paper.plugin.lifecycle.event.handler.configuration;
+
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Contract;
+
+/**
+ * Handler configuration that allows both "monitor" and prioritized handlers.
+ * The default priority is 0.
+ *
+ * @param <O> the required owner type
+ */
+@ApiStatus.Experimental
+@ApiStatus.NonExtendable
+public interface PrioritizedLifecycleEventHandlerConfiguration<O extends LifecycleEventOwner> extends LifecycleEventHandlerConfiguration<O> {
+
+    /**
+     * Sets the priority for this handler. Resets
+     * all previous calls to {@link #monitor()}. A
+     * lower numeric value correlates to the handler
+     * being run earlier.
+     *
+     * @param priority the numerical priority
+     * @return this configuration for chaining
+     */
+    @Contract("_ -> this")
+    PrioritizedLifecycleEventHandlerConfiguration<O> priority(int priority);
+
+    /**
+     * Sets this handler configuration to be considered a "monitor".
+     * These handlers will run last and should only be used by plugins
+     * to observe any changes from previously ran handlers.
+     *
+     * @return this configuration for chaining
+     */
+    @Contract("-> this")
+    PrioritizedLifecycleEventHandlerConfiguration<O> monitor();
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/Registrar.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/Registrar.java
new file mode 100644
index 0000000000000000000000000000000000000000..fd9c3605a8f5e6bdd31e42f18a45154d4074eb67
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/Registrar.java
@@ -0,0 +1,12 @@
+package io.papermc.paper.plugin.lifecycle.event.registrar;
+
+import org.jetbrains.annotations.ApiStatus;
+
+/**
+ * To be implemented by types that provide ways to register types
+ * either on server start or during a reload
+ */
+@ApiStatus.Experimental
+@ApiStatus.NonExtendable
+public interface Registrar {
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/RegistrarEvent.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/RegistrarEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..2e5758d1af6215f33f89b12984a5594df592147f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/RegistrarEvent.java
@@ -0,0 +1,27 @@
+package io.papermc.paper.plugin.lifecycle.event.registrar;
+
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEvent;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A lifecycle event that exposes a {@link Registrar} of some kind
+ * to allow management of various things. Look at implementations of
+ * {@link Registrar} for an idea of what uses this event.
+ *
+ * @param <R> registrar type
+ * @see ReloadableRegistrarEvent
+ */
+@ApiStatus.Experimental
+@ApiStatus.NonExtendable
+public interface RegistrarEvent<R extends Registrar> extends LifecycleEvent {
+
+    /**
+     * Get the registrar related to this event.
+     *
+     * @return the registrar
+     */
+    @Contract(pure = true)
+    @NotNull R registrar();
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/ReloadableRegistrarEvent.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/ReloadableRegistrarEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..b8b439bdad2e47c7c715fe30e0c1e69aa25374dd
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/ReloadableRegistrarEvent.java
@@ -0,0 +1,38 @@
+package io.papermc.paper.plugin.lifecycle.event.registrar;
+
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A lifecycle event that exposes a {@link Registrar} that is
+ * reloadable.
+ *
+ * @param <R> the registrar type
+ * @see RegistrarEvent
+ */
+@ApiStatus.Experimental
+@ApiStatus.NonExtendable
+public interface ReloadableRegistrarEvent<R extends Registrar> extends RegistrarEvent<R> {
+
+    /**
+     * Get the cause of this reload.
+     *
+     * @return the cause
+     */
+    @Contract(pure = true)
+    @NotNull Cause cause();
+
+    @ApiStatus.Experimental
+    enum Cause {
+        /**
+         * The initial load of the server.
+         */
+        INITIAL,
+        /**
+         * A reload, triggered via one of the various mechanisms like
+         * the bukkit or minecraft reload commands.
+         */
+        RELOAD
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/LifecycleEventType.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/LifecycleEventType.java
new file mode 100644
index 0000000000000000000000000000000000000000..92ea0374079a228ccc59c00fcf58abff2f6c46fe
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/LifecycleEventType.java
@@ -0,0 +1,73 @@
+package io.papermc.paper.plugin.lifecycle.event.types;
+
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventManager;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import io.papermc.paper.plugin.lifecycle.event.handler.LifecycleEventHandler;
+import io.papermc.paper.plugin.lifecycle.event.handler.configuration.LifecycleEventHandlerConfiguration;
+import io.papermc.paper.plugin.lifecycle.event.handler.configuration.MonitorLifecycleEventHandlerConfiguration;
+import io.papermc.paper.plugin.lifecycle.event.handler.configuration.PrioritizedLifecycleEventHandlerConfiguration;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Base type for all types of lifecycle events. Differs from
+ * {@link LifecycleEvent} which is the actual event object, whereas
+ * this is an object representing the type of the event. Used
+ * to construct subtypes of {@link LifecycleEventHandlerConfiguration} for
+ * use in {@link LifecycleEventManager}
+ *
+ * @param <O> the required owner type
+ * @param <E> the event object type
+ * @param <C> the configuration type
+ */
+@ApiStatus.Experimental
+@ApiStatus.NonExtendable
+public interface LifecycleEventType<O extends LifecycleEventOwner, E extends LifecycleEvent, C extends LifecycleEventHandlerConfiguration<O>> {
+
+    /**
+     * Gets the name of the lifecycle event.
+     *
+     * @return the name
+     */
+    @Contract(pure = true)
+    @NotNull String name();
+
+    /**
+     * Create a configuration for this event with the specified
+     * handler.
+     *
+     * @param handler the event handler
+     * @return a new configuration
+     * @see LifecycleEventManager#registerEventHandler(LifecycleEventHandlerConfiguration)
+     */
+    @Contract("_ -> new")
+    @NotNull C newHandler(@NotNull LifecycleEventHandler<? super E> handler);
+
+    /**
+     * Lifecycle event type that supports separate registration
+     * of handlers as "monitors" that are run last. Useful
+     * if a plugin wants to only observe the changes other handlers
+     * made.
+     *
+     * @param <O> the required owner type
+     * @param <E> the event object type
+     */
+    @ApiStatus.Experimental
+    @ApiStatus.NonExtendable
+    interface Monitorable<O extends LifecycleEventOwner, E extends LifecycleEvent> extends LifecycleEventType<O, E, MonitorLifecycleEventHandlerConfiguration<O>> {
+    }
+
+    /**
+     * Lifecycle event type that supports both {@link Monitorable "monitors"} and
+     * specific numeric-based priorities.
+     *
+     * @param <O> the required owner type
+     * @param <E> the event object type
+     */
+    @ApiStatus.Experimental
+    @ApiStatus.NonExtendable
+    interface Prioritizable<O extends LifecycleEventOwner, E extends LifecycleEvent> extends LifecycleEventType<O, E, PrioritizedLifecycleEventHandlerConfiguration<O>> {
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/LifecycleEventTypeProvider.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/LifecycleEventTypeProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..f69673042757748b6333e49a032519ac8ad80143
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/LifecycleEventTypeProvider.java
@@ -0,0 +1,19 @@
+package io.papermc.paper.plugin.lifecycle.event.types;
+
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import org.jetbrains.annotations.ApiStatus;
+
+import java.util.ServiceLoader;
+
+@ApiStatus.Internal
+interface LifecycleEventTypeProvider {
+
+    LifecycleEventTypeProvider PROVIDER = ServiceLoader.load(LifecycleEventTypeProvider.class)
+        .findFirst()
+        .orElseThrow();
+
+    <O extends LifecycleEventOwner, E extends LifecycleEvent> LifecycleEventType.Monitorable<O, E> monitor(String name, Class<? extends O> ownerType);
+
+    <O extends LifecycleEventOwner, E extends LifecycleEvent> LifecycleEventType.Prioritizable<O, E> prioritized(String name, Class<? extends O> ownerType);
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/LifecycleEvents.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/LifecycleEvents.java
new file mode 100644
index 0000000000000000000000000000000000000000..3c8e3a8c52f377a293e6ea0b4c7917b22b5340cb
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/LifecycleEvents.java
@@ -0,0 +1,53 @@
+package io.papermc.paper.plugin.lifecycle.event.types;
+
+import io.papermc.paper.plugin.bootstrap.BootstrapContext;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventManager;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import io.papermc.paper.plugin.lifecycle.event.registrar.ReloadableRegistrarEvent;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.ApiStatus;
+
+/**
+ * Holds various types of lifecycle events for
+ * use when creating event handler configurations
+ * in {@link LifecycleEventManager}.
+ */
+@ApiStatus.Experimental
+public final class LifecycleEvents {
+
+    //<editor-fold desc="helper methods" defaultstate="collapsed">
+    @ApiStatus.Internal
+    private static <E extends LifecycleEvent> LifecycleEventType.Monitorable<Plugin, E> plugin(final String name) {
+        return monitor(name, Plugin.class);
+    }
+
+    @ApiStatus.Internal
+    private static <E extends LifecycleEvent> LifecycleEventType.Prioritizable<Plugin, E> pluginPrioritized(final String name) {
+        return prioritized(name, Plugin.class);
+    }
+
+    @ApiStatus.Internal
+    private static <E extends LifecycleEvent> LifecycleEventType.Monitorable<BootstrapContext, E> bootstrap(final String name) {
+        return monitor(name, BootstrapContext.class);
+    }
+
+    @ApiStatus.Internal
+    private static <E extends LifecycleEvent> LifecycleEventType.Prioritizable<BootstrapContext, E> bootstrapPrioritized(final String name) {
+        return prioritized(name, BootstrapContext.class);
+    }
+
+    @ApiStatus.Internal
+    private static <O extends LifecycleEventOwner, E extends LifecycleEvent, O2 extends O> LifecycleEventType.Monitorable<O, E> monitor(final String name, final Class<O2> ownerType) {
+        return LifecycleEventTypeProvider.PROVIDER.monitor(name, ownerType);
+    }
+
+    @ApiStatus.Internal
+    private static <O extends LifecycleEventOwner, E extends LifecycleEvent> LifecycleEventType.Prioritizable<O, E> prioritized(final String name, final Class<? extends O> ownerType) {
+        return LifecycleEventTypeProvider.PROVIDER.prioritized(name, ownerType);
+    }
+    //</editor-fold>
+
+    private LifecycleEvents() {
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/loader/PluginClasspathBuilder.java b/src/main/java/io/papermc/paper/plugin/loader/PluginClasspathBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..28cbc09b7c1ded1f4515969cef4a669adac85703
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/loader/PluginClasspathBuilder.java
@@ -0,0 +1,38 @@
+package io.papermc.paper.plugin.loader;
+
+import io.papermc.paper.plugin.bootstrap.PluginProviderContext;
+import io.papermc.paper.plugin.loader.library.ClassPathLibrary;
+import io.papermc.paper.plugin.loader.library.LibraryStore;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A mutable builder that may be used to collect and register all {@link ClassPathLibrary} instances a
+ * {@link PluginLoader} aims to provide to its plugin at runtime.
+ */
+@ApiStatus.NonExtendable
+@ApiStatus.Experimental
+public interface PluginClasspathBuilder {
+
+    /**
+     * Adds a new classpath library to this classpath builder.
+     * <p>
+     * As a builder, this method does not invoke {@link ClassPathLibrary#register(LibraryStore)} and
+     * may hence be run without invoking potential IO performed by a {@link ClassPathLibrary} during resolution.
+     * <p>
+     * The paper api provides pre implemented {@link ClassPathLibrary} types that allow easy inclusion of existing
+     * libraries on disk or on remote maven repositories.
+     *
+     * @param classPathLibrary the library instance to add to this builder
+     * @return self
+     * @see io.papermc.paper.plugin.loader.library.impl.JarLibrary
+     * @see io.papermc.paper.plugin.loader.library.impl.MavenLibraryResolver
+     */
+    @NotNull
+    @Contract("_ -> this")
+    PluginClasspathBuilder addLibrary(@NotNull ClassPathLibrary classPathLibrary);
+
+    @NotNull
+    PluginProviderContext getContext();
+}
diff --git a/src/main/java/io/papermc/paper/plugin/loader/PluginLoader.java b/src/main/java/io/papermc/paper/plugin/loader/PluginLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..c9e31f78ff6ff969436c6d99755845786c4d383f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/loader/PluginLoader.java
@@ -0,0 +1,30 @@
+package io.papermc.paper.plugin.loader;
+
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A plugin loader is responsible for creating certain aspects of a plugin before it is created.
+ * <p>
+ * The goal of the plugin loader is the creation of an expected/dynamic environment for the plugin to load into.
+ * This, as of right now, only applies to creating the expected classpath for the plugin, e.g. supplying external
+ * libraries to the plugin.
+ * <p>
+ * It should be noted that this class will be called from a different classloader, this will cause any static values
+ * set in this class/any other classes loaded not to persist when the plugin loads.
+ */
+@ApiStatus.OverrideOnly
+@ApiStatus.Experimental
+public interface PluginLoader {
+
+    /**
+     * Called by the server to allows plugins to configure the runtime classpath that the plugin is run on.
+     * This allows plugin loaders to configure dependencies for the plugin where jars can be downloaded or
+     * provided during runtime.
+     *
+     * @param classpathBuilder a mutable classpath builder that may be used to register custom runtime dependencies
+     *                         for the plugin the loader was registered for.
+     */
+    void classloader(@NotNull PluginClasspathBuilder classpathBuilder);
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/loader/library/ClassPathLibrary.java b/src/main/java/io/papermc/paper/plugin/loader/library/ClassPathLibrary.java
new file mode 100644
index 0000000000000000000000000000000000000000..1347b535d90c2c281c184d0459e7ac59c0350c9f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/loader/library/ClassPathLibrary.java
@@ -0,0 +1,20 @@
+package io.papermc.paper.plugin.loader.library;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * The classpath library interface represents libraries that are capable of registering themselves via
+ * {@link #register(LibraryStore)} on any given {@link LibraryStore}.
+ */
+public interface ClassPathLibrary {
+
+    /**
+     * Called to register the library this class path library represents into the passed library store.
+     * This method may either be implemented by the plugins themselves if they need complex logic, or existing
+     * API exposed implementations of this interface may be used.
+     *
+     * @param store the library store instance to register this library into
+     * @throws LibraryLoadingException if library loading failed for this classpath library
+     */
+    void register(@NotNull LibraryStore store) throws LibraryLoadingException;
+}
diff --git a/src/main/java/io/papermc/paper/plugin/loader/library/LibraryLoadingException.java b/src/main/java/io/papermc/paper/plugin/loader/library/LibraryLoadingException.java
new file mode 100644
index 0000000000000000000000000000000000000000..79ba423a364b50588f3ee87fdc69155cb8e64ad0
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/loader/library/LibraryLoadingException.java
@@ -0,0 +1,15 @@
+package io.papermc.paper.plugin.loader.library;
+
+/**
+ * Indicates that an exception has occured while loading a library.
+ */
+public class LibraryLoadingException extends RuntimeException {
+
+    public LibraryLoadingException(String s) {
+        super(s);
+    }
+
+    public LibraryLoadingException(String s, Exception e) {
+        super(s, e);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/loader/library/LibraryStore.java b/src/main/java/io/papermc/paper/plugin/loader/library/LibraryStore.java
new file mode 100644
index 0000000000000000000000000000000000000000..0546fa1e9dcd7155086a8650806a8c086b6fc458
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/loader/library/LibraryStore.java
@@ -0,0 +1,26 @@
+package io.papermc.paper.plugin.loader.library;
+
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.nio.file.Path;
+
+/**
+ * Represents a storage that stores library jars.
+ * <p>
+ * The library store api allows plugins to register specific dependencies into their runtime classloader when their
+ * {@link io.papermc.paper.plugin.loader.PluginLoader} is processed.
+ *
+ * @see io.papermc.paper.plugin.loader.PluginLoader
+ */
+@ApiStatus.Internal
+public interface LibraryStore {
+
+    /**
+     * Adds the provided library path to this library store.
+     *
+     * @param library path to the libraries jar file on the disk
+     */
+    void addLibrary(@NotNull Path library);
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/loader/library/impl/JarLibrary.java b/src/main/java/io/papermc/paper/plugin/loader/library/impl/JarLibrary.java
new file mode 100644
index 0000000000000000000000000000000000000000..e3da0d67cab01e1233dccde1a12ff25961ee79fb
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/loader/library/impl/JarLibrary.java
@@ -0,0 +1,45 @@
+package io.papermc.paper.plugin.loader.library.impl;
+
+import io.papermc.paper.plugin.loader.library.ClassPathLibrary;
+import io.papermc.paper.plugin.loader.library.LibraryLoadingException;
+import io.papermc.paper.plugin.loader.library.LibraryStore;
+import org.jetbrains.annotations.NotNull;
+
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+/**
+ * A simple jar library implementation of the {@link ClassPathLibrary} that allows {@link io.papermc.paper.plugin.loader.PluginLoader}s to
+ * append a jar stored on the local file system into their runtime classloader.
+ * <p>
+ * An example creation of the jar library type may look like this:
+ * <pre>{@code
+ *   final JarLibrary customLibrary = new JarLibrary(Path.of("libs/custom-library-1.24.jar"));
+ * }</pre>
+ * resulting in a jar library that provides the jar at {@code libs/custom-library-1.24.jar} to the plugins classloader
+ * at runtime.
+ * <p>
+ * The jar library implementation will error if the file does not exist at the specified path.
+ */
+public class JarLibrary implements ClassPathLibrary {
+
+    private final Path path;
+
+    /**
+     * Creates a new jar library that references the jar file found at the provided path.
+     *
+     * @param path the path, relative to the JVMs start directory.
+     */
+    public JarLibrary(@NotNull Path path) {
+        this.path = path;
+    }
+
+    @Override
+    public void register(@NotNull LibraryStore store) throws LibraryLoadingException {
+        if (Files.notExists(this.path)) {
+            throw new LibraryLoadingException("Could not find library at " + this.path);
+        }
+
+        store.addLibrary(this.path);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/loader/library/impl/MavenLibraryResolver.java b/src/main/java/io/papermc/paper/plugin/loader/library/impl/MavenLibraryResolver.java
new file mode 100644
index 0000000000000000000000000000000000000000..70f352630de71f575d1aea5a3126da19a94791ab
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/loader/library/impl/MavenLibraryResolver.java
@@ -0,0 +1,133 @@
+package io.papermc.paper.plugin.loader.library.impl;
+
+import io.papermc.paper.plugin.loader.library.ClassPathLibrary;
+import io.papermc.paper.plugin.loader.library.LibraryLoadingException;
+import io.papermc.paper.plugin.loader.library.LibraryStore;
+import org.apache.maven.repository.internal.MavenRepositorySystemUtils;
+import org.eclipse.aether.DefaultRepositorySystemSession;
+import org.eclipse.aether.RepositorySystem;
+import org.eclipse.aether.collection.CollectRequest;
+import org.eclipse.aether.connector.basic.BasicRepositoryConnectorFactory;
+import org.eclipse.aether.graph.Dependency;
+import org.eclipse.aether.impl.DefaultServiceLocator;
+import org.eclipse.aether.repository.LocalRepository;
+import org.eclipse.aether.repository.RemoteRepository;
+import org.eclipse.aether.repository.RepositoryPolicy;
+import org.eclipse.aether.resolution.ArtifactResult;
+import org.eclipse.aether.resolution.DependencyRequest;
+import org.eclipse.aether.resolution.DependencyResolutionException;
+import org.eclipse.aether.resolution.DependencyResult;
+import org.eclipse.aether.spi.connector.RepositoryConnectorFactory;
+import org.eclipse.aether.spi.connector.transport.TransporterFactory;
+import org.eclipse.aether.transfer.AbstractTransferListener;
+import org.eclipse.aether.transfer.TransferCancelledException;
+import org.eclipse.aether.transfer.TransferEvent;
+import org.eclipse.aether.transport.http.HttpTransporterFactory;
+import org.jetbrains.annotations.NotNull;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * The maven library resolver acts as a resolver for yet to be resolved jar libraries that may be pulled from a
+ * remote maven repository.
+ * <p>
+ * Plugins may create and configure a {@link MavenLibraryResolver} by creating a new one and registering both
+ * a dependency artifact that should be resolved to a library at runtime and the repository it is found in.
+ * An example of this would be the inclusion of the jooq library for typesafe SQL queries:
+ * <pre>{@code
+ * MavenLibraryResolver resolver = new MavenLibraryResolver();
+ * resolver.addDependency(new Dependency(new DefaultArtifact("org.jooq:jooq:3.17.7"), null));
+ * resolver.addRepository(new RemoteRepository.Builder(
+ *     "central", "default", "https://repo1.maven.org/maven2/"
+ * ).build());
+ * }</pre>
+ *
+ * Plugins may create and register a {@link MavenLibraryResolver} after configuring it.
+ */
+public class MavenLibraryResolver implements ClassPathLibrary {
+
+    private static final Logger logger = LoggerFactory.getLogger("MavenLibraryResolver");
+
+    private final RepositorySystem repository;
+    private final DefaultRepositorySystemSession session;
+    private final List<RemoteRepository> repositories = new ArrayList<>();
+    private final List<Dependency> dependencies = new ArrayList<>();
+
+    /**
+     * Creates a new maven library resolver instance.
+     * <p>
+     * The created instance will use the servers {@code libraries} folder to cache fetched libraries in.
+     * Notably, the resolver is created without any repository, not even maven central.
+     * It is hence crucial that plugins which aim to use this api register all required repositories before
+     * submitting the {@link MavenLibraryResolver} to the {@link io.papermc.paper.plugin.loader.PluginClasspathBuilder}.
+     */
+    public MavenLibraryResolver() {
+        DefaultServiceLocator locator = MavenRepositorySystemUtils.newServiceLocator();
+        locator.addService(RepositoryConnectorFactory.class, BasicRepositoryConnectorFactory.class);
+        locator.addService(TransporterFactory.class, HttpTransporterFactory.class);
+
+        this.repository = locator.getService(RepositorySystem.class);
+        this.session = MavenRepositorySystemUtils.newSession();
+
+        this.session.setSystemProperties(System.getProperties());
+        this.session.setChecksumPolicy(RepositoryPolicy.CHECKSUM_POLICY_FAIL);
+        this.session.setLocalRepositoryManager(this.repository.newLocalRepositoryManager(this.session, new LocalRepository("libraries")));
+        this.session.setTransferListener(new AbstractTransferListener() {
+            @Override
+            public void transferInitiated(@NotNull TransferEvent event) throws TransferCancelledException {
+                logger.info("Downloading {}", event.getResource().getRepositoryUrl() + event.getResource().getResourceName());
+            }
+        });
+        this.session.setReadOnly();
+    }
+
+    /**
+     * Adds the provided dependency to the library resolver.
+     * The artifact from the first valid repository matching the passed dependency will be chosen.
+     *
+     * @param dependency the definition of the dependency the maven library resolver should resolve when running
+     * @see MavenLibraryResolver#addRepository(RemoteRepository)
+     */
+    public void addDependency(@NotNull Dependency dependency) {
+        this.dependencies.add(dependency);
+    }
+
+    /**
+     * Adds the provided repository to the library resolver.
+     * The order in which these are added does matter, as dependency resolving will start at the first added
+     * repository.
+     *
+     * @param remoteRepository the configuration that defines the maven repository this library resolver should fetch
+     *                         dependencies from
+     */
+    public void addRepository(@NotNull RemoteRepository remoteRepository) {
+        this.repositories.add(remoteRepository);
+    }
+
+    /**
+     * Resolves the provided dependencies and adds them to the library store.
+     *
+     * @param store the library store the then resolved and downloaded dependencies are registered into
+     * @throws LibraryLoadingException if resolving a dependency failed
+     */
+    @Override
+    public void register(@NotNull LibraryStore store) throws LibraryLoadingException {
+        List<RemoteRepository> repos = this.repository.newResolutionRepositories(this.session, this.repositories);
+
+        DependencyResult result;
+        try {
+            result = this.repository.resolveDependencies(this.session, new DependencyRequest(new CollectRequest((Dependency) null, this.dependencies, repos), null));
+        } catch (DependencyResolutionException ex) {
+            throw new LibraryLoadingException("Error resolving libraries", ex);
+        }
+
+        for (ArtifactResult artifact : result.getArtifactResults()) {
+            File file = artifact.getArtifact().getFile();
+            store.addLibrary(file.toPath());
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/classloader/ClassLoaderAccess.java b/src/main/java/io/papermc/paper/plugin/provider/classloader/ClassLoaderAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..a37a0b9e161aaf9db892ca4993033076cd924fc3
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/classloader/ClassLoaderAccess.java
@@ -0,0 +1,33 @@
+package io.papermc.paper.plugin.provider.classloader;
+
+import org.jetbrains.annotations.ApiStatus;
+
+/**
+ * The class loader access interface is an <b>internal</b> representation of a class accesses' ability to see types
+ * from other {@link ConfiguredPluginClassLoader}.
+ * <p>
+ * An example of this would be a class loader access representing a plugin. The class loader access in that case would
+ * only return {@code true} on calls for {@link #canAccess(ConfiguredPluginClassLoader)} if the passed class loader
+ * is owned by a direct or transitive dependency of the plugin, preventing the plugin for accidentally discovering and
+ * using class types that are supplied by plugins/libraries the plugin did not actively define as a dependency.
+ */
+@ApiStatus.Internal
+public interface ClassLoaderAccess {
+
+    /**
+     * Evaluates if this class loader access is allowed to access types provided by the passed {@link
+     * ConfiguredPluginClassLoader}.
+     * <p>
+     * This interface method does not offer any further contracts on the interface level, as the logic to determine
+     * what class loaders this class loader access is allowed to retrieve types from depends heavily on the type of
+     * access.
+     * Legacy spigot types for example may access any class loader available on the server, while modern paper plugins
+     * are properly limited to their dependency tree.
+     *
+     * @param classLoader the class loader for which access should be evaluated
+     * @return a plain boolean flag, {@code true} indicating that this class loader access is allowed to access types
+     * from the passed configured plugin class loader, {@code false} indicating otherwise.
+     */
+    boolean canAccess(ConfiguredPluginClassLoader classLoader);
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/classloader/ConfiguredPluginClassLoader.java b/src/main/java/io/papermc/paper/plugin/provider/classloader/ConfiguredPluginClassLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..46d9650bd99d6866250177cf05542fa6aed1cb68
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/classloader/ConfiguredPluginClassLoader.java
@@ -0,0 +1,71 @@
+package io.papermc.paper.plugin.provider.classloader;
+
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.Closeable;
+
+/**
+ * The configured plugin class loader represents an <b>internal</b> abstraction over the classloaders used by the server
+ * to load and access a plugins classes during runtime.
+ * <p>
+ * It implements {@link Closeable} to define the ability to shutdown and close the classloader that implements this
+ * interface.
+ */
+@ApiStatus.Internal
+public interface ConfiguredPluginClassLoader extends Closeable {
+
+    /**
+     * Provides the configuration of the plugin that this plugin classloader provides type access to.
+     *
+     * @return the plugin meta instance, holding all meta information about the plugin instance.
+     */
+    PluginMeta getConfiguration();
+
+    /**
+     * Attempts to load a class from this plugin class loader using the passed fully qualified name.
+     * This lookup logic can be configured through the following parameters to define how wide or how narrow the
+     * class lookup should be.
+     *
+     * @param name           the fully qualified name of the class to load
+     * @param resolve        whether the class should be resolved if needed or not
+     * @param checkGlobal    whether this lookup should check transitive dependencies, including either the legacy spigot
+     *                       global class loader or the paper {@link PluginClassLoaderGroup}
+     * @param checkLibraries whether the defined libraries should be checked for the class or not
+     * @return the class found at the fully qualified class name passed under the passed restrictions
+     * @throws ClassNotFoundException if the class could not be found considering the passed restrictions
+     * @see ClassLoader#loadClass(String)
+     * @see Class#forName(String, boolean, ClassLoader)
+     */
+    Class<?> loadClass(@NotNull String name,
+                       boolean resolve,
+                       boolean checkGlobal,
+                       boolean checkLibraries) throws ClassNotFoundException;
+
+    /**
+     * Initializes both this configured plugin class loader and the java plugin passed to link to each other.
+     * This logic is to be called exactly once when the initial setup between the class loader and the instantiated
+     * {@link JavaPlugin} is loaded.
+     *
+     * @param plugin the {@link JavaPlugin} that should be interlinked with this class loader.
+     */
+    void init(JavaPlugin plugin);
+
+    /**
+     * Gets the plugin held by this class loader.
+     *
+     * @return the plugin or null if it doesn't exist yet
+     */
+    @Nullable JavaPlugin getPlugin();
+
+    /**
+     * Get the plugin classloader group
+     * that is used by the underlying classloader
+     * @return classloader
+     */
+    @Nullable
+    PluginClassLoaderGroup getGroup();
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/classloader/PaperClassLoaderStorage.java b/src/main/java/io/papermc/paper/plugin/provider/classloader/PaperClassLoaderStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..fefc87d5ffd36b848a7adb326a3a741e9edb28df
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/classloader/PaperClassLoaderStorage.java
@@ -0,0 +1,92 @@
+package io.papermc.paper.plugin.provider.classloader;
+
+import org.bukkit.plugin.java.PluginClassLoader;
+import org.jetbrains.annotations.ApiStatus;
+
+/**
+ * The plugin classloader storage is an <b>internal</b> type that is used to manage existing classloaders on the server.
+ * <p>
+ * The paper classloader storage is also responsible for storing added {@link ConfiguredPluginClassLoader}s into
+ * {@link PluginClassLoaderGroup}s, via {@link #registerOpenGroup(ConfiguredPluginClassLoader)},
+ * {@link #registerSpigotGroup(PluginClassLoader)} and {@link
+ * #registerAccessBackedGroup(ConfiguredPluginClassLoader, ClassLoaderAccess)}.
+ * <p>
+ * Groups are differentiated into the global group or plugin owned groups.
+ * <ul>
+ * <li>The global group holds all registered class loaders and merely exists to maintain backwards compatibility with
+ * spigots legacy classloader handling.</li>
+ * <li>The plugin groups only contains the classloaders that each plugin has access to and hence serves to properly
+ * separates unrelated classloaders.</li>
+ * </ul>
+ */
+@ApiStatus.Internal
+public interface PaperClassLoaderStorage {
+
+    /**
+     * Access to the shared instance of the {@link PaperClassLoaderStorageAccess}.
+     *
+     * @return the singleton instance of the {@link PaperClassLoaderStorage} used throughout the server
+     */
+    static PaperClassLoaderStorage instance() {
+        return PaperClassLoaderStorageAccess.INSTANCE;
+    }
+
+    /**
+     * Registers a legacy spigot {@link PluginClassLoader} into the loader storage, creating a group wrapping
+     * the single plugin class loader with transitive access to the global group.
+     *
+     * @param pluginClassLoader the legacy spigot plugin class loader to register
+     * @return the group the plugin class loader was placed into
+     */
+    PluginClassLoaderGroup registerSpigotGroup(PluginClassLoader pluginClassLoader);
+
+    /**
+     * Registers a paper configured plugin classloader into a new open group, with full access to the global
+     * plugin class loader group.
+     * <p>
+     * This method hence allows the configured plugin class loader to access all other class loaders registered in this
+     * storage.
+     *
+     * @param classLoader the configured plugin class loader to register
+     * @return the group the plugin class loader was placed into
+     */
+    PluginClassLoaderGroup registerOpenGroup(ConfiguredPluginClassLoader classLoader);
+
+    /**
+     * Registers a paper configured classloader into a new, access backed group.
+     * The access backed classloader group, different from an open group, only has access to the classloaders
+     * the passed {@link ClassLoaderAccess} grants access to.
+     *
+     * @param classLoader the configured plugin class loader to register
+     * @param access      the class loader access that defines what other classloaders the passed plugin class loader
+     *                    should be granted access to.
+     * @return the group the plugin class loader was placed into.
+     */
+    PluginClassLoaderGroup registerAccessBackedGroup(ConfiguredPluginClassLoader classLoader, ClassLoaderAccess access);
+
+    /**
+     * Unregisters a configured class loader from this storage.
+     * This removes the passed class loaders from any group it may have been a part of, including the global group.
+     * <p>
+     * Note: this method is <b>highly</b> discouraged from being used, as mutation of the classloaders at runtime
+     * is not encouraged
+     *
+     * @param configuredPluginClassLoader the class loader to remove from this storage.
+     */
+    void unregisterClassloader(ConfiguredPluginClassLoader configuredPluginClassLoader);
+
+    /**
+     * Registers a configured plugin class loader directly into the global group without adding it to
+     * any existing groups.
+     * <p>
+     * Note: this method unsafely injects the plugin classloader directly into the global group, which bypasses the
+     * group structure paper's plugin API introduced. This method should hence be used with caution.
+     *
+     * @param pluginLoader the configured plugin classloader instance that should be registered directly into the global
+     *                     group.
+     * @return a simple boolean flag, {@code true} if the classloader was registered or {@code false} if the classloader
+     * was already part of the global group.
+     */
+    boolean registerUnsafePlugin(ConfiguredPluginClassLoader pluginLoader);
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/classloader/PaperClassLoaderStorageAccess.java b/src/main/java/io/papermc/paper/plugin/provider/classloader/PaperClassLoaderStorageAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..2c0e5ba6f8eba7a632180491843071b8a8558e56
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/classloader/PaperClassLoaderStorageAccess.java
@@ -0,0 +1,17 @@
+package io.papermc.paper.plugin.provider.classloader;
+
+import net.kyori.adventure.util.Services;
+
+/**
+ * The paper classloader storage access acts as the holder for the server provided implementation of the
+ * {@link PaperClassLoaderStorage} interface.
+ */
+class PaperClassLoaderStorageAccess {
+
+    /**
+     * The shared instance of the {@link PaperClassLoaderStorage}, supplied through the {@link java.util.ServiceLoader}
+     * by the server.
+     */
+    static final PaperClassLoaderStorage INSTANCE = Services.service(PaperClassLoaderStorage.class).orElseThrow();
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/classloader/PluginClassLoaderGroup.java b/src/main/java/io/papermc/paper/plugin/provider/classloader/PluginClassLoaderGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..885151cb932d9b8c09a7887edc879e154225f416
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/classloader/PluginClassLoaderGroup.java
@@ -0,0 +1,65 @@
+package io.papermc.paper.plugin.provider.classloader;
+
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * A plugin classloader group represents a group of classloaders that a plugins classloader may access.
+ * <p>
+ * An example of this would be a classloader group that holds all direct and transitive dependencies a plugin declared,
+ * allowing a plugins classloader to access classes included in these dependencies via this group.
+ */
+@ApiStatus.Internal
+public interface PluginClassLoaderGroup {
+
+    /**
+     * Attempts to find/load a class from this plugin class loader group using the passed fully qualified name
+     * in any of the classloaders that are part of this group.
+     * <p>
+     * The lookup order across the contained loaders is not defined on the API level and depends purely on the
+     * implementation.
+     *
+     * @param name      the fully qualified name of the class to load
+     * @param resolve   whether the class should be resolved if needed or not
+     * @param requester plugin classloader that is requesting the class from this loader group
+     * @return the class found at the fully qualified class name passed. If the class could not be found, {@code null}
+     * will be returned.
+     * @see ConfiguredPluginClassLoader#loadClass(String, boolean, boolean, boolean)
+     */
+    @Nullable
+    Class<?> getClassByName(String name, boolean resolve, ConfiguredPluginClassLoader requester);
+
+    /**
+     * Removes a configured plugin classloader from this class loader group.
+     * If the classloader is not currently in the list, this method will simply do nothing.
+     *
+     * @param configuredPluginClassLoader the plugin classloader to remove from the group
+     */
+    @Contract(mutates = "this")
+    void remove(ConfiguredPluginClassLoader configuredPluginClassLoader);
+
+    /**
+     * Adds the passed plugin classloader to this group, allowing this group to use it during
+     * {@link #getClassByName(String, boolean, ConfiguredPluginClassLoader)} lookups.
+     * <p>
+     * This method does <b>not</b> query the {@link ClassLoaderAccess} (exposed via {@link #getAccess()}) to ensure
+     * if this group has access to the class loader passed.
+     *
+     * @param configuredPluginClassLoader the plugin classloader to add to this group.
+     */
+    @Contract(mutates = "this")
+    void add(ConfiguredPluginClassLoader configuredPluginClassLoader);
+
+    /**
+     * Provides the class loader access that guards and defines the content of this classloader group.
+     * While not guaranteed contractually (see {@link #add(ConfiguredPluginClassLoader)}), the access generally is
+     * responsible for defining which {@link ConfiguredPluginClassLoader}s should be part of this group and which ones
+     * should not.
+     *
+     * @return the classloader access governing which classloaders should be part of this group and which ones should
+     * not.
+     */
+    ClassLoaderAccess getAccess();
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/entrypoint/DependencyContext.java b/src/main/java/io/papermc/paper/plugin/provider/entrypoint/DependencyContext.java
new file mode 100644
index 0000000000000000000000000000000000000000..44d630c3eb2670c36134b9907519dc986b3761b4
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/entrypoint/DependencyContext.java
@@ -0,0 +1,48 @@
+package io.papermc.paper.plugin.provider.entrypoint;
+
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A dependency context is a read-only abstraction of a type/concept that can resolve dependencies between plugins.
+ * <p>
+ * This may for example be the server wide plugin manager itself, capable of validating if a dependency exists between
+ * two {@link PluginMeta} instances, however the implementation is not limited to such a concrete use-case.
+ */
+@ApiStatus.Internal
+public interface DependencyContext {
+
+    /**
+     * Computes if the passed {@link PluginMeta} defined the passed dependency as a transitive dependency.
+     * A transitive dependency, as implied by its name, may not have been configured directly by the passed plugin
+     * but could also simply be a dependency of a dependency.
+     * <p>
+     * A simple example of this method would be
+     * <pre>{@code
+     * dependencyContext.isTransitiveDependency(pluginMetaA, pluginMetaC);
+     * }</pre>
+     * which would return {@code true} if {@code pluginMetaA} directly or indirectly depends on {@code pluginMetaC}.
+     *
+     * @param plugin the plugin meta this computation should consider the requester of the dependency status for the
+     *               passed potential dependency.
+     * @param depend the potential transitive dependency of the {@code plugin} parameter.
+     * @return a simple boolean flag indicating if {@code plugin} considers {@code depend} as a transitive dependency.
+     */
+    boolean isTransitiveDependency(@NotNull PluginMeta plugin, @NotNull PluginMeta depend);
+
+    /**
+     * Computes if this dependency context is aware of a dependency that provides/matches the passed identifier.
+     * <p>
+     * A dependency in this methods context is any dependable artefact. It does not matter if anything actually depends
+     * on said artefact, its mere existence as a potential dependency is enough for this method to consider it a
+     * dependency. If this dependency context is hence aware of an artefact with the matching identifier, this
+     * method returns {@code true}.
+     *
+     * @param pluginIdentifier the unique identifier of the dependency with which to probe this dependency context.
+     * @return a plain boolean flag indicating if this dependency context is aware of a potential dependency with the
+     * passed identifier.
+     */
+    boolean hasDependency(@NotNull String pluginIdentifier);
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/util/ProviderUtil.java b/src/main/java/io/papermc/paper/plugin/provider/util/ProviderUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..6bf3d212a6156ad9ab0e82d1ca0a04f83f6e4b83
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/util/ProviderUtil.java
@@ -0,0 +1,78 @@
+package io.papermc.paper.plugin.provider.util;
+
+import com.destroystokyo.paper.util.SneakyThrow;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * An <b>internal</b> utility type that holds logic for loading a provider-like type from a classloaders.
+ * Provides, at least in the context of this utility, define themselves as implementations of a specific parent
+ * interface/type, e.g. {@link org.bukkit.plugin.java.JavaPlugin} and implement a no-args constructor.
+ */
+@ApiStatus.Internal
+public class ProviderUtil {
+
+    /**
+     * Loads the class found at the provided fully qualified class name from the passed classloader, creates a new
+     * instance of it using the no-args constructor, that should exist as per this method contract, and casts it to the
+     * provided parent type.
+     *
+     * @param clazz     the fully qualified name of the class to load
+     * @param classType the parent type that the created object found at the {@code clazz} name should be cast to
+     * @param loader    the loader from which the class should be loaded
+     * @param <T>       the generic type of the parent class the created object will be cast to
+     * @return the object instantiated from the class found at the provided FQN, cast to the parent type
+     */
+    @NotNull
+    public static <T> T loadClass(@NotNull String clazz, @NotNull Class<T> classType, @NotNull ClassLoader loader) {
+        return loadClass(clazz, classType, loader, null);
+    }
+
+    /**
+     * Loads the class found at the provided fully qualified class name from the passed classloader, creates a new
+     * instance of it using the no-args constructor, that should exist as per this method contract, and casts it to the
+     * provided parent type.
+     *
+     * @param clazz     the fully qualified name of the class to load
+     * @param classType the parent type that the created object found at the {@code clazz} name should be cast to
+     * @param loader    the loader from which the class should be loaded
+     * @param onError   a runnable that is executed before any unknown exception is raised through a sneaky throw.
+     * @param <T>       the generic type of the parent class the created object will be cast to
+     * @return the object instantiated from the class found at the provided fully qualified class name, cast to the
+     * parent type
+     */
+    @NotNull
+    public static <T> T loadClass(@NotNull String clazz, @NotNull Class<T> classType, @NotNull ClassLoader loader, @Nullable Runnable onError) {
+        try {
+            T clazzInstance;
+
+            try {
+                Class<?> jarClass = Class.forName(clazz, true, loader);
+
+                Class<? extends T> pluginClass;
+                try {
+                    pluginClass = jarClass.asSubclass(classType);
+                } catch (ClassCastException ex) {
+                    throw new ClassCastException("class '%s' does not extend '%s'".formatted(clazz, classType));
+                }
+
+                clazzInstance = pluginClass.getDeclaredConstructor().newInstance();
+            } catch (IllegalAccessException exception) {
+                throw new RuntimeException("No public constructor");
+            } catch (InstantiationException exception) {
+                throw new RuntimeException("Abnormal class instantiation", exception);
+            }
+
+            return clazzInstance;
+        } catch (Throwable e) {
+            if (onError != null) {
+                onError.run();
+            }
+            SneakyThrow.sneaky(e);
+        }
+
+        throw new AssertionError(); // Shouldn't happen
+    }
+
+}
diff --git a/src/main/java/org/bukkit/Bukkit.java b/src/main/java/org/bukkit/Bukkit.java
index 194261bf20bb727d207a2429fa59abf0acf61b19..ac0cc4813f46c9da4e311bffe7b48fa32e64fc0f 100644
--- a/src/main/java/org/bukkit/Bukkit.java
+++ b/src/main/java/org/bukkit/Bukkit.java
@@ -108,6 +108,16 @@ public final class Bukkit {
         return server.getVersion();
     }
 
+    /**
+     * Gets the version string of this server implementation.
+     *
+     * @return version of this server implementation
+     */
+    @NotNull
+    public static File getPluginsFolder() {
+        return server.getPluginsFolder();
+    }
+
     /**
      * Gets the Bukkit version that this server is running.
      *
diff --git a/src/main/java/org/bukkit/Server.java b/src/main/java/org/bukkit/Server.java
index a7fcd00ae37f9a2026759642562b1059c9dd9526..889891df337b4e38fda9b185869d07b50c15ada0 100644
--- a/src/main/java/org/bukkit/Server.java
+++ b/src/main/java/org/bukkit/Server.java
@@ -57,6 +57,18 @@ import org.jetbrains.annotations.Nullable;
  */
 public interface Server extends PluginMessageRecipient, net.kyori.adventure.audience.ForwardingAudience { // Paper
 
+    /**
+     * Returns the de facto plugins directory, generally used for storing plugin jars to be loaded,
+     * as well as their {@link org.bukkit.plugin.Plugin#getDataFolder() data folders}.
+     *
+     * <p>Plugins should use {@link org.bukkit.plugin.Plugin#getDataFolder()} rather than traversing this
+     * directory manually when determining the location in which to store their data and configuration files.</p>
+     *
+     * @return plugins directory
+     */
+    @NotNull
+    File getPluginsFolder();
+
     /**
      * Used for all administrative messages, such as an operator using a
      * command.
diff --git a/src/main/java/org/bukkit/UnsafeValues.java b/src/main/java/org/bukkit/UnsafeValues.java
index 9b6e50a1f72d1fd56c5520cdeec97e63837ea339..32b61bfaf2b69260e0c89328e61aeba66c08ebfa 100644
--- a/src/main/java/org/bukkit/UnsafeValues.java
+++ b/src/main/java/org/bukkit/UnsafeValues.java
@@ -178,6 +178,14 @@ public interface UnsafeValues {
     @org.jetbrains.annotations.NotNull
     public com.google.common.collect.Multimap<org.bukkit.attribute.Attribute, org.bukkit.attribute.AttributeModifier> getItemAttributes(@org.jetbrains.annotations.NotNull Material material, @org.jetbrains.annotations.NotNull org.bukkit.inventory.EquipmentSlot equipmentSlot);
 
+    // Paper start - lifecycle event API
+    /**
+     * @hidden
+     */
+    @org.jetbrains.annotations.ApiStatus.Internal
+    io.papermc.paper.plugin.lifecycle.event.LifecycleEventManager<org.bukkit.plugin.Plugin> createPluginLifecycleEventManager(final org.bukkit.plugin.java.JavaPlugin plugin, final java.util.function.BooleanSupplier registrationCheck);
+    // Paper end - lifecycle event API
+
     /**
      * Returns the server's protocol version.
      *
diff --git a/src/main/java/org/bukkit/plugin/AuthorNagException.java b/src/main/java/org/bukkit/plugin/AuthorNagException.java
index 20985f022afa077ba0907f3404175cb4500fa29f..6565a441467e323b3e1871485a9e09e4cfbea050 100644
--- a/src/main/java/org/bukkit/plugin/AuthorNagException.java
+++ b/src/main/java/org/bukkit/plugin/AuthorNagException.java
@@ -1,8 +1,5 @@
 package org.bukkit.plugin;
 
-/**
- * Author nag exception
- */
 @SuppressWarnings("serial")
 public class AuthorNagException extends RuntimeException {
     private final String message;
diff --git a/src/main/java/org/bukkit/plugin/EventExecutor.java b/src/main/java/org/bukkit/plugin/EventExecutor.java
index 9026e108ccd3a88aee1267ee275137befa646455..6ab9ea80ef752fb5a5dea45b5048be6339d6152d 100644
--- a/src/main/java/org/bukkit/plugin/EventExecutor.java
+++ b/src/main/java/org/bukkit/plugin/EventExecutor.java
@@ -1,22 +1,20 @@
 package org.bukkit.plugin;
 
+import com.destroystokyo.paper.event.executor.MethodHandleEventExecutor;
+import com.destroystokyo.paper.event.executor.StaticMethodHandleEventExecutor;
+import com.destroystokyo.paper.event.executor.asm.ASMEventExecutorGenerator;
+import com.destroystokyo.paper.event.executor.asm.ClassDefiner;
+import com.google.common.base.Preconditions;
 import org.bukkit.event.Event;
 import org.bukkit.event.EventException;
 import org.bukkit.event.Listener;
 import org.jetbrains.annotations.NotNull;
 
-// Paper start
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.function.Function;
-
-import com.destroystokyo.paper.event.executor.MethodHandleEventExecutor;
-import com.destroystokyo.paper.event.executor.StaticMethodHandleEventExecutor;
-import com.destroystokyo.paper.event.executor.asm.ASMEventExecutorGenerator;
-import com.destroystokyo.paper.event.executor.asm.ClassDefiner;
-import com.google.common.base.Preconditions;
 // Paper end
 
 /**
@@ -51,6 +49,12 @@ public interface EventExecutor {
         Preconditions.checkArgument(m.getParameterCount() != 0, "Incorrect number of arguments %s", m.getParameterCount());
         Preconditions.checkArgument(m.getParameterTypes()[0] == eventClass, "First parameter %s doesn't match event class %s", m.getParameterTypes()[0], eventClass);
         ClassDefiner definer = ClassDefiner.getInstance();
+        if (m.getReturnType() != Void.TYPE) {
+            final org.bukkit.plugin.java.JavaPlugin plugin = org.bukkit.plugin.java.JavaPlugin.getProvidingPlugin(m.getDeclaringClass());
+            org.bukkit.Bukkit.getLogger().warning("@EventHandler method " + m.getDeclaringClass().getName() + (Modifier.isStatic(m.getModifiers()) ? '.' : '#') + m.getName()
+                + " returns non-void type " + m.getReturnType().getName() + ". This is unsupported behavior and will no longer work in a future version of Paper."
+                + " This should be reported to the developers of " + plugin.getPluginMeta().getDisplayName() + " (" + String.join(",", plugin.getPluginMeta().getAuthors()) + ')');
+        }
         if (Modifier.isStatic(m.getModifiers())) {
             return new StaticMethodHandleEventExecutor(eventClass, m);
         } else if (definer.isBypassAccessChecks() || Modifier.isPublic(m.getDeclaringClass().getModifiers()) && Modifier.isPublic(m.getModifiers())) {
@@ -64,9 +68,18 @@ public interface EventExecutor {
             try {
                 EventExecutor asmExecutor = executorClass.newInstance();
                 // Define a wrapper to conform to bukkit stupidity (passing in events that don't match and wrapper exception)
-                return (listener, event) -> {
-                    if (!eventClass.isInstance(event)) return;
-                    asmExecutor.execute(listener, event);
+                return new EventExecutor() {
+                    @Override
+                    public void execute(@NotNull Listener listener, @NotNull Event event) throws EventException {
+                        if (!eventClass.isInstance(event)) return;
+                        asmExecutor.execute(listener, event);
+                    }
+
+                    @Override
+                    @NotNull
+                    public String toString() {
+                        return "ASMEventExecutor['" + m + "']";
+                    }
                 };
             } catch (InstantiationException | IllegalAccessException e) {
                 throw new AssertionError("Unable to initialize generated event executor", e);
diff --git a/src/main/java/org/bukkit/plugin/Plugin.java b/src/main/java/org/bukkit/plugin/Plugin.java
index 79890c68f1ad31f951dfdbd9a16dac500ec58c40..7f439e3782eed8abb595212abae9801647949cb2 100644
--- a/src/main/java/org/bukkit/plugin/Plugin.java
+++ b/src/main/java/org/bukkit/plugin/Plugin.java
@@ -1,8 +1,5 @@
 package org.bukkit.plugin;
 
-import java.io.File;
-import java.io.InputStream;
-import java.util.logging.Logger;
 import org.bukkit.Server;
 import org.bukkit.command.TabExecutor;
 import org.bukkit.configuration.file.FileConfiguration;
@@ -10,12 +7,16 @@ import org.bukkit.generator.ChunkGenerator;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
+import java.io.File;
+import java.io.InputStream;
+import java.util.logging.Logger;
+
 /**
  * Represents a Plugin
  * <p>
  * The use of {@link PluginBase} is recommended for actual Implementation
  */
-public interface Plugin extends TabExecutor {
+public interface Plugin extends TabExecutor, io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner { // Paper
     /**
      * Returns the folder that the plugin data's files are located in. The
      * folder may not yet exist.
@@ -29,10 +30,21 @@ public interface Plugin extends TabExecutor {
      * Returns the plugin.yaml file containing the details for this plugin
      *
      * @return Contents of the plugin.yaml file
+     * @deprecated May be inaccurate due to different plugin implementations.
+     * @see Plugin#getPluginMeta()
      */
+    @Deprecated // Paper
     @NotNull
     public PluginDescriptionFile getDescription();
 
+    // Paper start
+    /**
+     * Gets the plugin meta for this plugin.
+     * @return configuration
+     */
+    @NotNull
+    io.papermc.paper.plugin.configuration.PluginMeta getPluginMeta();
+    // Paper end
     /**
      * Gets a {@link FileConfiguration} for this plugin, read through
      * "config.yml"
@@ -93,6 +105,7 @@ public interface Plugin extends TabExecutor {
      *
      * @return PluginLoader that controls this plugin
      */
+    @Deprecated(forRemoval = true) // Paper - The PluginLoader system will not function in the near future
     @NotNull
     public PluginLoader getPluginLoader();
 
@@ -156,6 +169,7 @@ public interface Plugin extends TabExecutor {
     @Nullable
     public ChunkGenerator getDefaultWorldGenerator(@NotNull String worldName, @Nullable String id);
 
+
     /**
      * Returns the plugin logger associated with this server's logger. The
      * returned logger automatically tags all log messages with the plugin's
@@ -183,4 +197,14 @@ public interface Plugin extends TabExecutor {
      */
     @NotNull
     public String getName();
+
+    // Paper start - lifecycle events
+    /**
+     * Get the lifecycle event manager for registering handlers
+     * for lifecycle events allowed on the {@link Plugin}.
+     *
+     * @return the lifecycle event manager
+     */
+    @NotNull io.papermc.paper.plugin.lifecycle.event.LifecycleEventManager<Plugin> getLifecycleManager();
+    // Paper end - lifecycle events
 }
diff --git a/src/main/java/org/bukkit/plugin/PluginBase.java b/src/main/java/org/bukkit/plugin/PluginBase.java
index 94f8ceb965cecb5669a84a0ec61c0f706c2a2673..e773db6da357ad210eb24d4c389af2dc84ce450a 100644
--- a/src/main/java/org/bukkit/plugin/PluginBase.java
+++ b/src/main/java/org/bukkit/plugin/PluginBase.java
@@ -31,6 +31,6 @@ public abstract class PluginBase implements Plugin {
     @Override
     @NotNull
     public final String getName() {
-        return getDescription().getName();
+        return getPluginMeta().getName(); // Paper
     }
 }
diff --git a/src/main/java/org/bukkit/plugin/PluginDescriptionFile.java b/src/main/java/org/bukkit/plugin/PluginDescriptionFile.java
index 053993e562a0f449654e345f01bc8138ed60ad2c..8dd2fcc22c1f3381f9b9be82f1da459a2463045a 100644
--- a/src/main/java/org/bukkit/plugin/PluginDescriptionFile.java
+++ b/src/main/java/org/bukkit/plugin/PluginDescriptionFile.java
@@ -3,32 +3,28 @@ package org.bukkit.plugin;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import java.io.InputStream;
-import java.io.Reader;
-import java.io.Writer;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.regex.Pattern;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandExecutor;
-import org.bukkit.command.CommandSender;
-import org.bukkit.command.PluginCommand;
-import org.bukkit.command.TabCompleter;
+import org.bukkit.command.*;
 import org.bukkit.permissions.Permissible;
 import org.bukkit.permissions.Permission;
 import org.bukkit.permissions.PermissionDefault;
 import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.ApiStatus;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
+import org.yaml.snakeyaml.DumperOptions;
 import org.yaml.snakeyaml.LoaderOptions;
 import org.yaml.snakeyaml.Yaml;
 import org.yaml.snakeyaml.constructor.AbstractConstruct;
 import org.yaml.snakeyaml.constructor.SafeConstructor;
 import org.yaml.snakeyaml.nodes.Node;
 import org.yaml.snakeyaml.nodes.Tag;
+import org.yaml.snakeyaml.representer.Representer;
+
+import java.io.InputStream;
+import java.io.Reader;
+import java.io.Writer;
+import java.util.*;
+import java.util.regex.Pattern;
 
 /**
  * This type is the runtime-container for the information in the plugin.yml.
@@ -195,12 +191,13 @@ import org.yaml.snakeyaml.nodes.Tag;
  *      inferno.burningdeaths: true
  *</pre></blockquote>
  */
-public final class PluginDescriptionFile {
+public final class PluginDescriptionFile implements io.papermc.paper.plugin.configuration.PluginMeta { // Paper
     private static final Pattern VALID_NAME = Pattern.compile("^[A-Za-z0-9 _.-]+$");
     private static final ThreadLocal<Yaml> YAML = new ThreadLocal<Yaml>() {
         @Override
         @NotNull
         protected Yaml initialValue() {
+            DumperOptions dumperOptions = new DumperOptions();
             return new Yaml(new SafeConstructor(new LoaderOptions()) {
                 {
                     yamlConstructors.put(null, new AbstractConstruct() {
@@ -230,7 +227,7 @@ public final class PluginDescriptionFile {
                         });
                     }
                 }
-            });
+            }, new Representer(dumperOptions), dumperOptions, new PluginDescriptionResolver());
         }
     };
     String rawName = null;
@@ -255,6 +252,77 @@ public final class PluginDescriptionFile {
     private Set<PluginAwareness> awareness = ImmutableSet.of();
     private String apiVersion = null;
     private List<String> libraries = ImmutableList.of();
+    // Paper start - plugin loader api
+    private String paperPluginLoader;
+    @ApiStatus.Internal @Nullable
+    public String getPaperPluginLoader() {
+        return this.paperPluginLoader;
+    }
+    // Paper end - plugin loader api
+    // Paper start - oh my goddddd
+    /**
+     * Don't use this.
+     */
+    @ApiStatus.Internal
+    public PluginDescriptionFile(String rawName, String name, List<String> provides, String main, String classLoaderOf, List<String> depend, List<String> softDepend, List<String> loadBefore, String version, Map<String, Map<String, Object>> commands, String description, List<String> authors, List<String> contributors, String website, String prefix, PluginLoadOrder order, List<Permission> permissions, PermissionDefault defaultPerm, Set<PluginAwareness> awareness, String apiVersion, List<String> libraries) {
+        this.rawName = rawName;
+        this.name = name;
+        this.provides = provides;
+        this.main = main;
+        this.classLoaderOf = classLoaderOf;
+        this.depend = depend;
+        this.softDepend = softDepend;
+        this.loadBefore = loadBefore;
+        this.version = version;
+        this.commands = commands;
+        this.description = description;
+        this.authors = authors;
+        this.contributors = contributors;
+        this.website = website;
+        this.prefix = prefix;
+        this.order = order;
+        this.permissions = permissions;
+        this.defaultPerm = defaultPerm;
+        this.awareness = awareness;
+        this.apiVersion = apiVersion;
+        this.libraries = libraries;
+    }
+
+    @Override
+    public @NotNull String getMainClass() {
+        return this.main;
+    }
+
+    @Override
+    public @NotNull PluginLoadOrder getLoadOrder() {
+        return this.order;
+    }
+
+    @Override
+    public @Nullable String getLoggerPrefix() {
+        return this.prefix;
+    }
+
+    @Override
+    public @NotNull List<String> getPluginDependencies() {
+        return this.depend;
+    }
+
+    @Override
+    public @NotNull List<String> getPluginSoftDependencies() {
+        return this.softDepend;
+    }
+
+    @Override
+    public @NotNull List<String> getLoadBeforePlugins() {
+        return this.loadBefore;
+    }
+
+    @Override
+    public @NotNull List<String> getProvidedPlugins() {
+        return this.provides;
+    }
+    // Paper end
 
     public PluginDescriptionFile(@NotNull final InputStream stream) throws InvalidDescriptionException {
         loadMap(asMap(YAML.get().load(stream)));
@@ -332,7 +400,7 @@ public final class PluginDescriptionFile {
      * <li>An entry of this list can be referenced in {@link #getDepend()},
      *    {@link #getSoftDepend()}, and {@link #getLoadBefore()}.
      * <li><code>provides</code> must be in <a
-     *     href="http://en.wikipedia.org/wiki/YAML#Lists">YAML list
+     *     href="https://en.wikipedia.org/wiki/YAML#Lists">YAML list
      *     format</a>.
      * </ul>
      * <p>
@@ -451,7 +519,7 @@ public final class PluginDescriptionFile {
      * <li>A SpigotMC forum handle or email address is recommended.
      * <li>Is displayed when a user types <code>/version PluginName</code>
      * <li><code>authors</code> must be in <a
-     *     href="http://en.wikipedia.org/wiki/YAML#Lists">YAML list
+     *     href="https://en.wikipedia.org/wiki/YAML#Lists">YAML list
      *     format</a>.
      * </ul>
      * <p>
@@ -488,7 +556,7 @@ public final class PluginDescriptionFile {
      * <li>A SpigotMC forum handle or email address is recommended.
      * <li>Is displayed when a user types <code>/version PluginName</code>
      * <li><code>contributors</code> must be in <a
-     *     href="http://en.wikipedia.org/wiki/YAML#Lists">YAML list
+     *     href="https://en.wikipedia.org/wiki/YAML#Lists">YAML list
      *     format</a>.
      * </ul>
      * <p>
@@ -535,7 +603,7 @@ public final class PluginDescriptionFile {
      *     href=https://en.wikipedia.org/wiki/Circular_dependency>network</a>,
      *     all plugins in that network will fail.
      * <li><code>depend</code> must be in <a
-     *     href="http://en.wikipedia.org/wiki/YAML#Lists">YAML list
+     *     href="https://en.wikipedia.org/wiki/YAML#Lists">YAML list
      *     format</a>.
      * </ul>
      * <p>
@@ -567,7 +635,7 @@ public final class PluginDescriptionFile {
      *     or soft-dependending each other), it will arbitrarily choose a
      *     plugin that can be resolved when ignoring soft-dependencies.
      * <li><code>softdepend</code> must be in <a
-     *     href="http://en.wikipedia.org/wiki/YAML#Lists">YAML list
+     *     href="https://en.wikipedia.org/wiki/YAML#Lists">YAML list
      *     format</a>.
      * </ul>
      * <p>
@@ -594,7 +662,7 @@ public final class PluginDescriptionFile {
      *     specified plugin's {@link #getSoftDepend()} include {@link
      *     #getName() this plugin}.
      * <li><code>loadbefore</code> must be in <a
-     *     href="http://en.wikipedia.org/wiki/YAML#Lists">YAML list
+     *     href="https://en.wikipedia.org/wiki/YAML#Lists">YAML list
      *     format</a>.
      * </ul>
      * <p>
@@ -658,7 +726,7 @@ public final class PluginDescriptionFile {
      *     <td><code>aliases</code></td>
      *     <td>{@link PluginCommand#setAliases(List)}</td>
      *     <td>String or <a
-     *         href="http://en.wikipedia.org/wiki/YAML#Lists">List</a> of
+     *         href="https://en.wikipedia.org/wiki/YAML#Lists">List</a> of
      *         strings</td>
      *     <td>Alternative command names, with special usefulness for commands
      *         that are already registered. <i>Aliases are not effective when
@@ -806,7 +874,7 @@ public final class PluginDescriptionFile {
      *         <p>
      *         Child permissions may be defined in a number of ways:<ul>
      *         <li>Children may be defined as a <a
-     *             href="http://en.wikipedia.org/wiki/YAML#Lists">list</a> of
+     *             href="https://en.wikipedia.org/wiki/YAML#Lists">list</a> of
      *             names. Using a list will treat all children associated
      *             positively to their parent.
      *         <li>Children may be defined as a map. Each permission name maps
@@ -914,7 +982,7 @@ public final class PluginDescriptionFile {
      *     by the API, effectively discluding any derived type from any
      *     plugin's classpath.
      * <li><code>awareness</code> must be in <a
-     *     href="http://en.wikipedia.org/wiki/YAML#Lists">YAML list
+     *     href="https://en.wikipedia.org/wiki/YAML#Lists">YAML list
      *     format</a>.
      * </ul>
      * <p>
@@ -1082,7 +1150,7 @@ public final class PluginDescriptionFile {
 
         if (map.get("load") != null) {
             try {
-                order = PluginLoadOrder.valueOf(((String) map.get("load")).toUpperCase(java.util.Locale.ENGLISH).replaceAll("\\W", ""));
+                order = PluginLoadOrder.valueOf(((String) map.get("load")).toUpperCase(Locale.ROOT).replaceAll("\\W", ""));
             } catch (ClassCastException ex) {
                 throw new InvalidDescriptionException(ex, "load is of wrong type");
             } catch (IllegalArgumentException ex) {
@@ -1164,6 +1232,23 @@ public final class PluginDescriptionFile {
         } else {
             libraries = ImmutableList.<String>of();
         }
+        // Paper start - plugin loader api
+        if (map.containsKey("paper-plugin-loader")) {
+            this.paperPluginLoader = map.get("paper-plugin-loader").toString();
+        }
+
+        /*
+        Allow skipping the Bukkit/Spigot 'libraries' list. By default, both the 'libraries'
+        list and the 'paper-plugin-loader' will contribute libraries. It may be desired to only
+        use one or the other. (i.e. 'libraries' on Spigot and 'paper-plugin-loader' on Paper)
+        */
+        if (map.containsKey("paper-skip-libraries")) {
+            String skip = map.get("paper-skip-libraries").toString();
+            if (skip.equalsIgnoreCase("true")) {
+                this.libraries = ImmutableList.of();
+            }
+        }
+        // Paper end - plugin loader api
 
         try {
             lazyPermissions = (Map<?, ?>) map.get("permissions");
@@ -1259,14 +1344,13 @@ public final class PluginDescriptionFile {
         if (object instanceof Map) {
             return (Map<?, ?>) object;
         }
-        throw new InvalidDescriptionException(object + " is not properly structured.");
+        throw new InvalidDescriptionException("Plugin description file is empty or not properly structured. Is " + object + "but should be a map.");
     }
 
     /**
      * @return internal use
-     * @deprecated Internal use
      */
-    @Deprecated
+    @ApiStatus.Internal
     @NotNull
     public String getRawName() {
         return rawName;
diff --git a/src/main/java/org/bukkit/plugin/PluginDescriptionResolver.java b/src/main/java/org/bukkit/plugin/PluginDescriptionResolver.java
new file mode 100644
index 0000000000000000000000000000000000000000..2697841d0afd661d41eb14c11efa59a9006f8b1e
--- /dev/null
+++ b/src/main/java/org/bukkit/plugin/PluginDescriptionResolver.java
@@ -0,0 +1,18 @@
+package org.bukkit.plugin;
+
+import org.yaml.snakeyaml.nodes.Tag;
+import org.yaml.snakeyaml.resolver.Resolver;
+
+final class PluginDescriptionResolver extends Resolver {
+
+    @Override
+    protected void addImplicitResolvers() {
+        addImplicitResolver(Tag.BOOL, BOOL, "yYnNtTfFoO");
+        // addImplicitResolver(Tag.FLOAT, FLOAT, "-+0123456789."); // Don't resolve floats. Preserve strings - SPIGOT-7370
+        addImplicitResolver(Tag.INT, INT, "-+0123456789");
+        addImplicitResolver(Tag.MERGE, MERGE, "<");
+        addImplicitResolver(Tag.NULL, NULL, "~nN\0");
+        addImplicitResolver(Tag.NULL, EMPTY, null);
+        addImplicitResolver(Tag.TIMESTAMP, TIMESTAMP, "0123456789");
+    }
+}
diff --git a/src/main/java/org/bukkit/plugin/PluginLoader.java b/src/main/java/org/bukkit/plugin/PluginLoader.java
index 6ab9cd8213cbe35943748dcf42948d5fc048c84c..9dc4103104cd63506b05aa0a49adcb28e4fd39a5 100644
--- a/src/main/java/org/bukkit/plugin/PluginLoader.java
+++ b/src/main/java/org/bukkit/plugin/PluginLoader.java
@@ -1,17 +1,19 @@
 package org.bukkit.plugin;
 
+import org.bukkit.event.Event;
+import org.bukkit.event.Listener;
+import org.jetbrains.annotations.NotNull;
+
 import java.io.File;
 import java.util.Map;
 import java.util.Set;
 import java.util.regex.Pattern;
-import org.bukkit.event.Event;
-import org.bukkit.event.Listener;
-import org.jetbrains.annotations.NotNull;
 
 /**
  * Represents a plugin loader, which handles direct access to specific types
  * of plugins
  */
+@Deprecated(forRemoval = true) // Paper - The PluginLoader system will not function in the near future
 public interface PluginLoader {
 
     /**
@@ -77,18 +79,4 @@ public interface PluginLoader {
      * @param plugin Plugin to disable
      */
     public void disablePlugin(@NotNull Plugin plugin);
-    // Paper start - close Classloader on disable
-    /**
-     * Disables the specified plugin
-     * <p>
-     * Attempting to disable a plugin that is not enabled will have no effect
-     *
-     * @param plugin Plugin to disable
-     * @param closeClassloader if the classloader for the Plugin should be closed
-     */
-    // provide default to allow other PluginLoader implementations to work
-    default public void disablePlugin(@NotNull Plugin plugin, boolean closeClassloader) {
-        disablePlugin(plugin);
-    }
-    // Paper end - close Classloader on disable
 }
diff --git a/src/main/java/org/bukkit/plugin/PluginLogger.java b/src/main/java/org/bukkit/plugin/PluginLogger.java
index 0182370014e0dc8b74759933ab984d16678f6ec3..533f0b6f8145884de006ea2525dbc9a288d3ce22 100644
--- a/src/main/java/org/bukkit/plugin/PluginLogger.java
+++ b/src/main/java/org/bukkit/plugin/PluginLogger.java
@@ -1,9 +1,10 @@
 package org.bukkit.plugin;
 
+import org.jetbrains.annotations.NotNull;
+
 import java.util.logging.Level;
 import java.util.logging.LogRecord;
 import java.util.logging.Logger;
-import org.jetbrains.annotations.NotNull;
 
 /**
  * The PluginLogger class is a modified {@link Logger} that prepends all
diff --git a/src/main/java/org/bukkit/plugin/PluginManager.java b/src/main/java/org/bukkit/plugin/PluginManager.java
index 86cc5025ad98f7a752c51713b7cd6a39d5136ecc..00073e15dd1f3f13d04b10be6216043eae8a3b64 100644
--- a/src/main/java/org/bukkit/plugin/PluginManager.java
+++ b/src/main/java/org/bukkit/plugin/PluginManager.java
@@ -1,7 +1,5 @@
 package org.bukkit.plugin;
 
-import java.io.File;
-import java.util.Set;
 import org.bukkit.event.Event;
 import org.bukkit.event.EventPriority;
 import org.bukkit.event.Listener;
@@ -11,10 +9,13 @@ import org.jetbrains.annotations.Contract;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
+import java.io.File;
+import java.util.Set;
+
 /**
  * Handles all plugin management from the Server
  */
-public interface PluginManager {
+public interface PluginManager extends io.papermc.paper.plugin.PermissionManager { // Paper
 
     /**
      * Registers the specified plugin loader
@@ -23,6 +24,7 @@ public interface PluginManager {
      * @throws IllegalArgumentException Thrown when the given Class is not a
      *     valid PluginLoader
      */
+    @Deprecated(forRemoval = true) // Paper - The PluginLoader system will not function in the near future
     public void registerInterface(@NotNull Class<? extends PluginLoader> loader) throws IllegalArgumentException;
 
     /**
@@ -89,6 +91,15 @@ public interface PluginManager {
     @NotNull
     public Plugin[] loadPlugins(@NotNull File directory);
 
+    /**
+     * Loads the plugins in the list of the files
+     *
+     * @param files List of files containing plugins to load
+     * @return A list of all plugins loaded
+     */
+    @NotNull
+    public Plugin[] loadPlugins(@NotNull File[] files);
+
     /**
      * Disables all the loaded plugins
      */
@@ -161,18 +172,6 @@ public interface PluginManager {
      */
     public void disablePlugin(@NotNull Plugin plugin);
 
-    // Paper start - close Classloader on disable
-    /**
-     * Disables the specified plugin
-     * <p>
-     * Attempting to disable a plugin that is not enabled will have no effect
-     *
-     * @param plugin Plugin to disable
-     * @param closeClassloader if the classloader for the Plugin should be closed
-     */
-    public void disablePlugin(@NotNull Plugin plugin, boolean closeClassloader);
-    // Paper end - close Classloader on disable
-
     /**
      * Gets a {@link Permission} from its fully qualified name
      *
@@ -315,4 +314,17 @@ public interface PluginManager {
      * @return True if event timings are to be used
      */
     public boolean useTimings();
+
+    // Paper start
+    @org.jetbrains.annotations.ApiStatus.Internal
+    boolean isTransitiveDependency(io.papermc.paper.plugin.configuration.PluginMeta pluginMeta, io.papermc.paper.plugin.configuration.PluginMeta dependencyConfig);
+
+    /**
+     * Sets the permission manager to be used for this server.
+     *
+     * @param permissionManager permission manager
+     */
+    @org.jetbrains.annotations.ApiStatus.Experimental
+    void overridePermissionManager(@NotNull Plugin plugin, @Nullable io.papermc.paper.plugin.PermissionManager permissionManager);
+    // Paper end
 }
diff --git a/src/main/java/org/bukkit/plugin/RegisteredListener.java b/src/main/java/org/bukkit/plugin/RegisteredListener.java
index 419aec56b0e3fa8bcec2ea7f340caa3456b57d00..09ba893b17560e1d7f9148a9568dd7e7723ad678 100644
--- a/src/main/java/org/bukkit/plugin/RegisteredListener.java
+++ b/src/main/java/org/bukkit/plugin/RegisteredListener.java
@@ -1,10 +1,6 @@
 package org.bukkit.plugin;
 
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.Event;
-import org.bukkit.event.EventException;
-import org.bukkit.event.EventPriority;
-import org.bukkit.event.Listener;
+import org.bukkit.event.*;
 import org.jetbrains.annotations.NotNull;
 
 /**
@@ -78,4 +74,27 @@ public class RegisteredListener {
     public boolean isIgnoringCancelled() {
         return ignoreCancelled;
     }
+
+    // Paper start
+    /**
+     * Get the executor for this registration.
+     *
+     * @return executor
+     */
+    @NotNull
+    public EventExecutor getExecutor() {
+        return this.executor;
+    }
+
+    @Override
+    public String toString() {
+        return "RegisteredListener{"
+            + "plugin=\"" + this.plugin.getName()
+            + "\", listener=\"" + this.listener
+            + "\", executor=\"" + this.executor
+            + "\", priority=\"" + this.priority.name() + " (" + this.priority.getSlot() + ")"
+            + "\", ignoringCancelled=" + this.ignoreCancelled
+            + "}";
+    }
+    // Paper end
 }
diff --git a/src/main/java/org/bukkit/plugin/ServicesManager.java b/src/main/java/org/bukkit/plugin/ServicesManager.java
index 5066c938a2fe9ebfe54571066e52ccf06855a72c..547c515ccfa80e542f54059b1f78ff1220cc0bca 100644
--- a/src/main/java/org/bukkit/plugin/ServicesManager.java
+++ b/src/main/java/org/bukkit/plugin/ServicesManager.java
@@ -1,10 +1,11 @@
 package org.bukkit.plugin;
 
-import java.util.Collection;
-import java.util.List;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
+import java.util.Collection;
+import java.util.List;
+
 /**
  * Manages services and service providers. Services are an interface
  * specifying a list of methods that a provider must implement. Providers are
diff --git a/src/main/java/org/bukkit/plugin/SimplePluginManager.java b/src/main/java/org/bukkit/plugin/SimplePluginManager.java
index 0e25119564dfa9cb12f3c5dc5f653d7f2c147a9d..d2e78b855c40d551840a8fa0f95b92f26cf5e18e 100644
--- a/src/main/java/org/bukkit/plugin/SimplePluginManager.java
+++ b/src/main/java/org/bukkit/plugin/SimplePluginManager.java
@@ -5,29 +5,6 @@ import com.google.common.collect.ImmutableSet;
 import com.google.common.graph.GraphBuilder;
 import com.google.common.graph.Graphs;
 import com.google.common.graph.MutableGraph;
-import java.io.File;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.WeakHashMap;
-import java.util.logging.Level;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import com.destroystokyo.paper.event.server.ServerExceptionEvent;
-import com.destroystokyo.paper.exception.ServerEventException;
-import com.destroystokyo.paper.exception.ServerPluginEnableDisableException;
-import org.apache.commons.lang.Validate;
 import org.bukkit.Server;
 import org.bukkit.World;
 import org.bukkit.command.Command;
@@ -44,9 +21,20 @@ import org.bukkit.util.FileUtil;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
+import java.io.File;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.*;
+import java.util.logging.Level;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
 /**
  * Handles all plugin management from the Server
  */
+@Deprecated(forRemoval = true) // Paper - This implementation may be replaced in a future version of Paper.
+// Plugins may still reflect into this class to modify permission logic for the time being.
 public final class SimplePluginManager implements PluginManager {
     private final Server server;
     private final Map<Pattern, PluginLoader> fileAssociations = new HashMap<Pattern, PluginLoader>();
@@ -55,12 +43,14 @@ public final class SimplePluginManager implements PluginManager {
     private MutableGraph<String> dependencyGraph = GraphBuilder.directed().build();
     private File updateDirectory;
     private final SimpleCommandMap commandMap;
-    private final Map<String, Permission> permissions = new HashMap<String, Permission>();
-    private final Map<Boolean, Set<Permission>> defaultPerms = new LinkedHashMap<Boolean, Set<Permission>>();
-    private final Map<String, Map<Permissible, Boolean>> permSubs = new HashMap<String, Map<Permissible, Boolean>>();
-    private final Map<Boolean, Map<Permissible, Boolean>> defSubs = new HashMap<Boolean, Map<Permissible, Boolean>>();
+    // Paper start
+    public final Map<String, Permission> permissions = new HashMap<String, Permission>();
+    public final Map<Boolean, Set<Permission>> defaultPerms = new LinkedHashMap<Boolean, Set<Permission>>();
+    public final Map<String, Map<Permissible, Boolean>> permSubs = new HashMap<String, Map<Permissible, Boolean>>();
+    public final Map<Boolean, Map<Permissible, Boolean>> defSubs = new HashMap<Boolean, Map<Permissible, Boolean>>();
+    public PluginManager paperPluginManager;
+    // Paper end
     private boolean useTimings = false;
-    private File pluginsDirectory; public @Nullable File pluginsDirectory() { return this.pluginsDirectory; } // Paper
 
     public SimplePluginManager(@NotNull Server instance, @NotNull SimpleCommandMap commandMap) {
         server = instance;
@@ -121,18 +111,43 @@ public final class SimplePluginManager implements PluginManager {
     }
     @NotNull
     public Plugin[] loadPlugins(final @NotNull File directory, final @NotNull List<File> extraPluginJars) {
-        this.pluginsDirectory = directory;
         // Paper end
-        Validate.notNull(directory, "Directory cannot be null");
-        Validate.isTrue(directory.isDirectory(), "Directory must be a directory");
-
-        List<Plugin> result = new ArrayList<Plugin>();
-        Set<Pattern> filters = fileAssociations.keySet();
+        if (true) {
+            List<Plugin> pluginList = new ArrayList<>();
+            java.util.Collections.addAll(pluginList, this.paperPluginManager.loadPlugins(directory));
+            for (File file : extraPluginJars) {
+                try {
+                    pluginList.add(this.paperPluginManager.loadPlugin(file));
+                } catch (Exception e) {
+                    this.server.getLogger().log(Level.SEVERE, "Plugin loading error!", e);
+                }
+            }
+            return pluginList.toArray(new Plugin[0]);
+        }
+        Preconditions.checkArgument(directory != null, "Directory cannot be null");
+        Preconditions.checkArgument(directory.isDirectory(), "Directory must be a directory");
 
         if (!(server.getUpdateFolder().equals(""))) {
             updateDirectory = new File(directory, server.getUpdateFolder());
         }
 
+        return loadPlugins(directory.listFiles());
+    }
+
+    /**
+     * Loads the plugins in the list of the files
+     *
+     * @param files List of files containing plugins to load
+     * @return A list of all plugins loaded
+     */
+    @NotNull
+    public Plugin[] loadPlugins(@NotNull File[] files) {
+        // TODO Replace with Paper plugin loader
+        Preconditions.checkArgument(files != null, "File list cannot be null");
+
+        List<Plugin> result = new ArrayList<Plugin>();
+        Set<Pattern> filters = fileAssociations.keySet();
+
         Map<String, File> plugins = new HashMap<String, File>();
         Set<String> loadedPlugins = new HashSet<String>();
         Map<String, String> pluginsProvided = new HashMap<>();
@@ -140,11 +155,7 @@ public final class SimplePluginManager implements PluginManager {
         Map<String, Collection<String>> softDependencies = new HashMap<String, Collection<String>>();
 
         // This is where it figures out all possible plugins
-        // Paper start - extra jars
-        final List<File> pluginJars = new ArrayList<>(java.util.Arrays.asList(directory.listFiles()));
-        pluginJars.addAll(extraPluginJars);
-        for (File file : pluginJars) {
-            // Paper end
+        for (File file : files) {
             PluginLoader loader = null;
             for (Pattern filter : filters) {
                 Matcher match = filter.matcher(file.getName());
@@ -160,25 +171,24 @@ public final class SimplePluginManager implements PluginManager {
                 description = loader.getPluginDescription(file);
                 String name = description.getName();
                 if (name.equalsIgnoreCase("bukkit") || name.equalsIgnoreCase("minecraft") || name.equalsIgnoreCase("mojang")) {
-                    server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + file.getParentFile().getPath() + "': Restricted Name"); // Paper
+                    server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "': Restricted Name");
                     continue;
                 } else if (description.rawName.indexOf(' ') != -1) {
-                    server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + file.getParentFile().getPath() + "': uses the space-character (0x20) in its name"); // Paper
+                    server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "': uses the space-character (0x20) in its name");
                     continue;
                 }
             } catch (InvalidDescriptionException ex) {
-                server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + file.getParentFile().getPath() + "'", ex); // Paper
+                server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "'", ex);
                 continue;
             }
 
             File replacedFile = plugins.put(description.getName(), file);
             if (replacedFile != null) {
                 server.getLogger().severe(String.format(
-                    "Ambiguous plugin name `%s' for files `%s' and `%s' in `%s'",
-                    description.getName(),
-                    file.getPath(),
-                    replacedFile.getPath(),
-                    file.getParentFile().getPath() // Paper
+                        "Ambiguous plugin name `%s' for files `%s' and `%s'",
+                        description.getName(),
+                        file.getPath(),
+                        replacedFile.getPath()
                 ));
             }
 
@@ -195,11 +205,10 @@ public final class SimplePluginManager implements PluginManager {
                 File pluginFile = plugins.get(provided);
                 if (pluginFile != null) {
                     server.getLogger().warning(String.format(
-                            "`%s provides `%s' while this is also the name of `%s' in `%s'",
+                            "`%s provides `%s' while this is also the name of `%s'",
                             file.getPath(),
                             provided,
-                            pluginFile.getPath(),
-                            file.getParentFile().getPath() // Paper
+                            pluginFile.getPath()
                     ));
                 } else {
                     String replacedPlugin = pluginsProvided.put(provided, description.getName());
@@ -264,7 +273,6 @@ public final class SimplePluginManager implements PluginManager {
 
                 if (dependencies.containsKey(plugin)) {
                     Iterator<String> dependencyIterator = dependencies.get(plugin).iterator();
-                    final Set<String> missingHardDependencies = new HashSet<>(dependencies.get(plugin).size()); // Paper - list all missing hard depends
 
                     while (dependencyIterator.hasNext()) {
                         String dependency = dependencyIterator.next();
@@ -275,21 +283,17 @@ public final class SimplePluginManager implements PluginManager {
 
                         // We have a dependency not found
                         } else if (!plugins.containsKey(dependency) && !pluginsProvided.containsKey(dependency)) {
-                            // Paper start
-                            missingHardDependencies.add(dependency);
-                        }
-                    }
-                    if (!missingHardDependencies.isEmpty()) {
-                            // Paper end
                             missingDependency = false;
                             pluginIterator.remove();
                             softDependencies.remove(plugin);
                             dependencies.remove(plugin);
 
                             server.getLogger().log(
-                                Level.SEVERE,
-                                "Could not load '" + entry.getValue().getPath() + "' in folder '" + entry.getValue().getParentFile().getPath() + "'", // Paper
-                                new UnknownDependencyException(missingHardDependencies, plugin)); // Paper
+                                    Level.SEVERE,
+                                    "Could not load '" + entry.getValue().getPath() + "'",
+                                    new UnknownDependencyException("Unknown dependency " + dependency + ". Please download and install " + dependency + " to run this plugin."));
+                            break;
+                        }
                     }
 
                     if (dependencies.containsKey(plugin) && dependencies.get(plugin).isEmpty()) {
@@ -325,11 +329,11 @@ public final class SimplePluginManager implements PluginManager {
                             loadedPlugins.add(loadedPlugin.getName());
                             loadedPlugins.addAll(loadedPlugin.getDescription().getProvides());
                         } else {
-                            server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + file.getParentFile().getPath() + "'"); // Paper
+                            server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "'");
                         }
                         continue;
                     } catch (InvalidPluginException ex) {
-                        server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + file.getParentFile().getPath() + "'", ex); // Paper
+                        server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "'", ex);
                     }
                 }
             }
@@ -356,11 +360,11 @@ public final class SimplePluginManager implements PluginManager {
                                 loadedPlugins.add(loadedPlugin.getName());
                                 loadedPlugins.addAll(loadedPlugin.getDescription().getProvides());
                             } else {
-                                server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + file.getParentFile().getPath() + "'"); // Paper
+                                server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "'");
                             }
                             break;
                         } catch (InvalidPluginException ex) {
-                            server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + file.getParentFile().getPath() + "'", ex); // Paper
+                            server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "'", ex);
                         }
                     }
                 }
@@ -373,7 +377,7 @@ public final class SimplePluginManager implements PluginManager {
                     while (failedPluginIterator.hasNext()) {
                         File file = failedPluginIterator.next();
                         failedPluginIterator.remove();
-                        server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + file.getParentFile().getPath() + "': circular dependency detected"); // Paper
+                        server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "': circular dependency detected");
                     }
                 }
             }
@@ -397,7 +401,16 @@ public final class SimplePluginManager implements PluginManager {
     @Override
     @Nullable
     public synchronized Plugin loadPlugin(@NotNull File file) throws InvalidPluginException, UnknownDependencyException {
-        Validate.notNull(file, "File cannot be null");
+        Preconditions.checkArgument(file != null, "File cannot be null");
+        // Paper start
+        if (true) {
+            try {
+                return this.paperPluginManager.loadPlugin(file);
+            } catch (InvalidDescriptionException ignored) {
+                return null;
+            }
+        }
+        // Paper end
 
         checkUpdate(file);
 
@@ -417,9 +430,9 @@ public final class SimplePluginManager implements PluginManager {
 
         if (result != null) {
             plugins.add(result);
-            lookupNames.put(result.getDescription().getName().toLowerCase(java.util.Locale.ENGLISH), result); // Paper
+            lookupNames.put(result.getDescription().getName().toLowerCase(Locale.ENGLISH), result); // Paper
             for (String provided : result.getDescription().getProvides()) {
-                lookupNames.putIfAbsent(provided.toLowerCase(java.util.Locale.ENGLISH), result); // Paper
+                lookupNames.putIfAbsent(provided.toLowerCase(Locale.ENGLISH), result); // Paper
             }
         }
 
@@ -448,12 +461,14 @@ public final class SimplePluginManager implements PluginManager {
     @Override
     @Nullable
     public synchronized Plugin getPlugin(@NotNull String name) {
-        return lookupNames.get(name.replace(' ', '_').toLowerCase(java.util.Locale.ENGLISH)); // Paper
+        if (true) {return this.paperPluginManager.getPlugin(name);} // Paper
+        return lookupNames.get(name.replace(' ', '_').toLowerCase(Locale.ENGLISH)); // Paper
     }
 
     @Override
     @NotNull
     public synchronized Plugin[] getPlugins() {
+        if (true) {return this.paperPluginManager.getPlugins();} // Paper
         return plugins.toArray(new Plugin[plugins.size()]);
     }
 
@@ -467,6 +482,7 @@ public final class SimplePluginManager implements PluginManager {
      */
     @Override
     public boolean isPluginEnabled(@NotNull String name) {
+        if (true) {return this.paperPluginManager.isPluginEnabled(name);} // Paper
         Plugin plugin = getPlugin(name);
 
         return isPluginEnabled(plugin);
@@ -479,7 +495,8 @@ public final class SimplePluginManager implements PluginManager {
      * @return true if the plugin is enabled, otherwise false
      */
     @Override
-    public synchronized boolean isPluginEnabled(@Nullable Plugin plugin) { // Paper - synchronize
+    public boolean isPluginEnabled(@Nullable Plugin plugin) {
+        if (true) {return this.paperPluginManager.isPluginEnabled(plugin);} // Paper
         if ((plugin != null) && (plugins.contains(plugin))) {
             return plugin.isEnabled();
         } else {
@@ -488,7 +505,8 @@ public final class SimplePluginManager implements PluginManager {
     }
 
     @Override
-    public synchronized void enablePlugin(@NotNull final Plugin plugin) { // Paper - synchronize
+    public void enablePlugin(@NotNull final Plugin plugin) {
+        if (true) {this.paperPluginManager.enablePlugin(plugin); return;} // Paper
         if (!plugin.isEnabled()) {
             List<Command> pluginCommands = PluginCommandYamlParser.parse(plugin);
 
@@ -509,28 +527,19 @@ public final class SimplePluginManager implements PluginManager {
 
     @Override
     public void disablePlugins() {
-        disablePlugins(false);
-    }
-
-    public void disablePlugins(boolean closeClassloaders) {
-        // Paper end - close Classloader on disable
+        if (true) {this.paperPluginManager.disablePlugins(); return;} // Paper
         Plugin[] plugins = getPlugins();
         for (int i = plugins.length - 1; i >= 0; i--) {
-            disablePlugin(plugins[i], closeClassloaders); // Paper - close Classloader on disable
+            disablePlugin(plugins[i]);
         }
     }
 
     @Override
     public void disablePlugin(@NotNull final Plugin plugin) {
-        disablePlugin(plugin, false);
-    }
-
-    @Override
-    public synchronized void disablePlugin(@NotNull final Plugin plugin, boolean closeClassloader) { // Paper - synchronize
-        // Paper end - close Classloader on disable
+        if (true) {this.paperPluginManager.disablePlugin(plugin); return;} // Paper
         if (plugin.isEnabled()) {
             try {
-                plugin.getPluginLoader().disablePlugin(plugin, closeClassloader); // Paper - close Classloader on disable
+                plugin.getPluginLoader().disablePlugin(plugin);
             } catch (Throwable ex) {
                 handlePluginException("Error occurred (in the plugin loader) while disabling "
                         + plugin.getDescription().getFullName() + " (Is it up to date?)", ex, plugin); // Paper
@@ -578,14 +587,15 @@ public final class SimplePluginManager implements PluginManager {
     // Paper start
     private void handlePluginException(String msg, Throwable ex, Plugin plugin) {
         server.getLogger().log(Level.SEVERE, msg, ex);
-        callEvent(new ServerExceptionEvent(new ServerPluginEnableDisableException(msg, ex, plugin)));
+        callEvent(new com.destroystokyo.paper.event.server.ServerExceptionEvent(new com.destroystokyo.paper.exception.ServerPluginEnableDisableException(msg, ex, plugin)));
     }
     // Paper end
 
     @Override
     public void clearPlugins() {
+        if (true) {this.paperPluginManager.clearPlugins(); return;} // Paper
         synchronized (this) {
-            disablePlugins(true); // Paper - close Classloader on disable
+            disablePlugins();
             plugins.clear();
             lookupNames.clear();
             dependencyGraph = GraphBuilder.directed().build();
@@ -596,7 +606,6 @@ public final class SimplePluginManager implements PluginManager {
             defaultPerms.get(false).clear();
         }
     }
-    private void fireEvent(Event event) { callEvent(event); } // Paper - support old method incase plugin uses reflection
 
     /**
      * Calls an event with the given details.
@@ -605,13 +614,24 @@ public final class SimplePluginManager implements PluginManager {
      */
     @Override
     public void callEvent(@NotNull Event event) {
-        // Paper - replace callEvent by merging to below method
-        if (event.isAsynchronous() && server.isPrimaryThread()) {
-            throw new IllegalStateException(event.getEventName() + " may only be triggered asynchronously.");
-        } else if (!event.isAsynchronous() && !server.isPrimaryThread() && !server.isStopping() ) {
-            throw new IllegalStateException(event.getEventName() + " may only be triggered synchronously.");
+        if (true) {this.paperPluginManager.callEvent(event); return;} // Paper
+        if (event.isAsynchronous()) {
+            if (Thread.holdsLock(this)) {
+                throw new IllegalStateException(event.getEventName() + " cannot be triggered asynchronously from inside synchronized code.");
+            }
+            if (server.isPrimaryThread()) {
+                throw new IllegalStateException(event.getEventName() + " cannot be triggered asynchronously from primary server thread.");
+            }
+        } else {
+            if (!server.isPrimaryThread()) {
+                throw new IllegalStateException(event.getEventName() + " cannot be triggered asynchronously from another thread.");
+            }
         }
 
+        fireEvent(event);
+    }
+
+    private void fireEvent(@NotNull Event event) {
         HandlerList handlers = event.getHandlers();
         RegisteredListener[] listeners = handlers.getRegisteredListeners();
 
@@ -639,8 +659,8 @@ public final class SimplePluginManager implements PluginManager {
                 // Paper start - error reporting
                 String msg = "Could not pass event " + event.getEventName() + " to " + registration.getPlugin().getDescription().getFullName();
                 server.getLogger().log(Level.SEVERE, msg, ex);
-                if (!(event instanceof ServerExceptionEvent)) { // We don't want to cause an endless event loop
-                    callEvent(new ServerExceptionEvent(new ServerEventException(msg, ex, registration.getPlugin(), registration.getListener(), event)));
+                if (!(event instanceof com.destroystokyo.paper.event.server.ServerExceptionEvent)) { // We don't want to cause an endless event loop
+                    callEvent(new com.destroystokyo.paper.event.server.ServerExceptionEvent(new com.destroystokyo.paper.exception.ServerEventException(msg, ex, registration.getPlugin(), registration.getListener(), event)));
                 }
                 // Paper end
             }
@@ -649,6 +669,7 @@ public final class SimplePluginManager implements PluginManager {
 
     @Override
     public void registerEvents(@NotNull Listener listener, @NotNull Plugin plugin) {
+        if (true) {this.paperPluginManager.registerEvents(listener, plugin); return;} // Paper
         if (!plugin.isEnabled()) {
             throw new IllegalPluginAccessException("Plugin attempted to register " + listener + " while not enabled");
         }
@@ -678,10 +699,11 @@ public final class SimplePluginManager implements PluginManager {
      */
     @Override
     public void registerEvent(@NotNull Class<? extends Event> event, @NotNull Listener listener, @NotNull EventPriority priority, @NotNull EventExecutor executor, @NotNull Plugin plugin, boolean ignoreCancelled) {
-        Validate.notNull(listener, "Listener cannot be null");
-        Validate.notNull(priority, "Priority cannot be null");
-        Validate.notNull(executor, "Executor cannot be null");
-        Validate.notNull(plugin, "Plugin cannot be null");
+        Preconditions.checkArgument(listener != null, "Listener cannot be null");
+        Preconditions.checkArgument(priority != null, "Priority cannot be null");
+        Preconditions.checkArgument(executor != null, "Executor cannot be null");
+        Preconditions.checkArgument(plugin != null, "Plugin cannot be null");
+        if (true) {this.paperPluginManager.registerEvent(event, listener, priority, executor, plugin, ignoreCancelled); return;} // Paper
 
         if (!plugin.isEnabled()) {
             throw new IllegalPluginAccessException("Plugin attempted to register " + event + " while not enabled");
@@ -700,9 +722,14 @@ public final class SimplePluginManager implements PluginManager {
         try {
             Method method = getRegistrationClass(type).getDeclaredMethod("getHandlerList");
             method.setAccessible(true);
+
+            if (!Modifier.isStatic(method.getModifiers())) {
+                throw new IllegalAccessException("getHandlerList must be static");
+            }
+
             return (HandlerList) method.invoke(null);
         } catch (Exception e) {
-            throw new IllegalPluginAccessException(e.toString());
+            throw new IllegalPluginAccessException("Error while registering listener for event type " + type.toString() + ": " + e.toString());
         }
     }
 
@@ -725,17 +752,20 @@ public final class SimplePluginManager implements PluginManager {
     @Override
     @Nullable
     public Permission getPermission(@NotNull String name) {
-        return permissions.get(name.toLowerCase(java.util.Locale.ENGLISH));
+        if (true) {return this.paperPluginManager.getPermission(name);} // Paper
+        return permissions.get(name.toLowerCase(Locale.ROOT));
     }
 
     @Override
     public void addPermission(@NotNull Permission perm) {
+        if (true) {this.paperPluginManager.addPermission(perm); return;} // Paper
         addPermission(perm, true);
     }
 
     @Deprecated
     public void addPermission(@NotNull Permission perm, boolean dirty) {
-        String name = perm.getName().toLowerCase(java.util.Locale.ENGLISH);
+        if (true) {this.paperPluginManager.addPermission(perm); return;} // Paper - This just has a performance implication, use the better api to avoid this.
+        String name = perm.getName().toLowerCase(Locale.ROOT);
 
         if (permissions.containsKey(name)) {
             throw new IllegalArgumentException("The permission " + name + " is already defined!");
@@ -748,22 +778,26 @@ public final class SimplePluginManager implements PluginManager {
     @Override
     @NotNull
     public Set<Permission> getDefaultPermissions(boolean op) {
+        if (true) {return this.paperPluginManager.getDefaultPermissions(op);} // Paper
         return ImmutableSet.copyOf(defaultPerms.get(op));
     }
 
     @Override
     public void removePermission(@NotNull Permission perm) {
+        if (true) {this.paperPluginManager.removePermission(perm); return;} // Paper
         removePermission(perm.getName());
     }
 
     @Override
     public void removePermission(@NotNull String name) {
-        permissions.remove(name.toLowerCase(java.util.Locale.ENGLISH));
+        if (true) {this.paperPluginManager.removePermission(name); return;} // Paper
+        permissions.remove(name.toLowerCase(Locale.ROOT));
     }
 
     @Override
     public void recalculatePermissionDefaults(@NotNull Permission perm) {
-        if (perm != null && permissions.containsKey(perm.getName().toLowerCase(java.util.Locale.ENGLISH))) {
+        if (true) {this.paperPluginManager.recalculatePermissionDefaults(perm); return;} // Paper
+        if (perm != null && permissions.containsKey(perm.getName().toLowerCase(Locale.ROOT))) {
             defaultPerms.get(true).remove(perm);
             defaultPerms.get(false).remove(perm);
 
@@ -802,7 +836,8 @@ public final class SimplePluginManager implements PluginManager {
 
     @Override
     public void subscribeToPermission(@NotNull String permission, @NotNull Permissible permissible) {
-        String name = permission.toLowerCase(java.util.Locale.ENGLISH);
+        if (true) {this.paperPluginManager.subscribeToPermission(permission, permissible); return;} // Paper
+        String name = permission.toLowerCase(Locale.ROOT);
         Map<Permissible, Boolean> map = permSubs.get(name);
 
         if (map == null) {
@@ -815,7 +850,8 @@ public final class SimplePluginManager implements PluginManager {
 
     @Override
     public void unsubscribeFromPermission(@NotNull String permission, @NotNull Permissible permissible) {
-        String name = permission.toLowerCase(java.util.Locale.ENGLISH);
+        if (true) {this.paperPluginManager.unsubscribeFromPermission(permission, permissible); return;} // Paper
+        String name = permission.toLowerCase(Locale.ROOT);
         Map<Permissible, Boolean> map = permSubs.get(name);
 
         if (map != null) {
@@ -830,7 +866,8 @@ public final class SimplePluginManager implements PluginManager {
     @Override
     @NotNull
     public Set<Permissible> getPermissionSubscriptions(@NotNull String permission) {
-        String name = permission.toLowerCase(java.util.Locale.ENGLISH);
+        if (true) {return this.paperPluginManager.getPermissionSubscriptions(permission);} // Paper
+        String name = permission.toLowerCase(Locale.ROOT);
         Map<Permissible, Boolean> map = permSubs.get(name);
 
         if (map == null) {
@@ -842,6 +879,7 @@ public final class SimplePluginManager implements PluginManager {
 
     @Override
     public void subscribeToDefaultPerms(boolean op, @NotNull Permissible permissible) {
+        if (true) {this.paperPluginManager.subscribeToDefaultPerms(op, permissible); return;} // Paper
         Map<Permissible, Boolean> map = defSubs.get(op);
 
         if (map == null) {
@@ -854,6 +892,7 @@ public final class SimplePluginManager implements PluginManager {
 
     @Override
     public void unsubscribeFromDefaultPerms(boolean op, @NotNull Permissible permissible) {
+        if (true) {this.paperPluginManager.unsubscribeFromDefaultPerms(op, permissible); return;} // Paper
         Map<Permissible, Boolean> map = defSubs.get(op);
 
         if (map != null) {
@@ -868,6 +907,7 @@ public final class SimplePluginManager implements PluginManager {
     @Override
     @NotNull
     public Set<Permissible> getDefaultPermSubscriptions(boolean op) {
+        if (true) {return this.paperPluginManager.getDefaultPermSubscriptions(op);} // Paper
         Map<Permissible, Boolean> map = defSubs.get(op);
 
         if (map == null) {
@@ -880,6 +920,7 @@ public final class SimplePluginManager implements PluginManager {
     @Override
     @NotNull
     public Set<Permission> getPermissions() {
+        if (true) {return this.paperPluginManager.getPermissions();} // Paper
         return new HashSet<Permission>(permissions.values());
     }
 
@@ -903,6 +944,7 @@ public final class SimplePluginManager implements PluginManager {
 
     @Override
     public boolean useTimings() {
+        if (true) {return this.paperPluginManager.useTimings();} // Paper
         return co.aikar.timings.Timings.isTimingsEnabled(); // Spigot
     }
 
@@ -917,10 +959,25 @@ public final class SimplePluginManager implements PluginManager {
 
     // Paper start
     public void clearPermissions() {
+        if (true) {this.paperPluginManager.clearPermissions(); return;} // Paper
         permissions.clear();
         defaultPerms.get(true).clear();
         defaultPerms.get(false).clear();
     }
-    // Paper end
 
+    @Override
+    public boolean isTransitiveDependency(io.papermc.paper.plugin.configuration.PluginMeta pluginMeta, io.papermc.paper.plugin.configuration.PluginMeta dependencyConfig) {
+        return this.paperPluginManager.isTransitiveDependency(pluginMeta, dependencyConfig);
+    }
+
+    @Override
+    public void overridePermissionManager(@NotNull Plugin plugin, @Nullable io.papermc.paper.plugin.PermissionManager permissionManager) {
+        this.paperPluginManager.overridePermissionManager(plugin, permissionManager);
+    }
+
+    @Override
+    public void addPermissions(@NotNull List<Permission> perm) {
+        this.paperPluginManager.addPermissions(perm);
+    }
+    // Paper end
 }
diff --git a/src/main/java/org/bukkit/plugin/SimpleServicesManager.java b/src/main/java/org/bukkit/plugin/SimpleServicesManager.java
index f3dd8490230b85be7e03f7c0f0c20b476e1574fd..aaa95ca8b99d62b3dfb7b689e09d077b75aa90b5 100644
--- a/src/main/java/org/bukkit/plugin/SimpleServicesManager.java
+++ b/src/main/java/org/bukkit/plugin/SimpleServicesManager.java
@@ -2,20 +2,14 @@ package org.bukkit.plugin;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.NoSuchElementException;
-import java.util.Set;
 import org.bukkit.Bukkit;
 import org.bukkit.event.server.ServiceRegisterEvent;
 import org.bukkit.event.server.ServiceUnregisterEvent;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
+import java.util.*;
+
 /**
  * A simple services manager.
  */
diff --git a/src/main/java/org/bukkit/plugin/UnknownDependencyException.java b/src/main/java/org/bukkit/plugin/UnknownDependencyException.java
index 7b2e607a21f1173d98ee84581881411176380625..310c4041963a3f1e0a26e39a6da12a9bfdb51edc 100644
--- a/src/main/java/org/bukkit/plugin/UnknownDependencyException.java
+++ b/src/main/java/org/bukkit/plugin/UnknownDependencyException.java
@@ -26,19 +26,6 @@ public class UnknownDependencyException extends RuntimeException {
         super(message);
     }
 
-    // Paper start
-    /**
-     * Create a new {@link UnknownDependencyException} with a message informing
-     * about which dependencies are missing for what plugin.
-     *
-     * @param missingDependencies missing dependencies
-     * @param pluginName plugin which is missing said dependencies
-     */
-    public UnknownDependencyException(final @org.jetbrains.annotations.NotNull java.util.Collection<String> missingDependencies, final @org.jetbrains.annotations.NotNull String pluginName) {
-        this("Unknown/missing dependency plugins: [" + String.join(", ", missingDependencies) + "]. Please download and install these plugins to run '" + pluginName + "'.");
-    }
-    // Paper end
-
     /**
      * Constructs a new UnknownDependencyException based on the given
      * Exception
@@ -56,4 +43,16 @@ public class UnknownDependencyException extends RuntimeException {
     public UnknownDependencyException() {
 
     }
+    // Paper start
+    /**
+     * Create a new {@link UnknownDependencyException} with a message informing
+     * about which dependencies are missing for what plugin.
+     *
+     * @param missingDependencies missing dependencies
+     * @param pluginName plugin which is missing said dependencies
+     */
+    public UnknownDependencyException(final @org.jetbrains.annotations.NotNull java.util.Collection<String> missingDependencies, final @org.jetbrains.annotations.NotNull String pluginName) {
+        this("Unknown/missing dependency plugins: [" + String.join(", ", missingDependencies) + "]. Please download and install these plugins to run '" + pluginName + "'.");
+    }
+    // Paper end
 }
diff --git a/src/main/java/org/bukkit/plugin/java/JavaPlugin.java b/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
index 04fa3991f6ce4e9dad804f28fc6c947695857089..ca90a0fc9f5198c731bc1bc793428bbba2e21ce6 100644
--- a/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
+++ b/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
@@ -1,19 +1,7 @@
 package org.bukkit.plugin.java;
 
 import com.google.common.base.Charsets;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.io.Reader;
-import java.net.URL;
-import java.net.URLConnection;
-import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import org.apache.commons.lang.Validate;
+import com.google.common.base.Preconditions;
 import org.bukkit.Server;
 import org.bukkit.command.Command;
 import org.bukkit.command.CommandSender;
@@ -24,12 +12,21 @@ import org.bukkit.generator.ChunkGenerator;
 import org.bukkit.plugin.PluginBase;
 import org.bukkit.plugin.PluginDescriptionFile;
 import org.bukkit.plugin.PluginLoader;
-import org.bukkit.plugin.PluginLogger;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
+import java.io.*;
+import java.net.URL;
+import java.net.URLConnection;
+import java.util.List;
+import java.util.Locale;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
 /**
- * Represents a Java plugin
+ * Represents a Java plugin and its main class. It contains fundamental methods
+ * and fields for a plugin to be loaded and work properly. This is an indirect
+ * implementation of {@link org.bukkit.plugin.Plugin}.
  */
 public abstract class JavaPlugin extends PluginBase {
     private boolean isEnabled = false;
@@ -37,21 +34,30 @@ public abstract class JavaPlugin extends PluginBase {
     private Server server = null;
     private File file = null;
     private PluginDescriptionFile description = null;
+    private io.papermc.paper.plugin.configuration.PluginMeta pluginMeta = null; // Paper
     private File dataFolder = null;
     private ClassLoader classLoader = null;
     private boolean naggable = true;
     private FileConfiguration newConfig = null;
     private File configFile = null;
-    Logger logger = null; // Paper - PluginLogger -> Logger, package-private
+    private Logger logger = null; // Paper - PluginLogger -> Logger
+    // Paper start - lifecycle events
+    @SuppressWarnings("deprecation")
+    private final io.papermc.paper.plugin.lifecycle.event.LifecycleEventManager<org.bukkit.plugin.Plugin> lifecycleEventManager = org.bukkit.Bukkit.getUnsafe().createPluginLifecycleEventManager(this, () -> this.allowsLifecycleRegistration);
+    private boolean allowsLifecycleRegistration = true;
+    // Paper end
 
     public JavaPlugin() {
-        final ClassLoader classLoader = this.getClass().getClassLoader();
-        if (!(classLoader instanceof PluginClassLoader)) {
-            throw new IllegalStateException("JavaPlugin requires " + PluginClassLoader.class.getName());
+        // Paper start
+        if (this.getClass().getClassLoader() instanceof io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader configuredPluginClassLoader) {
+            configuredPluginClassLoader.init(this);
+        } else {
+            throw new IllegalStateException("JavaPlugin requires to be created by a valid classloader.");
         }
-        ((PluginClassLoader) classLoader).initialize(this);
+        // Paper end
     }
 
+    @Deprecated(forRemoval = true) // Paper
     protected JavaPlugin(@NotNull final JavaPluginLoader loader, @NotNull final PluginDescriptionFile description, @NotNull final File dataFolder, @NotNull final File file) {
         final ClassLoader classLoader = this.getClass().getClassLoader();
         if (classLoader instanceof PluginClassLoader) {
@@ -76,9 +82,12 @@ public abstract class JavaPlugin extends PluginBase {
      * Gets the associated PluginLoader responsible for this plugin
      *
      * @return PluginLoader that controls this plugin
+     * @deprecated Plugin loading now occurs at a point which makes it impossible to expose this
+     * behavior. This instance will only throw unsupported operation exceptions.
      */
     @NotNull
     @Override
+    @Deprecated(forRemoval = true) // Paper
     public final PluginLoader getPluginLoader() {
         return loader;
     }
@@ -119,13 +128,20 @@ public abstract class JavaPlugin extends PluginBase {
      * Returns the plugin.yaml file containing the details for this plugin
      *
      * @return Contents of the plugin.yaml file
+     * @deprecated No longer applicable to all types of plugins
      */
     @NotNull
     @Override
+    @Deprecated
     public final PluginDescriptionFile getDescription() {
         return description;
     }
 
+    @NotNull
+    public final io.papermc.paper.plugin.configuration.PluginMeta getPluginMeta() {
+        return this.pluginMeta;
+    }
+
     @NotNull
     @Override
     public FileConfiguration getConfig() {
@@ -255,32 +271,41 @@ public abstract class JavaPlugin extends PluginBase {
      *
      * @param enabled true if enabled, otherwise false
      */
-    protected final void setEnabled(final boolean enabled) {
+    @org.jetbrains.annotations.ApiStatus.Internal // Paper
+    public final void setEnabled(final boolean enabled) { // Paper
         if (isEnabled != enabled) {
             isEnabled = enabled;
 
             if (isEnabled) {
+                try { // Paper - lifecycle events
                 onEnable();
+                } finally { this.allowsLifecycleRegistration = false; } // Paper - lifecycle events
             } else {
                 onDisable();
             }
         }
     }
 
-
-    final void init(@NotNull PluginLoader loader, @NotNull Server server, @NotNull PluginDescriptionFile description, @NotNull File dataFolder, @NotNull File file, @NotNull ClassLoader classLoader) {
-        this.loader = loader;
+    // Paper start
+    private static class DummyPluginLoaderImplHolder {
+        private static final PluginLoader INSTANCE =  net.kyori.adventure.util.Services.service(PluginLoader.class)
+            .orElseThrow();
+    }
+    public final void init(@NotNull PluginLoader loader, @NotNull Server server, @NotNull PluginDescriptionFile description, @NotNull File dataFolder, @NotNull File file, @NotNull ClassLoader classLoader) {
+        init(server, description, dataFolder, file, classLoader, description, com.destroystokyo.paper.utils.PaperPluginLogger.getLogger(description));
+        this.pluginMeta = description;
+    }
+    public final void init(@NotNull Server server, @NotNull PluginDescriptionFile description, @NotNull File dataFolder, @NotNull File file, @NotNull ClassLoader classLoader, @Nullable io.papermc.paper.plugin.configuration.PluginMeta configuration, @NotNull Logger logger) {
+    // Paper end
+        this.loader = DummyPluginLoaderImplHolder.INSTANCE; // Paper
         this.server = server;
         this.file = file;
         this.description = description;
         this.dataFolder = dataFolder;
         this.classLoader = classLoader;
         this.configFile = new File(dataFolder, "config.yml");
-        // Paper start
-        if (this.logger == null) {
-            this.logger = com.destroystokyo.paper.utils.PaperPluginLogger.getLogger(this.description);
-        }
-        // Paper end
+        this.pluginMeta = configuration; // Paper
+        this.logger = logger; // Paper
     }
 
     /**
@@ -310,11 +335,11 @@ public abstract class JavaPlugin extends PluginBase {
      */
     @Nullable
     public PluginCommand getCommand(@NotNull String name) {
-        String alias = name.toLowerCase(java.util.Locale.ENGLISH);
+        String alias = name.toLowerCase(Locale.ROOT);
         PluginCommand command = getServer().getPluginCommand(alias);
 
         if (command == null || command.getPlugin() != this) {
-            command = getServer().getPluginCommand(description.getName().toLowerCase(java.util.Locale.ENGLISH) + ":" + alias);
+            command = getServer().getPluginCommand(description.getName().toLowerCase(Locale.ROOT) + ":" + alias);
         }
 
         if (command != null && command.getPlugin() == this) {
@@ -386,15 +411,15 @@ public abstract class JavaPlugin extends PluginBase {
      */
     @NotNull
     public static <T extends JavaPlugin> T getPlugin(@NotNull Class<T> clazz) {
-        Validate.notNull(clazz, "Null class cannot have a plugin");
+        Preconditions.checkArgument(clazz != null, "Null class cannot have a plugin");
         if (!JavaPlugin.class.isAssignableFrom(clazz)) {
             throw new IllegalArgumentException(clazz + " does not extend " + JavaPlugin.class);
         }
         final ClassLoader cl = clazz.getClassLoader();
-        if (!(cl instanceof PluginClassLoader)) {
-            throw new IllegalArgumentException(clazz + " is not initialized by " + PluginClassLoader.class);
+        if (!(cl instanceof io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader configuredPluginClassLoader)) { // Paper
+            throw new IllegalArgumentException(clazz + " is not initialized by a " + io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader.class); // Paper
         }
-        JavaPlugin plugin = ((PluginClassLoader) cl).plugin;
+        JavaPlugin plugin = configuredPluginClassLoader.getPlugin(); // Paper
         if (plugin == null) {
             throw new IllegalStateException("Cannot get plugin for " + clazz + " from a static initializer");
         }
@@ -415,15 +440,22 @@ public abstract class JavaPlugin extends PluginBase {
      */
     @NotNull
     public static JavaPlugin getProvidingPlugin(@NotNull Class<?> clazz) {
-        Validate.notNull(clazz, "Null class cannot have a plugin");
+        Preconditions.checkArgument(clazz != null, "Null class cannot have a plugin");
         final ClassLoader cl = clazz.getClassLoader();
-        if (!(cl instanceof PluginClassLoader)) {
-            throw new IllegalArgumentException(clazz + " is not provided by " + PluginClassLoader.class);
+        if (!(cl instanceof io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader configuredPluginClassLoader)) { // Paper
+            throw new IllegalArgumentException(clazz + " is not provided by a " + io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader.class); // Paper
         }
-        JavaPlugin plugin = ((PluginClassLoader) cl).plugin;
+        JavaPlugin plugin = configuredPluginClassLoader.getPlugin(); // Paper
         if (plugin == null) {
             throw new IllegalStateException("Cannot get plugin for " + clazz + " from a static initializer");
         }
         return plugin;
     }
+
+    // Paper start - lifecycle events
+    @Override
+    public final @NotNull io.papermc.paper.plugin.lifecycle.event.LifecycleEventManager<org.bukkit.plugin.Plugin> getLifecycleManager() {
+        return this.lifecycleEventManager;
+    }
+    // Paper end - lifecycle events
 }
diff --git a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
index b622cedeeee017f042bcf92485d81832030a8030..8671438e4f3d7f3c6ce001193c378c58314386c8 100644
--- a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
@@ -1,24 +1,6 @@
 package org.bukkit.plugin.java;
 
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.CopyOnWriteArrayList;
-import java.util.jar.JarEntry;
-import java.util.jar.JarFile;
-import java.util.logging.Level;
-import java.util.regex.Pattern;
-import org.apache.commons.lang.Validate;
+import com.google.common.base.Preconditions;
 import org.bukkit.Server;
 import org.bukkit.Warning;
 import org.bukkit.Warning.WarningState;
@@ -30,33 +12,34 @@ import org.bukkit.event.EventHandler;
 import org.bukkit.event.Listener;
 import org.bukkit.event.server.PluginDisableEvent;
 import org.bukkit.event.server.PluginEnableEvent;
-import org.bukkit.plugin.AuthorNagException;
-import org.bukkit.plugin.EventExecutor;
-import org.bukkit.plugin.InvalidDescriptionException;
-import org.bukkit.plugin.InvalidPluginException;
-import org.bukkit.plugin.Plugin;
-import org.bukkit.plugin.PluginDescriptionFile;
-import org.bukkit.plugin.PluginLoader;
-import org.bukkit.plugin.RegisteredListener;
-import org.bukkit.plugin.SimplePluginManager;
-import org.bukkit.plugin.TimedRegisteredListener;
-import org.bukkit.plugin.UnknownDependencyException;
+import org.bukkit.plugin.*;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
-import org.spigotmc.CustomTimingsHandler; // Spigot
 import org.yaml.snakeyaml.error.YAMLException;
 
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.*;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+import java.util.logging.Level;
+import java.util.regex.Pattern;
+
 /**
  * Represents a Java plugin loader, allowing plugins in the form of .jar
  */
+@Deprecated(forRemoval = true) // Paper - The PluginLoader system will not function in the near future. This implementation will be moved.
 public final class JavaPluginLoader implements PluginLoader {
     final Server server;
-    private static final boolean DISABLE_CLASS_PRIORITIZATION = Boolean.getBoolean("Paper.DisableClassPrioritization"); // Paper
     private final Pattern[] fileFilters = new Pattern[]{Pattern.compile("\\.jar$")};
-    private final Map<String, java.util.concurrent.locks.ReentrantReadWriteLock> classLoadLock = new java.util.HashMap<String, java.util.concurrent.locks.ReentrantReadWriteLock>(); // Paper
-    private final Map<String, Integer> classLoadLockCount = new java.util.HashMap<String, Integer>(); // Paper
     private final List<PluginClassLoader> loaders = new CopyOnWriteArrayList<PluginClassLoader>();
     private final LibraryLoader libraryLoader;
+    public static boolean SuppressLibraryLoaderLogger = false; // Purpur
 
     /**
      * This class was not meant to be constructed explicitly
@@ -65,7 +48,7 @@ public final class JavaPluginLoader implements PluginLoader {
      */
     @Deprecated
     public JavaPluginLoader(@NotNull Server instance) {
-        Validate.notNull(instance, "Server cannot be null");
+        Preconditions.checkArgument(instance != null, "Server cannot be null");
         server = instance;
 
         LibraryLoader libraryLoader = null;
@@ -81,7 +64,8 @@ public final class JavaPluginLoader implements PluginLoader {
     @Override
     @NotNull
     public Plugin loadPlugin(@NotNull final File file) throws InvalidPluginException {
-        Validate.notNull(file, "File cannot be null");
+        if (true) throw new UnsupportedOperationException(); // Paper
+        Preconditions.checkArgument(file != null, "File cannot be null");
 
         if (!file.exists()) {
             throw new InvalidPluginException(new FileNotFoundException(file.getPath() + " does not exist"));
@@ -94,7 +78,7 @@ public final class JavaPluginLoader implements PluginLoader {
             throw new InvalidPluginException(ex);
         }
 
-        final File parentFile = ((SimplePluginManager) this.server.getPluginManager()).pluginsDirectory(); // Paper
+        final File parentFile = this.server.getPluginsFolder(); // Paper
         final File dataFolder = new File(parentFile, description.getName());
         @SuppressWarnings("deprecation")
         final File oldDataFolder = new File(parentFile, description.getRawName());
@@ -132,25 +116,19 @@ public final class JavaPluginLoader implements PluginLoader {
             ));
         }
 
-        Set<String> missingHardDependencies = new HashSet<>(description.getDepend().size()); // Paper - list all missing hard depends
         for (final String pluginName : description.getDepend()) {
             Plugin current = server.getPluginManager().getPlugin(pluginName);
 
             if (current == null) {
-                missingHardDependencies.add(pluginName); // Paper - list all missing hard depends
+                throw new UnknownDependencyException("Unknown dependency " + pluginName + ". Please download and install " + pluginName + " to run this plugin.");
             }
         }
-        // Paper start - list all missing hard depends
-        if (!missingHardDependencies.isEmpty()) {
-            throw new UnknownDependencyException(missingHardDependencies, description.getFullName());
-        }
-        // Paper end
 
         server.getUnsafe().checkSupported(description);
 
         final PluginClassLoader loader;
         try {
-            loader = new PluginClassLoader(this, getClass().getClassLoader(), description, dataFolder, file, (libraryLoader != null) ? libraryLoader.createLoader(description) : null);
+            loader = new PluginClassLoader(getClass().getClassLoader(), description, dataFolder, file, (libraryLoader != null) ? libraryLoader.createLoader(description) : null, null, null); // Paper
         } catch (InvalidPluginException ex) {
             throw ex;
         } catch (Throwable ex) {
@@ -165,7 +143,7 @@ public final class JavaPluginLoader implements PluginLoader {
     @Override
     @NotNull
     public PluginDescriptionFile getPluginDescription(@NotNull File file) throws InvalidDescriptionException {
-        Validate.notNull(file, "File cannot be null");
+        Preconditions.checkArgument(file != null, "File cannot be null");
 
         JarFile jar = null;
         InputStream stream = null;
@@ -210,45 +188,12 @@ public final class JavaPluginLoader implements PluginLoader {
 
     @Nullable
     Class<?> getClassByName(final String name, boolean resolve, PluginDescriptionFile description) {
-        // Paper start - prioritize self
-        return getClassByName(name, resolve, description, null);
-    }
-    Class<?> getClassByName(final String name, boolean resolve, PluginDescriptionFile description, PluginClassLoader requester) {
-        // Paper end
-        // Paper start - make MT safe
-        java.util.concurrent.locks.ReentrantReadWriteLock lock;
-        synchronized (classLoadLock) {
-            lock = classLoadLock.computeIfAbsent(name, (x) -> new java.util.concurrent.locks.ReentrantReadWriteLock());
-            classLoadLockCount.compute(name, (x, prev) -> prev != null ? prev + 1 : 1);
-        }
-        lock.writeLock().lock();try {
-            // Paper start - prioritize self
-            if (!DISABLE_CLASS_PRIORITIZATION && requester != null) {
-                try {
-                return requester.loadClass0(name, false, false, ((SimplePluginManager) server.getPluginManager()).isTransitiveDepend(description, requester.getDescription()));
-                } catch (ClassNotFoundException cnfe) {}
-            }
-            // Paper end
-        // Paper end
         for (PluginClassLoader loader : loaders) {
             try {
                 return loader.loadClass0(name, resolve, false, ((SimplePluginManager) server.getPluginManager()).isTransitiveDepend(description, loader.plugin.getDescription()));
             } catch (ClassNotFoundException cnfe) {
             }
         }
-        // Paper start - make MT safe
-        } finally {
-            synchronized (classLoadLock) {
-                lock.writeLock().unlock();
-                if (classLoadLockCount.get(name) == 1) {
-                    classLoadLock.remove(name);
-                    classLoadLockCount.remove(name);
-                } else {
-                    classLoadLockCount.compute(name, (x, prev) -> prev - 1);
-                }
-            }
-        }
-        // Paper end
         return null;
     }
 
@@ -269,8 +214,8 @@ public final class JavaPluginLoader implements PluginLoader {
     @Override
     @NotNull
     public Map<Class<? extends Event>, Set<RegisteredListener>> createRegisteredListeners(@NotNull Listener listener, @NotNull final Plugin plugin) {
-        Validate.notNull(plugin, "Plugin can not be null");
-        Validate.notNull(listener, "Listener can not be null");
+        Preconditions.checkArgument(plugin != null, "Plugin can not be null");
+        Preconditions.checkArgument(listener != null, "Listener can not be null");
 
         boolean useTimings = server.getPluginManager().useTimings();
         Map<Class<? extends Event>, Set<RegisteredListener>> ret = new HashMap<Class<? extends Event>, Set<RegisteredListener>>();
@@ -333,7 +278,21 @@ public final class JavaPluginLoader implements PluginLoader {
                 }
             }
 
-            EventExecutor executor = new co.aikar.timings.TimedEventExecutor(EventExecutor.create(method, eventClass), plugin, method, eventClass); // Paper // Paper (Yes.) - Use factory method `EventExecutor.create()`
+            EventExecutor executor = new co.aikar.timings.TimedEventExecutor(new EventExecutor() { // Paper
+                @Override
+                public void execute(@NotNull Listener listener, @NotNull Event event) throws EventException { // Paper
+                    try {
+                        if (!eventClass.isAssignableFrom(event.getClass())) {
+                            return;
+                        }
+                        method.invoke(listener, event);
+                    } catch (InvocationTargetException ex) {
+                        throw new EventException(ex.getCause());
+                    } catch (Throwable t) {
+                        throw new EventException(t);
+                    }
+                }
+            }, plugin, method, eventClass); // Paper
             if (false) { // Spigot - RL handles useTimings check now
                 eventSet.add(new TimedRegisteredListener(listener, executor, eh.priority(), plugin, eh.ignoreCancelled()));
             } else {
@@ -345,17 +304,10 @@ public final class JavaPluginLoader implements PluginLoader {
 
     @Override
     public void enablePlugin(@NotNull final Plugin plugin) {
-        Validate.isTrue(plugin instanceof JavaPlugin, "Plugin is not associated with this PluginLoader");
+        Preconditions.checkArgument(plugin instanceof JavaPlugin, "Plugin is not associated with this PluginLoader");
 
         if (!plugin.isEnabled()) {
-            // Paper start - Add an asterisk to legacy plugins (so admins are aware)
-            String enableMsg = "Enabling " + plugin.getDescription().getFullName();
-            if (org.bukkit.UnsafeValues.isLegacyPlugin(plugin)) {
-                enableMsg += "*";
-            }
-
-            plugin.getLogger().info(enableMsg);
-            // Paper end
+            plugin.getLogger().info("Enabling " + plugin.getDescription().getFullName());
 
             JavaPlugin jPlugin = (JavaPlugin) plugin;
 
@@ -370,10 +322,6 @@ public final class JavaPluginLoader implements PluginLoader {
                 jPlugin.setEnabled(true);
             } catch (Throwable ex) {
                 server.getLogger().log(Level.SEVERE, "Error occurred while enabling " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
-                // Paper start - Disable plugins that fail to load
-                server.getPluginManager().disablePlugin(jPlugin, true); // Paper - close Classloader on disable - She's dead jim
-                return;
-                // Paper end
             }
 
             // Perhaps abort here, rather than continue going, but as it stands,
@@ -384,13 +332,7 @@ public final class JavaPluginLoader implements PluginLoader {
 
     @Override
     public void disablePlugin(@NotNull Plugin plugin) {
-    // Paper start - close Classloader on disable
-        disablePlugin(plugin, false); // Retain old behavior unless requested
-    }
-
-    public void disablePlugin(@NotNull Plugin plugin, boolean closeClassloader) {
-        // Paper end - close Class Loader on disable
-        Validate.isTrue(plugin instanceof JavaPlugin, "Plugin is not associated with this PluginLoader");
+        Preconditions.checkArgument(plugin instanceof JavaPlugin, "Plugin is not associated with this PluginLoader");
 
         if (plugin.isEnabled()) {
             String message = String.format("Disabling %s", plugin.getDescription().getFullName());
@@ -422,16 +364,6 @@ public final class JavaPluginLoader implements PluginLoader {
                 } catch (IOException ex) {
                     //
                 }
-                // Paper start - close Class Loader on disable
-                try {
-                    if (closeClassloader) {
-                        loader.close();
-                    }
-                } catch (IOException e) {
-                    server.getLogger().log(Level.WARNING, "Error closing the Plugin Class Loader for " + plugin.getDescription().getFullName());
-                    e.printStackTrace();
-                }
-                // Paper end
             }
         }
     }
diff --git a/src/main/java/org/bukkit/plugin/java/LibraryLoader.java b/src/main/java/org/bukkit/plugin/java/LibraryLoader.java
index 939afec1f21f46170d5eff286cf9d698c233e1f4..f91efe8f38dfacad5ef1c0498ce5c04ce7a3d96c 100644
--- a/src/main/java/org/bukkit/plugin/java/LibraryLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/LibraryLoader.java
@@ -1,15 +1,6 @@
 // CHECKSTYLE:OFF
 package org.bukkit.plugin.java;
 
-import java.io.File;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.net.URLClassLoader;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 import org.apache.maven.repository.internal.MavenRepositorySystemUtils;
 import org.bukkit.plugin.PluginDescriptionFile;
 import org.eclipse.aether.DefaultRepositorySystemSession;
@@ -36,13 +27,27 @@ import org.eclipse.aether.transport.http.HttpTransporterFactory;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
-class LibraryLoader
+import java.io.File;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+// Paper start
+@org.jetbrains.annotations.ApiStatus.Internal
+public class LibraryLoader
+// Paper end
 {
 
     private final Logger logger;
     private final RepositorySystem repository;
     private final DefaultRepositorySystemSession session;
     private final List<RemoteRepository> repositories;
+    public static java.util.function.BiFunction<URL[], ClassLoader, URLClassLoader> LIBRARY_LOADER_FACTORY; // Paper - rewrite reflection in libraries
 
     public LibraryLoader(@NotNull Logger logger)
     {
@@ -55,6 +60,7 @@ class LibraryLoader
         this.repository = locator.getService( RepositorySystem.class );
         this.session = MavenRepositorySystemUtils.newSession();
 
+        session.setSystemProperties(System.getProperties()); // Paper - paper plugins, backport system properties fix for transitive dependency parsing, see #10116
         session.setChecksumPolicy( RepositoryPolicy.CHECKSUM_POLICY_FAIL );
         session.setLocalRepositoryManager( repository.newLocalRepositoryManager( session, new LocalRepository( "libraries" ) ) );
         session.setTransferListener( new AbstractTransferListener()
@@ -62,9 +68,15 @@ class LibraryLoader
             @Override
             public void transferStarted(@NotNull TransferEvent event) throws TransferCancelledException
             {
+                if (!JavaPluginLoader.SuppressLibraryLoaderLogger) // Purpur
                 logger.log( Level.INFO, "Downloading {0}", event.getResource().getRepositoryUrl() + event.getResource().getResourceName() );
             }
         } );
+
+        // SPIGOT-7638: Add system properties,
+        // since JdkVersionProfileActivator needs 'java.version' when a profile has the 'jdk' element
+        // otherwise it will silently fail and not resolves the dependencies in the affected pom.
+        session.setSystemProperties( System.getProperties() );
         session.setReadOnly();
 
         this.repositories = repository.newResolutionRepositories( session, Arrays.asList( new RemoteRepository.Builder( "central", "default", "https://repo.maven.apache.org/maven2" ).build() ) );
@@ -73,13 +85,20 @@ class LibraryLoader
     @Nullable
     public ClassLoader createLoader(@NotNull PluginDescriptionFile desc)
     {
-        if ( desc.getLibraries().isEmpty() )
+        // Paper start - plugin loader api
+        return this.createLoader(desc, null);
+    }
+    @Nullable
+    public ClassLoader createLoader(@NotNull PluginDescriptionFile desc, @Nullable List<java.nio.file.Path> paperLibraryPaths) {
+        if ( desc.getLibraries().isEmpty() && paperLibraryPaths == null )
+        // Paper end - plugin loader api
         {
             return null;
         }
+        if (!JavaPluginLoader.SuppressLibraryLoaderLogger) // Purpur
         logger.log( Level.INFO, "[{0}] Loading {1} libraries... please wait", new Object[]
         {
-            desc.getName(), desc.getLibraries().size()
+            java.util.Objects.requireNonNullElseGet(desc.getPrefix(), desc::getName), desc.getLibraries().size() // Paper - use configured log prefix
         } );
 
         List<Dependency> dependencies = new ArrayList<>();
@@ -92,18 +111,27 @@ class LibraryLoader
         }
 
         DependencyResult result;
-        try
+        if (!dependencies.isEmpty()) try // Paper - plugin loader api
         {
             result = repository.resolveDependencies( session, new DependencyRequest( new CollectRequest( (Dependency) null, dependencies, repositories ), null ) );
         } catch ( DependencyResolutionException ex )
         {
             throw new RuntimeException( "Error resolving libraries", ex );
-        }
+        } else result = null; // Paper - plugin loader api
 
         List<URL> jarFiles = new ArrayList<>();
-        for ( ArtifactResult artifact : result.getArtifactResults() )
+        List<java.nio.file.Path> jarPaths = new ArrayList<>(); // Paper - remap libraries
+        // Paper start - plugin loader api
+        if (paperLibraryPaths != null) jarPaths.addAll(paperLibraryPaths);
+        if (result != null) for ( ArtifactResult artifact : result.getArtifactResults() )
+        // Paper end - plugin loader api
         {
-            File file = artifact.getArtifact().getFile();
+            // Paper start - remap libraries
+            jarPaths.add(artifact.getArtifact().getFile().toPath());
+        }
+        for (java.nio.file.Path path : jarPaths) {
+            File file = path.toFile();
+            // Paper end - remap libraries
 
             URL url;
             try
@@ -115,13 +143,21 @@ class LibraryLoader
             }
 
             jarFiles.add( url );
+            if (!JavaPluginLoader.SuppressLibraryLoaderLogger) // Purpur
             logger.log( Level.INFO, "[{0}] Loaded library {1}", new Object[]
             {
-                desc.getName(), file
+                java.util.Objects.requireNonNullElseGet(desc.getPrefix(), desc::getName), file // Paper - use configured log prefix
             } );
         }
 
-        URLClassLoader loader = new URLClassLoader( jarFiles.toArray( new URL[ jarFiles.size() ] ) );
+        // Paper start - rewrite reflection in libraries
+        URLClassLoader loader;
+        if (LIBRARY_LOADER_FACTORY == null) {
+            loader = new URLClassLoader( jarFiles.toArray( new URL[ jarFiles.size() ] ), getClass().getClassLoader() );
+        } else {
+            loader = LIBRARY_LOADER_FACTORY.apply(jarFiles.toArray( new URL[ jarFiles.size() ] ), getClass().getClassLoader());
+        }
+        // Paper end - rewrite reflection in libraries
 
         return loader;
     }
diff --git a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
index d2fa792e182736070a119e96b4ae79337de53d2a..8b3a0bf4c3a6b3ecb837449072c7e5aa5a2f0629 100644
--- a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
@@ -1,39 +1,37 @@
 package org.bukkit.plugin.java;
 
+import com.google.common.base.Preconditions;
 import com.google.common.io.ByteStreams;
+import io.papermc.paper.plugin.provider.classloader.PaperClassLoaderStorage;
+import org.bukkit.plugin.InvalidPluginException;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.net.URLClassLoader;
 import java.security.CodeSigner;
 import java.security.CodeSource;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Enumeration;
-import java.util.Map;
-import java.util.Set;
+import java.util.*;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 import java.util.jar.Manifest;
-import java.util.logging.Level;
-import org.apache.commons.lang.Validate;
-import org.bukkit.plugin.InvalidPluginException;
-import org.bukkit.plugin.PluginDescriptionFile;
-import org.bukkit.plugin.SimplePluginManager;
-import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
 
 /**
  * A ClassLoader for plugins, to allow shared classes across multiple plugins
  */
-public final class PluginClassLoader extends URLClassLoader { // Spigot
-    public JavaPlugin getPlugin() { return plugin; } // Spigot
+@org.jetbrains.annotations.ApiStatus.Internal // Paper
+public final class PluginClassLoader extends URLClassLoader implements io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader { // Paper
     private final JavaPluginLoader loader;
     private final Map<String, Class<?>> classes = new ConcurrentHashMap<String, Class<?>>();
-    private final PluginDescriptionFile description; PluginDescriptionFile getDescription() { return description; } // Paper
+    private final PluginDescriptionFile description;
     private final File dataFolder;
     private final File file;
     private final JarFile jar;
@@ -45,70 +43,118 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot
     private IllegalStateException pluginState;
     private final Set<String> seenIllegalAccess = Collections.newSetFromMap(new ConcurrentHashMap<>());
     private java.util.logging.Logger logger; // Paper - add field
+    private io.papermc.paper.plugin.provider.classloader.PluginClassLoaderGroup classLoaderGroup; // Paper
+    public io.papermc.paper.plugin.provider.entrypoint.DependencyContext dependencyContext; // Paper
 
     static {
         ClassLoader.registerAsParallelCapable();
     }
 
-    PluginClassLoader(@NotNull final JavaPluginLoader loader, @Nullable final ClassLoader parent, @NotNull final PluginDescriptionFile description, @NotNull final File dataFolder, @NotNull final File file, @Nullable ClassLoader libraryLoader) throws IOException, InvalidPluginException, MalformedURLException {
-        super(new URL[] {file.toURI().toURL()}, parent);
-        Validate.notNull(loader, "Loader cannot be null");
+    @org.jetbrains.annotations.ApiStatus.Internal // Paper
+    public PluginClassLoader(@Nullable final ClassLoader parent, @NotNull final PluginDescriptionFile description, @NotNull final File dataFolder, @NotNull final File file, @Nullable ClassLoader libraryLoader, JarFile jarFile, io.papermc.paper.plugin.provider.entrypoint.DependencyContext dependencyContext) throws IOException, InvalidPluginException, MalformedURLException { // Paper - use JarFile provided by SpigotPluginProvider
+        super(file.getName(), new URL[] {file.toURI().toURL()}, parent);
+        this.loader = null; // Paper - pass null into loader field
 
-        this.loader = loader;
         this.description = description;
         this.dataFolder = dataFolder;
         this.file = file;
-        // Paper - enable multi-release jars for Java 9+
-        JarFile jarFile;
-        try {
-            final java.lang.reflect.Method runtimeVersionMethod = JarFile.class.getMethod("runtimeVersion");
-            final Object runtimeVersion = runtimeVersionMethod.invoke(null);
-            @SuppressWarnings("JavaReflectionMemberAccess") final java.lang.reflect.Constructor<JarFile> constructor = JarFile.class.getConstructor(File.class, boolean.class, int.class, runtimeVersion.getClass());
-            jarFile = constructor.newInstance(file, true, java.util.zip.ZipFile.OPEN_READ, runtimeVersion);
-        } catch (Exception ignored) {
-            jarFile = new JarFile(file);
-        }
-        this.jar = jarFile;
-        // Paper end
+        this.jar = jarFile; // Paper - use JarFile provided by SpigotPluginProvider
         this.manifest = jar.getManifest();
         this.url = file.toURI().toURL();
         this.libraryLoader = libraryLoader;
 
         this.logger = com.destroystokyo.paper.utils.PaperPluginLogger.getLogger(description); // Paper - Register logger early
+        // Paper start
+        this.dependencyContext = dependencyContext;
+        this.classLoaderGroup = PaperClassLoaderStorage.instance().registerSpigotGroup(this);
+        // Paper end
 
+        Class<?> jarClass;
         try {
-            Class<?> jarClass;
-            try {
-                jarClass = Class.forName(description.getMain(), true, this);
-            } catch (ClassNotFoundException ex) {
-                throw new InvalidPluginException("Cannot find main class `" + description.getMain() + "'", ex);
-            }
+            jarClass = Class.forName(description.getMain(), true, this);
+        } catch (ClassNotFoundException ex) {
+            throw new InvalidPluginException("Cannot find main class `" + description.getMain() + "'", ex);
+        }
 
-            Class<? extends JavaPlugin> pluginClass;
-            try {
-                pluginClass = jarClass.asSubclass(JavaPlugin.class);
-            } catch (ClassCastException ex) {
-                throw new InvalidPluginException("main class `" + description.getMain() + "' does not extend JavaPlugin", ex);
-            }
+        Class<? extends JavaPlugin> pluginClass;
+        try {
+            pluginClass = jarClass.asSubclass(JavaPlugin.class);
+        } catch (ClassCastException ex) {
+            throw new InvalidPluginException("main class `" + description.getMain() + "' must extend JavaPlugin", ex);
+        }
+
+        Constructor<? extends JavaPlugin> pluginConstructor;
+        try {
+            pluginConstructor = pluginClass.getDeclaredConstructor();
+        } catch (NoSuchMethodException ex) {
+            throw new InvalidPluginException("main class `" + description.getMain() + "' must have a public no-args constructor", ex);
+        }
 
-            plugin = pluginClass.newInstance();
+        try {
+            plugin = pluginConstructor.newInstance();
         } catch (IllegalAccessException ex) {
-            throw new InvalidPluginException("No public constructor", ex);
+            throw new InvalidPluginException("main class `" + description.getMain() + "' constructor must be public", ex);
         } catch (InstantiationException ex) {
-            throw new InvalidPluginException("Abnormal plugin type", ex);
+            throw new InvalidPluginException("main class `" + description.getMain() + "' must not be abstract", ex);
+        } catch (IllegalArgumentException ex) {
+            throw new InvalidPluginException("Could not invoke main class `" + description.getMain() + "' constructor", ex);
+        } catch (ExceptionInInitializerError | InvocationTargetException ex) {
+            throw new InvalidPluginException("Exception initializing main class `" + description.getMain() + "'", ex);
         }
     }
 
     @Override
     public URL getResource(String name) {
-        return findResource(name);
+        // Paper start
+        URL resource = findResource(name);
+        if (resource == null && libraryLoader != null) {
+            return libraryLoader.getResource(name);
+        }
+        return resource;
+        // Paper end
     }
 
     @Override
     public Enumeration<URL> getResources(String name) throws IOException {
-        return findResources(name);
+        // Paper start
+        java.util.ArrayList<URL> resources = new java.util.ArrayList<>();
+        addEnumeration(resources, findResources(name));
+        if (libraryLoader != null) {
+            addEnumeration(resources, libraryLoader.getResources(name));
+        }
+        return Collections.enumeration(resources);
+        // Paper end
+    }
+
+    // Paper start
+    private <T> void addEnumeration(java.util.ArrayList<T> list, Enumeration<T> enumeration) {
+        while (enumeration.hasMoreElements()) {
+            list.add(enumeration.nextElement());
+        }
+    }
+    // Paper end
+
+    // Paper start
+    @Override
+    public Class<?> loadClass(@NotNull String name, boolean resolve, boolean checkGlobal, boolean checkLibraries) throws ClassNotFoundException {
+        return this.loadClass0(name, resolve, checkGlobal, checkLibraries);
+    }
+    @Override
+    public io.papermc.paper.plugin.configuration.PluginMeta getConfiguration() {
+        return this.description;
     }
 
+    @Override
+    public void init(JavaPlugin plugin) {
+        this.initialize(plugin);
+    }
+
+    @Override
+    public JavaPlugin getPlugin() {
+        return this.plugin;
+    }
+    // Paper end
+
     @Override
     protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
         return loadClass0(name, resolve, true, true);
@@ -116,7 +162,12 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot
 
     Class<?> loadClass0(@NotNull String name, boolean resolve, boolean checkGlobal, boolean checkLibraries) throws ClassNotFoundException {
         try {
-            return super.loadClass(name, resolve);
+            Class<?> result = super.loadClass(name, resolve);
+
+            // SPIGOT-6749: Library classes will appear in the above, but we don't want to return them to other plugins
+            if (checkGlobal || result.getClassLoader() == this) {
+                return result;
+            }
         } catch (ClassNotFoundException ex) {
         }
 
@@ -129,24 +180,11 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot
 
         if (checkGlobal) {
             // This ignores the libraries of other plugins, unless they are transitive dependencies.
-            Class<?> result = loader.getClassByName(name, resolve, description, this);  // Paper - prioritize self
-
-            // If the class was loaded from a library instead of a PluginClassLoader, we can assume that its associated plugin is a transitive dependency and can therefore skip this check.
-            if (result != null && result.getClassLoader() instanceof PluginClassLoader) {
-                PluginDescriptionFile provider = ((PluginClassLoader) result.getClassLoader()).description;
-
-                if (provider != description
-                        && !seenIllegalAccess.contains(provider.getName())
-                        && !((SimplePluginManager) loader.server.getPluginManager()).isTransitiveDepend(description, provider)) {
-
-                    seenIllegalAccess.add(provider.getName());
-                    if (plugin != null) {
-                        plugin.getLogger().log(Level.WARNING, "Loaded class {0} from {1} which is not a depend, softdepend or loadbefore of this plugin.", new Object[]{name, provider.getFullName()});
-                    } else {
-                        // In case the bad access occurs on construction
-                        loader.server.getLogger().log(Level.WARNING, "[{0}] Loaded class {1} from {2} which is not a depend, softdepend or loadbefore of this plugin.", new Object[]{description.getName(), name, provider.getFullName()});
-                    }
-                }
+            Class<?> result = this.classLoaderGroup.getClassByName(name, resolve, this); // Paper
+
+            if (result != null) {
+                // If the class was loaded from a library instead of a PluginClassLoader, we can assume that its associated plugin is a transitive dependency and can therefore skip this check.
+                // Paper - Totally delete the illegal access logic, we are never going to enforce it anyways here.
 
                 return result;
             }
@@ -175,7 +213,7 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot
                     throw new ClassNotFoundException(name, ex);
                 }
 
-                classBytes = loader.server.getUnsafe().processClass(description, path, classBytes);
+                classBytes = org.bukkit.Bukkit.getServer().getUnsafe().processClass(description, path, classBytes); // Paper
 
                 int dot = name.lastIndexOf('.');
                 if (dot != -1) {
@@ -205,8 +243,8 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot
                 result = super.findClass(name);
             }
 
-            loader.setClass(name, result);
             classes.put(name, result);
+            this.setClass(name, result); // Paper
         }
 
         return result;
@@ -215,6 +253,12 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot
     @Override
     public void close() throws IOException {
         try {
+            // Paper start
+            Collection<Class<?>> classes = getClasses();
+            for (Class<?> clazz : classes) {
+                removeClass(clazz);
+            }
+            // Paper end
             super.close();
         } finally {
             jar.close();
@@ -226,9 +270,9 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot
         return classes.values();
     }
 
-    synchronized void initialize(@NotNull JavaPlugin javaPlugin) {
-        Validate.notNull(javaPlugin, "Initializing plugin cannot be null");
-        Validate.isTrue(javaPlugin.getClass().getClassLoader() == this, "Cannot initialize plugin outside of this class loader");
+    public synchronized void initialize(@NotNull JavaPlugin javaPlugin) { // Paper
+        Preconditions.checkArgument(javaPlugin != null, "Initializing plugin cannot be null");
+        Preconditions.checkArgument(javaPlugin.getClass().getClassLoader() == this, "Cannot initialize plugin outside of this class loader");
         if (this.plugin != null || this.pluginInit != null) {
             throw new IllegalArgumentException("Plugin already initialized!", pluginState);
         }
@@ -236,8 +280,7 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot
         pluginState = new IllegalStateException("Initial initialization");
         this.pluginInit = javaPlugin;
 
-        javaPlugin.logger = this.logger; // Paper - set logger
-        javaPlugin.init(loader, loader.server, description, dataFolder, file, this);
+        javaPlugin.init(org.bukkit.Bukkit.getServer(), description, dataFolder, file, this, description, this.logger); // Paper
     }
 
     // Paper start
@@ -250,5 +293,25 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot
                    ", url=" + file +
                    '}';
     }
+
+    void setClass(@NotNull final String name, @NotNull final Class<?> clazz) {
+        if (org.bukkit.configuration.serialization.ConfigurationSerializable.class.isAssignableFrom(clazz)) {
+            Class<? extends org.bukkit.configuration.serialization.ConfigurationSerializable> serializable = clazz.asSubclass(org.bukkit.configuration.serialization.ConfigurationSerializable.class);
+            org.bukkit.configuration.serialization.ConfigurationSerialization.registerClass(serializable);
+        }
+    }
+
+    private void removeClass(@NotNull Class<?> clazz) {
+        if (org.bukkit.configuration.serialization.ConfigurationSerializable.class.isAssignableFrom(clazz)) {
+            Class<? extends org.bukkit.configuration.serialization.ConfigurationSerializable> serializable = clazz.asSubclass(org.bukkit.configuration.serialization.ConfigurationSerializable.class);
+            org.bukkit.configuration.serialization.ConfigurationSerialization.unregisterClass(serializable);
+        }
+    }
+
+    @Override
+    public @Nullable io.papermc.paper.plugin.provider.classloader.PluginClassLoaderGroup getGroup() {
+        return this.classLoaderGroup;
+    }
+
     // Paper end
 }
diff --git a/src/main/java/org/bukkit/plugin/messaging/Messenger.java b/src/main/java/org/bukkit/plugin/messaging/Messenger.java
index 682c77188436d696d4dafbc70cf131d5c921e94d..aaba7bc633c2ecee84c8449e553a20fcc25418b5 100644
--- a/src/main/java/org/bukkit/plugin/messaging/Messenger.java
+++ b/src/main/java/org/bukkit/plugin/messaging/Messenger.java
@@ -1,11 +1,12 @@
 package org.bukkit.plugin.messaging;
 
-import java.util.Set;
 import org.bukkit.NamespacedKey;
 import org.bukkit.entity.Player;
 import org.bukkit.plugin.Plugin;
 import org.jetbrains.annotations.NotNull;
 
+import java.util.Set;
+
 /**
  * A class responsible for managing the registrations of plugin channels and
  * their listeners.
@@ -24,7 +25,7 @@ public interface Messenger {
     /**
      * Represents the largest size that a Plugin Channel may be.
      */
-    public static final int MAX_CHANNEL_SIZE = Integer.getInteger("paper.maxCustomChannelName", 64); // Paper
+    public static final int MAX_CHANNEL_SIZE = Integer.getInteger("paper.maxCustomChannelName", Short.MAX_VALUE); // Paper - set true max channel size
 
     /**
      * Checks if the specified channel is a reserved name.
diff --git a/src/main/java/org/bukkit/plugin/messaging/PluginMessageRecipient.java b/src/main/java/org/bukkit/plugin/messaging/PluginMessageRecipient.java
index b84b37fe27d84574dc5897285f1d9a1437bd322c..c586b59d176fb6ce3ecdc67364a5a7348c9f7fca 100644
--- a/src/main/java/org/bukkit/plugin/messaging/PluginMessageRecipient.java
+++ b/src/main/java/org/bukkit/plugin/messaging/PluginMessageRecipient.java
@@ -1,9 +1,10 @@
 package org.bukkit.plugin.messaging;
 
-import java.util.Set;
 import org.bukkit.plugin.Plugin;
 import org.jetbrains.annotations.NotNull;
 
+import java.util.Set;
+
 /**
  * Represents a possible recipient for a Plugin Message.
  */
@@ -31,7 +32,8 @@ public interface PluginMessageRecipient {
 
     /**
      * Gets a set containing all the Plugin Channels that this client is
-     * listening on.
+     * listening on. Does not contain the BungeeCord channel due to its
+     * special status.
      *
      * @return Set containing all the channels that this client may accept.
      */
diff --git a/src/main/java/org/bukkit/plugin/messaging/StandardMessenger.java b/src/main/java/org/bukkit/plugin/messaging/StandardMessenger.java
index 6fda7f3aa68e76af64362e9afed70fc6a5e92986..0635fb216d510a15b8e61c38a5108741ab342ecc 100644
--- a/src/main/java/org/bukkit/plugin/messaging/StandardMessenger.java
+++ b/src/main/java/org/bukkit/plugin/messaging/StandardMessenger.java
@@ -2,16 +2,13 @@ package org.bukkit.plugin.messaging;
 
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSet.Builder;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Set;
-import java.util.logging.Level;
 import org.bukkit.entity.Player;
 import org.bukkit.plugin.Plugin;
 import org.jetbrains.annotations.NotNull;
 
+import java.util.*;
+import java.util.logging.Level;
+
 /**
  * Standard implementation to {@link Messenger}
  */
diff --git a/src/main/java/org/bukkit/support/MatcherAssert.java b/src/main/java/org/bukkit/support/MatcherAssert.java
new file mode 100644
index 0000000000000000000000000000000000000000..494875935c0e1f99dbc450c520fc57c15070fae6
--- /dev/null
+++ b/src/main/java/org/bukkit/support/MatcherAssert.java
@@ -0,0 +1,34 @@
+package org.bukkit.support;
+
+import org.hamcrest.Matcher;
+import org.junit.Assert;
+
+/**
+ * Custom assertThat methods, where the reason is put at the end of the method call.
+ * To better match with JUnit 5 argument order and also help with readability for longer reasons.
+ * <br>
+ * <pre>
+ * assertThat(String.format("""
+ *         The block data created for the material %s is not an instance of the data class from that material.
+ *         """, material), blockData, is(instanceOf(expectedClass)));
+ * </pre>
+ * vs.
+ * <pre>
+ * assertThat(blockData, is(instanceOf(expectedClass)), String.format("""
+ *         The block data created for the material %s is not an instance of the data class from that material.
+ *         """, material));
+ * </pre>
+ */
+public final class MatcherAssert {
+
+    private MatcherAssert() {}
+
+    public static <T> void assertThat(T actual, Matcher<? super T> matcher) {
+        Assert.assertThat(actual, matcher);
+    }
+
+    public static <T> void assertThat(T actual, Matcher<? super T> matcher, String reason) {
+        Assert.assertThat(reason, actual, matcher);
+    }
+
+}
diff --git a/src/test/java/org/bukkit/AnnotationTest.java b/src/test/java/org/bukkit/AnnotationTest.java
deleted file mode 100644
index 82b2783497947f336b0dd95db61f31f8f77f446c..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/AnnotationTest.java
+++ /dev/null
@@ -1,272 +0,0 @@
-package org.bukkit;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
-import org.junit.Assert;
-import org.junit.Test;
-import org.objectweb.asm.ClassReader;
-import org.objectweb.asm.Opcodes;
-import org.objectweb.asm.Type;
-import org.objectweb.asm.tree.AnnotationNode;
-import org.objectweb.asm.tree.ClassNode;
-import org.objectweb.asm.tree.MethodNode;
-import org.objectweb.asm.tree.ParameterNode;
-
-public class AnnotationTest {
-
-    private static final String[] ACCEPTED_ANNOTATIONS = {
-        // Paper start
-        "Lorg/checkerframework/checker/nullness/qual/Nullable;",
-        "Lorg/checkerframework/checker/nullness/qual/NonNull;",
-        "Lorg/checkerframework/checker/nullness/qual/PolyNull;",
-        "Lorg/checkerframework/checker/nullness/qual/MonotonicNonNull;",
-        // Paper end
-        "Lorg/jetbrains/annotations/Nullable;",
-        "Lorg/jetbrains/annotations/NotNull;",
-        "Lorg/jetbrains/annotations/Contract;",
-        "Lorg/bukkit/UndefinedNullability;"
-    };
-
-    private static final String[] EXCLUDED_CLASSES = {
-        // Internal technical classes
-        "org/bukkit/plugin/java/JavaPluginLoader",
-        "org/bukkit/util/io/BukkitObjectInputStream",
-        "org/bukkit/util/io/BukkitObjectOutputStream",
-        "org/bukkit/util/io/Wrapper",
-        "org/bukkit/plugin/java/PluginClassLoader",
-        // Generic functional interface
-        "org/bukkit/util/Consumer",
-        // Paper start
-        "io/papermc/paper/util/TransformingRandomAccessList",
-        "io/papermc/paper/util/TransformingRandomAccessList$TransformedListIterator",
-        // Timings history is broken in terms of nullability due to guavas Function defining that the param is NonNull
-        "co/aikar/timings/TimingHistory$2",
-        "co/aikar/timings/TimingHistory$2$1",
-        "co/aikar/timings/TimingHistory$2$1$1",
-        "co/aikar/timings/TimingHistory$2$1$2",
-        "co/aikar/timings/TimingHistory$3",
-        "co/aikar/timings/TimingHistory$4",
-        "co/aikar/timings/TimingHistoryEntry$1"
-        // Paper end
-    };
-
-    @Test
-    public void testAll() throws IOException, URISyntaxException {
-        URL loc = Bukkit.class.getProtectionDomain().getCodeSource().getLocation();
-        File file = new File(loc.toURI());
-
-        // Running from jar is not supported yet
-        Assert.assertTrue("code must be in a directory", file.isDirectory());
-
-        final HashMap<String, ClassNode> foundClasses = new HashMap<>();
-        collectClasses(file, foundClasses);
-
-        final ArrayList<String> errors = new ArrayList<>();
-
-        for (ClassNode clazz : foundClasses.values()) {
-            if (!isClassIncluded(clazz, foundClasses)) {
-                continue;
-            }
-
-            for (MethodNode method : clazz.methods) {
-                if (!isMethodIncluded(clazz, method, foundClasses)) {
-                    continue;
-                }
-
-                if (mustBeAnnotated(Type.getReturnType(method.desc)) && !isWellAnnotated(method.invisibleAnnotations) && !isWellAnnotated(method.visibleTypeAnnotations)) { // Paper - also check visible type annotations
-                    warn(errors, clazz, method, "return value");
-                }
-
-                Type[] paramTypes = Type.getArgumentTypes(method.desc);
-                List<ParameterNode> parameters = method.parameters;
-
-                for (int i = 0; i < paramTypes.length; i++) {
-                    if (mustBeAnnotated(paramTypes[i]) && !isWellAnnotated(method.invisibleParameterAnnotations == null ? null : method.invisibleParameterAnnotations[i])) {
-                        ParameterNode paramNode = parameters == null ? null : parameters.get(i);
-                        String paramName = paramNode == null ? null : paramNode.name;
-
-                        warn(errors, clazz, method, "parameter " + i + (paramName == null ? "" : ": " + paramName));
-                    }
-                }
-            }
-        }
-
-        if (errors.isEmpty()) {
-            // Success
-            return;
-        }
-
-        Collections.sort(errors);
-
-        StringBuilder builder = new StringBuilder()
-            .append("There ")
-            .append(errors.size() != 1 ? "are " : "is ")
-            .append(errors.size())
-            .append(" missing annotation")
-            .append(errors.size() != 1 ? "s:\n" : ":\n");
-
-        for (String message : errors) {
-            builder.append("\t").append(message).append("\n");
-        }
-
-        Assert.fail(builder.toString());
-    }
-
-    private static void collectClasses(@NotNull File from, @NotNull Map<String, ClassNode> to) throws IOException {
-        if (from.isDirectory()) {
-            final File[] files = from.listFiles();
-            assert files != null;
-
-            for (File file : files) {
-                collectClasses(file, to);
-            }
-            return;
-        }
-
-        if (!from.getName().endsWith(".class")) {
-            return;
-        }
-
-        try (FileInputStream in = new FileInputStream(from)) {
-            final ClassReader cr = new ClassReader(in);
-
-            final ClassNode node = new ClassNode();
-            cr.accept(node, ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
-
-            to.put(node.name, node);
-        }
-    }
-
-    private static boolean isClassIncluded(@NotNull ClassNode clazz, @NotNull Map<String, ClassNode> allClasses) {
-        // Exclude private, synthetic or deprecated classes and annotations, since their members can't be null
-        if ((clazz.access & (Opcodes.ACC_PRIVATE | Opcodes.ACC_SYNTHETIC | Opcodes.ACC_DEPRECATED | Opcodes.ACC_ANNOTATION)) != 0) {
-            return false;
-        }
-
-        if (isSubclassOf(clazz, "org/bukkit/material/MaterialData", allClasses)) {
-            throw new AssertionError("Subclass of MaterialData must be deprecated: " + clazz.name);
-        }
-
-        if (isSubclassOf(clazz, "java/lang/Exception", allClasses)
-                || isSubclassOf(clazz, "java/lang/RuntimeException", allClasses)) {
-            // Exceptions are excluded
-            return false;
-        }
-
-        for (String excludedClass : EXCLUDED_CLASSES) {
-            if (excludedClass.equals(clazz.name)) {
-                return false;
-            }
-        }
-
-        return true;
-    }
-
-    private static boolean isMethodIncluded(@NotNull ClassNode clazz, @NotNull MethodNode method, @NotNull Map<String, ClassNode> allClasses) {
-        // Exclude private, synthetic and deprecated methods
-        if ((method.access & (Opcodes.ACC_PRIVATE | Opcodes.ACC_SYNTHETIC | Opcodes.ACC_DEPRECATED)) != 0 || (method.access & (Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED | Opcodes.ACC_PUBLIC)) == 0) { // Paper - ignore package-private
-            return false;
-        }
-
-        // Exclude Java methods
-        if (is(method, "toString", 0) || is(method, "clone", 0) || is(method, "equals", 1)) {
-            return false;
-        }
-
-        // Exclude generated Enum methods
-        if (isSubclassOf(clazz, "java/lang/Enum", allClasses) && (is(method, "values", 0) || is(method, "valueOf", 1))) {
-            return false;
-        }
-
-        // Anonymous classes have generated constructors, which can't be annotated nor invoked
-        if ("<init>".equals(method.name) && isAnonymous(clazz)) {
-            return false;
-        }
-
-        return true;
-    }
-
-    private static boolean isWellAnnotated(@Nullable List<? extends AnnotationNode> annotations) { // Paper - allow children of AnnotationNode
-        if (annotations == null) {
-            return false;
-        }
-
-        for (AnnotationNode node : annotations) {
-            for (String acceptedAnnotation : ACCEPTED_ANNOTATIONS) {
-                if (acceptedAnnotation.equals(node.desc)) {
-                    return true;
-                }
-            }
-        }
-
-        return false;
-    }
-
-    private static boolean mustBeAnnotated(@NotNull Type type) {
-        return type.getSort() == Type.ARRAY || type.getSort() == Type.OBJECT;
-    }
-
-    private static boolean is(@NotNull MethodNode method, @NotNull String name, int parameters) {
-        final List<ParameterNode> params = method.parameters;
-        return method.name.equals(name) && (params == null || params.size() == parameters);
-    }
-
-    /**
-     * Checks if the class is anonymous.
-     *
-     * @param clazz the class to check
-     * @return true if given class is anonymous
-     */
-    private static boolean isAnonymous(@NotNull ClassNode clazz) {
-        final String name = clazz.name;
-        if (name == null) {
-            return false;
-        }
-        final int nestedSeparator = name.lastIndexOf('$');
-        if (nestedSeparator == -1 || nestedSeparator + 1 == name.length()) {
-            return false;
-        }
-
-        // Nested classes have purely numeric names. Java classes can't begin with a number,
-        // so if first character is a number, the class must be anonymous
-        final char c = name.charAt(nestedSeparator + 1);
-        return c >= '0' && c <= '9';
-    }
-
-    private static boolean isSubclassOf(@NotNull ClassNode what, @NotNull String ofWhat, @NotNull Map<String, ClassNode> allClasses) {
-        if (ofWhat.equals(what.name)
-                // Not only optimization: Super class may not be present in allClasses, so it is checked here
-                || ofWhat.equals(what.superName)) {
-            return true;
-        }
-
-        final ClassNode parent = allClasses.get(what.superName);
-        if (parent != null && isSubclassOf(parent, ofWhat, allClasses)) {
-            return true;
-        }
-
-        for (String superInterface : what.interfaces) {
-            final ClassNode interfaceParent = allClasses.get(superInterface);
-            if (interfaceParent != null && isSubclassOf(interfaceParent, ofWhat, allClasses)) {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    private static void warn(@NotNull Collection<String> out, @NotNull ClassNode clazz, @NotNull MethodNode method, @NotNull String description) {
-        out.add(clazz.name + " \t" + method.name + " \t" + description);
-    }
-}
diff --git a/src/test/java/org/bukkit/BukkitMirrorTest.java b/src/test/java/org/bukkit/BukkitMirrorTest.java
index 2dfada66067d79b84cd490eadbe0178e8cd8c260..5974ceea58940e1799f3589eac0e39b925a42c3b 100644
--- a/src/test/java/org/bukkit/BukkitMirrorTest.java
+++ b/src/test/java/org/bukkit/BukkitMirrorTest.java
@@ -1,72 +1,60 @@
 package org.bukkit;
 
+import static org.bukkit.support.MatcherAssert.*;
 import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-import com.google.common.base.Function;
-import com.google.common.collect.Lists;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
-import java.util.Arrays;
-import java.util.List;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameter;
-import org.junit.runners.Parameterized.Parameters;
+import java.util.stream.Stream;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
 
-@RunWith(Parameterized.class)
+@org.junit.jupiter.api.Disabled // Paper
 public class BukkitMirrorTest {
 
-    @Parameters(name = "{index}: {1}")
-    public static List<Object[]> data() {
-        return Lists.transform(Arrays.asList(Server.class.getDeclaredMethods()), new Function<Method, Object[]>() {
-            @Override
-            public Object[] apply(Method input) {
-                return new Object[] {
-                    input,
-                    input.toGenericString().substring("public abstract ".length()).replace("(", "{").replace(")", "}")
-                    };
-            }
-        });
+    public static Stream<Arguments> data() {
+        return Stream.of(Server.class.getDeclaredMethods())
+                .map(method -> {
+                    try {
+                        return Arguments.of(
+                                method,
+                                method.toGenericString().substring("public abstract ".length()).replace("(", "{").replace(")", "}"),
+                                Bukkit.class.getDeclaredMethod(method.getName(), method.getParameterTypes())
+                        );
+                    } catch (NoSuchMethodException e) {
+                        throw new RuntimeException(e);
+                    }
+                });
     }
 
-    @Parameter(0)
-    public Method server;
-
-    @Parameter(1)
-    public String name;
-
-    private Method bukkit;
-
-    @Before
-    public void makeBukkit() throws Throwable {
-        bukkit = Bukkit.class.getDeclaredMethod(server.getName(), server.getParameterTypes());
-    }
-
-    @Test
-    public void isStatic() throws Throwable {
+    @ParameterizedTest
+    @MethodSource("data")
+    public void isStatic(Method server, String name, Method bukkit) throws Throwable {
         assertThat(Modifier.isStatic(bukkit.getModifiers()), is(true));
     }
 
-    @Test
-    public void isDeprecated() throws Throwable {
+    @ParameterizedTest
+    @MethodSource("data")
+    public void isDeprecated(Method server, String name, Method bukkit) throws Throwable {
         assertThat(bukkit.isAnnotationPresent(Deprecated.class), is(server.isAnnotationPresent(Deprecated.class)));
     }
 
-    @Test
-    public void returnType() throws Throwable {
+    @ParameterizedTest
+    @MethodSource("data")
+    public void returnType(Method server, String name, Method bukkit) throws Throwable {
         assertThat(bukkit.getReturnType(), is((Object) server.getReturnType()));
         // assertThat(bukkit.getGenericReturnType(), is(server.getGenericReturnType())); // too strict on <T> type generics
     }
 
-    @Test
-    public void parameterTypes() throws Throwable {
+    @ParameterizedTest
+    @MethodSource("data")
+    public void parameterTypes(Method server, String name, Method bukkit) throws Throwable {
         // assertThat(bukkit.getGenericParameterTypes(), is(server.getGenericParameterTypes())); // too strict on <T> type generics
     }
 
-    @Test
-    public void declaredException() throws Throwable {
+    @ParameterizedTest
+    @MethodSource("data")
+    public void declaredException(Method server, String name, Method bukkit) throws Throwable {
         assertThat(bukkit.getGenericExceptionTypes(), is(server.getGenericExceptionTypes()));
     }
 }
diff --git a/src/test/java/org/bukkit/DyeColorTest.java b/src/test/java/org/bukkit/DyeColorTest.java
index e56d9439a2c4aa029263d68cb435bec63ce87574..4e9ff14fcdc862cad9a93377b1be17b7ba038803 100644
--- a/src/test/java/org/bukkit/DyeColorTest.java
+++ b/src/test/java/org/bukkit/DyeColorTest.java
@@ -1,69 +1,57 @@
 package org.bukkit;
 
+import static org.bukkit.support.MatcherAssert.*;
 import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-import java.util.ArrayList;
-import java.util.List;
 import org.bukkit.material.Colorable;
 import org.bukkit.material.Dye;
 import org.bukkit.material.Wool;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameter;
-import org.junit.runners.Parameterized.Parameters;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.EnumSource;
 
-@RunWith(Parameterized.class)
 public class DyeColorTest {
 
-    @Parameters(name = "{index}: {0}")
-    public static List<Object[]> data() {
-        List<Object[]> list = new ArrayList<Object[]>();
-        for (DyeColor dye : DyeColor.values()) {
-            list.add(new Object[] {dye});
-        }
-        return list;
-    }
-
-    @Parameter public DyeColor dye;
-
-    @Test
+    @ParameterizedTest
+    @EnumSource(DyeColor.class)
     @SuppressWarnings("deprecation")
-    public void getByData() {
+    public void getByData(DyeColor dye) {
         byte data = dye.getWoolData();
 
         DyeColor byData = DyeColor.getByWoolData(data);
         assertThat(byData, is(dye));
     }
 
-    @Test
-    public void getByWoolData() {
+    @ParameterizedTest
+    @EnumSource(DyeColor.class)
+    public void getByWoolData(DyeColor dye) {
         byte data = dye.getWoolData();
 
         DyeColor byData = DyeColor.getByWoolData(data);
         assertThat(byData, is(dye));
     }
 
-    @Test
-    public void getByDyeData() {
+    @ParameterizedTest
+    @EnumSource(DyeColor.class)
+    public void getByDyeData(DyeColor dye) {
         byte data = dye.getDyeData();
 
         DyeColor byData = DyeColor.getByDyeData(data);
         assertThat(byData, is(dye));
     }
 
-    @Test
-    public void getDyeDyeColor() {
-        testColorable(new Dye(Material.LEGACY_INK_SACK, dye.getDyeData()));
-        testColorable(new Dye(dye));
+    @ParameterizedTest
+    @EnumSource(DyeColor.class)
+    public void getDyeDyeColor(DyeColor dye) {
+        testColorable(new Dye(Material.LEGACY_INK_SACK, dye.getDyeData()), dye);
+        testColorable(new Dye(dye), dye);
     }
 
-    @Test
-    public void getWoolDyeColor() {
-        testColorable(new Wool(Material.LEGACY_WOOL, dye.getWoolData()));
+    @ParameterizedTest
+    @EnumSource(DyeColor.class)
+    public void getWoolDyeColor(DyeColor dye) {
+        testColorable(new Wool(Material.LEGACY_WOOL, dye.getWoolData()), dye);
     }
 
-    private void testColorable(final Colorable colorable) {
-        assertThat(colorable.getColor(), is(this.dye));
+    private void testColorable(final Colorable colorable, DyeColor dye) {
+        assertThat(colorable.getColor(), is(dye));
     }
 }
diff --git a/src/test/java/org/bukkit/LocationTest.java b/src/test/java/org/bukkit/LocationTest.java
deleted file mode 100644
index 887305c05c3e53079347502c187984ca3e42a1f8..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/LocationTest.java
+++ /dev/null
@@ -1,202 +0,0 @@
-package org.bukkit;
-
-import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-import com.google.common.collect.ImmutableList;
-import java.util.List;
-import java.util.Random;
-import org.bukkit.util.Vector;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameter;
-import org.junit.runners.Parameterized.Parameters;
-
-@RunWith(Parameterized.class)
-public class LocationTest {
-    private static final double delta = 1.0 / 1000000;
-    /**
-     * <pre>
-     * a + b = c, a = b
-     * => 2(a) = 2(b) = c, c = 1
-     * => 2(a) = 1
-     * => a = 1/2
-     * => a = (1/2) 
-     * </pre>
-     */
-    private static final double HALF_UNIT = Math.sqrt(1 / 2f);
-    /**
-     * <pre>
-     * a + b = c, c = (1/2)
-     * => a + b = (1/2), a = b
-     * => 2(a) = 2(b) = 1/2
-     * => a = 1/4
-     * => a = (1/4) 
-     * </pre>
-     */
-    private static final double HALF_HALF_UNIT = Math.sqrt(1 / 4f);
-
-    @Parameters(name = "{index}: {0}")
-    public static List<Object[]> data() {
-        Random RANDOM = new Random(1L); // Test is deterministic
-        int r = 0;
-        return ImmutableList.<Object[]>of(
-            new Object[]{"X",
-                1, 0, 0,
-                270, 0
-            },
-            new Object[]{"-X",
-                -1, 0, 0,
-                90, 0
-            },
-            new Object[]{"Z",
-                0, 0, 1,
-                0, 0
-            },
-            new Object[]{"-Z",
-                0, 0, -1,
-                180, 0
-            },
-            new Object[]{"Y",
-                0, 1, 0,
-                0, -90 // Zero is here as a "default" value
-            },
-            new Object[]{"-Y",
-                0, -1, 0,
-                0, 90 // Zero is here as a "default" value
-            },
-            new Object[]{"X Z",
-                HALF_UNIT, 0, HALF_UNIT,
-                (270 + 360) / 2, 0
-            },
-            new Object[]{"X -Z",
-                HALF_UNIT, 0, -HALF_UNIT,
-                (270 + 180) / 2, 0
-            },
-            new Object[]{"-X -Z",
-                -HALF_UNIT, 0, -HALF_UNIT,
-                (90 + 180) / 2, 0
-            },
-            new Object[]{"-X Z",
-                -HALF_UNIT, 0, HALF_UNIT,
-                (90 + 0) / 2, 0
-            },
-            new Object[]{"X Y Z",
-                HALF_HALF_UNIT, HALF_UNIT, HALF_HALF_UNIT,
-                (270 + 360) / 2, -45
-            },
-            new Object[]{"-X -Y -Z",
-                -HALF_HALF_UNIT, -HALF_UNIT, -HALF_HALF_UNIT,
-                (90 + 180) / 2, 45
-            },
-            getRandom(RANDOM, r++),
-            getRandom(RANDOM, r++),
-            getRandom(RANDOM, r++),
-            getRandom(RANDOM, r++),
-            getRandom(RANDOM, r++),
-            getRandom(RANDOM, r++),
-            getRandom(RANDOM, r++),
-            getRandom(RANDOM, r++),
-            getRandom(RANDOM, r++),
-            getRandom(RANDOM, r++),
-            getRandom(RANDOM, r++),
-            getRandom(RANDOM, r++),
-            getRandom(RANDOM, r++),
-            getRandom(RANDOM, r++),
-            getRandom(RANDOM, r++),
-            getRandom(RANDOM, r++),
-            getRandom(RANDOM, r++),
-            getRandom(RANDOM, r++)
-        );
-    }
-
-    private static Object[] getRandom(Random random, int index) {
-        final double YAW_FACTOR = 360;
-        final double YAW_OFFSET = 0;
-        final double PITCH_FACTOR = 180;
-        final double PITCH_OFFSET = -90;
-        final double CARTESIAN_FACTOR = 256;
-        final double CARTESIAN_OFFSET = -128;
-
-        Vector vector;
-        Location location;
-        if (random.nextBoolean()) {
-            float pitch = (float) (random.nextDouble() * PITCH_FACTOR + PITCH_OFFSET);
-            float yaw = (float) (random.nextDouble() * YAW_FACTOR + YAW_OFFSET);
-
-            location = getEmptyLocation();
-            location.setPitch(pitch);
-            location.setYaw(yaw);
-
-            vector = location.getDirection();
-        } else {
-            double x = random.nextDouble() * CARTESIAN_FACTOR + CARTESIAN_OFFSET;
-            double y = random.nextDouble() * CARTESIAN_FACTOR + CARTESIAN_OFFSET;
-            double z = random.nextDouble() * CARTESIAN_FACTOR + CARTESIAN_OFFSET;
-
-            location = getEmptyLocation();
-            vector = new Vector(x, y, z).normalize();
-
-            location.setDirection(vector);
-        }
-
-        return new Object[]{"R" + index,
-            vector.getX(), vector.getY(), vector.getZ(),
-            location.getYaw(), location.getPitch()
-        };
-    }
-
-    @Parameter(0)
-    public String nane;
-    @Parameter(1)
-    public double x;
-    @Parameter(2)
-    public double y;
-    @Parameter(3)
-    public double z;
-    @Parameter(4)
-    public float yaw;
-    @Parameter(5)
-    public float pitch;
-
-    @Test
-    public void testExpectedPitchYaw() {
-        Location location = getEmptyLocation().setDirection(getVector());
-
-        assertThat((double) location.getYaw(), is(closeTo(yaw, delta)));
-        assertThat((double) location.getPitch(), is(closeTo(pitch, delta)));
-    }
-
-    @Test
-    public void testExpectedXYZ() {
-        Vector vector = getLocation().getDirection();
-
-        assertThat(vector.getX(), is(closeTo(x, delta)));
-        assertThat(vector.getY(), is(closeTo(y, delta)));
-        assertThat(vector.getZ(), is(closeTo(z, delta)));
-    }
-
-    @Test
-    public void testEquals() {
-        Location first = getLocation().add(getVector());
-        Location second = getLocation().add(getVector());
-
-        assertThat(first.hashCode(), is(second.hashCode()));
-        assertThat(first, is(second));
-    }
-
-    private Vector getVector() {
-        return new Vector(x, y, z);
-    }
-
-    private static Location getEmptyLocation() {
-        return new Location(TestWorld.INSTANCE, 0, 0, 0);
-    }
-
-    private Location getLocation() {
-        Location location = getEmptyLocation();
-        location.setYaw(yaw);
-        location.setPitch(pitch);
-        return location;
-    }
-}
diff --git a/src/test/java/org/bukkit/conversations/ConversationContextTest.java b/src/test/java/org/bukkit/conversations/ConversationContextTest.java
deleted file mode 100644
index 3780a47c1f48d47b39a0e8a36c64044b366f8cc0..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/conversations/ConversationContextTest.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package org.bukkit.conversations;
-
-import static org.junit.Assert.*;
-import java.util.HashMap;
-import java.util.Map;
-import org.junit.Test;
-
-/**
- */
-public class ConversationContextTest {
-    @Test
-    public void TestFromWhom() {
-        Conversable conversable = new FakeConversable();
-        ConversationContext context = new ConversationContext(null, conversable, new HashMap<Object, Object>());
-        assertEquals(conversable, context.getForWhom());
-    }
-
-    @Test
-    public void TestPlugin() {
-        Conversable conversable = new FakeConversable();
-        ConversationContext context = new ConversationContext(null, conversable, new HashMap<Object, Object>());
-        assertEquals(null, context.getPlugin());
-    }
-
-    @Test
-    public void TestSessionData() {
-        Conversable conversable = new FakeConversable();
-        Map session = new HashMap();
-        session.put("key", "value");
-        ConversationContext context = new ConversationContext(null, conversable, session);
-        assertEquals("value", context.getSessionData("key"));
-    }
-}
diff --git a/src/test/java/org/bukkit/conversations/ConversationTest.java b/src/test/java/org/bukkit/conversations/ConversationTest.java
deleted file mode 100644
index c448dc724d65f4b6a4cf52a6213f712b4c06d82e..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/conversations/ConversationTest.java
+++ /dev/null
@@ -1,119 +0,0 @@
-package org.bukkit.conversations;
-
-import static org.junit.Assert.*;
-import org.bukkit.plugin.TestPlugin;
-import org.junit.Test;
-
-/**
- */
-public class ConversationTest {
-
-    @Test
-    public void testBaseConversationFlow() {
-        FakeConversable forWhom = new FakeConversable();
-        Conversation conversation = new Conversation(null, forWhom, new FirstPrompt());
-
-        // Conversation not yet begun
-        assertNull(forWhom.lastSentMessage);
-        assertEquals(conversation.getForWhom(), forWhom);
-        assertTrue(conversation.isModal());
-
-        // Begin the conversation
-        conversation.begin();
-        assertEquals("FirstPrompt", forWhom.lastSentMessage);
-        assertEquals(conversation, forWhom.begunConversation);
-
-        // Send the first input
-        conversation.acceptInput("FirstInput");
-        assertEquals("SecondPrompt", forWhom.lastSentMessage);
-        assertEquals(conversation, forWhom.abandonedConverstion);
-    }
-
-    @Test
-    public void testConversationFactory() {
-        FakeConversable forWhom = new FakeConversable();
-        NullConversationPrefix prefix = new NullConversationPrefix();
-        ConversationFactory factory = new ConversationFactory(new TestPlugin("Test"))
-                .withFirstPrompt(new FirstPrompt())
-                .withModality(false)
-                .withPrefix(prefix);
-        Conversation conversation = factory.buildConversation(forWhom);
-
-        // Conversation not yet begun
-        assertNull(forWhom.lastSentMessage);
-        assertEquals(conversation.getForWhom(), forWhom);
-        assertFalse(conversation.isModal());
-        assertEquals(conversation.getPrefix(), prefix);
-
-        // Begin the conversation
-        conversation.begin();
-        assertEquals("FirstPrompt", forWhom.lastSentMessage);
-        assertEquals(conversation, forWhom.begunConversation);
-
-        // Send the first input
-        conversation.acceptInput("FirstInput");
-        assertEquals("SecondPrompt", forWhom.lastSentMessage);
-        assertEquals(conversation, forWhom.abandonedConverstion);
-    }
-
-    @Test
-    public void testEscapeSequence() {
-        FakeConversable forWhom = new FakeConversable();
-        Conversation conversation = new Conversation(null, forWhom, new FirstPrompt());
-        conversation.addConversationCanceller(new ExactMatchConversationCanceller("bananas"));
-
-        // Begin the conversation
-        conversation.begin();
-        assertEquals("FirstPrompt", forWhom.lastSentMessage);
-        assertEquals(conversation, forWhom.begunConversation);
-
-        // Send the first input
-        conversation.acceptInput("bananas");
-        assertEquals("bananas", forWhom.lastSentMessage);
-        assertEquals(conversation, forWhom.abandonedConverstion);
-    }
-
-    @Test
-    public void testNotPlayer() {
-        FakeConversable forWhom = new FakeConversable();
-        ConversationFactory factory = new ConversationFactory(new TestPlugin("Test"))
-                .thatExcludesNonPlayersWithMessage("bye");
-        Conversation conversation = factory.buildConversation(forWhom);
-
-        // Begin the conversation
-        conversation.begin();
-        assertEquals("bye", forWhom.lastSentMessage);
-        assertEquals(conversation, forWhom.begunConversation);
-        assertEquals(conversation, forWhom.abandonedConverstion);
-    }
-
-    private class FirstPrompt extends StringPrompt {
-
-        @Override
-        public String getPromptText(ConversationContext context) {
-            return "FirstPrompt";
-        }
-
-        @Override
-        public Prompt acceptInput(ConversationContext context, String input) {
-            assertEquals("FirstInput", input);
-            context.setSessionData("data", 10);
-            return new SecondPrompt();
-        }
-    }
-
-    private class SecondPrompt extends MessagePrompt {
-
-        @Override
-        protected Prompt getNextPrompt(ConversationContext context) {
-            return Prompt.END_OF_CONVERSATION;
-        }
-
-        @Override
-        public String getPromptText(ConversationContext context) {
-            // Assert that session data passes from one prompt to the next
-            assertEquals(context.getSessionData("data"), 10);
-            return "SecondPrompt";
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/conversations/FakeConversable.java b/src/test/java/org/bukkit/conversations/FakeConversable.java
deleted file mode 100644
index 567bfd7d3e45d83b5520af6ddd0140c2b84139b2..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/conversations/FakeConversable.java
+++ /dev/null
@@ -1,118 +0,0 @@
-package org.bukkit.conversations;
-
-import java.util.Set;
-import java.util.UUID;
-import org.bukkit.Server;
-import org.bukkit.permissions.Permission;
-import org.bukkit.permissions.PermissionAttachment;
-import org.bukkit.permissions.PermissionAttachmentInfo;
-import org.bukkit.plugin.Plugin;
-import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
-
-/**
- */
-public class FakeConversable implements Conversable {
-    public String lastSentMessage;
-    public Conversation begunConversation;
-    public Conversation abandonedConverstion;
-    public ConversationAbandonedEvent abandonedConversationEvent;
-
-    @Override
-    public boolean isConversing() {
-        return false;
-    }
-
-    @Override
-    public void acceptConversationInput(String input) {
-
-    }
-
-    @Override
-    public boolean beginConversation(Conversation conversation) {
-        begunConversation = conversation;
-        conversation.outputNextPrompt();
-        return true;
-    }
-
-    @Override
-    public void abandonConversation(Conversation conversation) {
-        abandonedConverstion = conversation;
-    }
-
-    @Override
-    public void abandonConversation(Conversation conversation, ConversationAbandonedEvent details) {
-        abandonedConverstion = conversation;
-        abandonedConversationEvent = details;
-    }
-
-    @Override
-    public void sendRawMessage(String message) {
-        lastSentMessage = message;
-    }
-
-    @Override
-    public void sendRawMessage(@Nullable UUID sender, @NotNull String message) {
-        this.sendRawMessage(message);
-    }
-
-    public Server getServer() {
-        return null;
-    }
-
-    public String getName() {
-        return null;
-    }
-
-    public boolean isPermissionSet(String name) {
-        return false;
-    }
-
-    public boolean isPermissionSet(Permission perm) {
-        return false;
-    }
-
-    public boolean hasPermission(String name) {
-        return false;
-    }
-
-    public boolean hasPermission(Permission perm) {
-        return false;
-    }
-
-    public PermissionAttachment addAttachment(Plugin plugin, String name, boolean value) {
-        return null;
-    }
-
-    public PermissionAttachment addAttachment(Plugin plugin) {
-        return null;
-    }
-
-    public PermissionAttachment addAttachment(Plugin plugin, String name, boolean value, int ticks) {
-        return null;
-    }
-
-    public PermissionAttachment addAttachment(Plugin plugin, int ticks) {
-        return null;
-    }
-
-    public void removeAttachment(PermissionAttachment attachment) {
-
-    }
-
-    public void recalculatePermissions() {
-
-    }
-
-    public Set<PermissionAttachmentInfo> getEffectivePermissions() {
-        return null;
-    }
-
-    public boolean isOp() {
-        return false;
-    }
-
-    public void setOp(boolean value) {
-
-    }
-}
diff --git a/src/test/java/org/bukkit/conversations/ValidatingPromptTest.java b/src/test/java/org/bukkit/conversations/ValidatingPromptTest.java
deleted file mode 100644
index 6093e9865b004c8fa4aed0bd0c291a4c77ca8b84..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/conversations/ValidatingPromptTest.java
+++ /dev/null
@@ -1,118 +0,0 @@
-package org.bukkit.conversations;
-
-import static org.junit.Assert.*;
-import org.junit.Test;
-
-/**
- */
-public class ValidatingPromptTest {
-
-    @Test
-    public void TestBooleanPrompt() {
-        TestBooleanPrompt prompt = new TestBooleanPrompt();
-        assertTrue(prompt.isInputValid(null, "true"));
-        assertFalse(prompt.isInputValid(null, "bananas"));
-        prompt.acceptInput(null, "true");
-        assertTrue(prompt.result);
-        prompt.acceptInput(null, "no");
-        assertFalse(prompt.result);
-    }
-
-    @Test
-    public void TestFixedSetPrompt() {
-        TestFixedSetPrompt prompt = new TestFixedSetPrompt("foo", "bar");
-        assertTrue(prompt.isInputValid(null, "foo"));
-        assertFalse(prompt.isInputValid(null, "cheese"));
-        prompt.acceptInput(null, "foo");
-        assertEquals("foo", prompt.result);
-    }
-
-    @Test
-    public void TestNumericPrompt() {
-        TestNumericPrompt prompt = new TestNumericPrompt();
-        assertTrue(prompt.isInputValid(null, "1010220"));
-        assertFalse(prompt.isInputValid(null, "tomato"));
-        prompt.acceptInput(null, "1010220");
-        assertEquals(1010220, prompt.result);
-    }
-
-    @Test
-    public void TestRegexPrompt() {
-        TestRegexPrompt prompt = new TestRegexPrompt("a.c");
-        assertTrue(prompt.isInputValid(null, "abc"));
-        assertTrue(prompt.isInputValid(null, "axc"));
-        assertFalse(prompt.isInputValid(null, "xyz"));
-        prompt.acceptInput(null, "abc");
-        assertEquals("abc", prompt.result);
-    }
-
-    //TODO: TestPlayerNamePrompt()
-
-    private class TestBooleanPrompt extends BooleanPrompt {
-        public boolean result;
-
-        @Override
-        protected Prompt acceptValidatedInput(ConversationContext context, boolean input) {
-            result = input;
-            return null;
-        }
-
-        @Override
-        public String getPromptText(ConversationContext context) {
-            return null;
-        }
-    }
-
-    private class TestFixedSetPrompt extends FixedSetPrompt {
-        public String result;
-
-        public TestFixedSetPrompt(String... fixedSet) {
-            super(fixedSet);
-        }
-
-        @Override
-        protected Prompt acceptValidatedInput(ConversationContext context, String input) {
-            result = input;
-            return null;
-        }
-
-        @Override
-        public String getPromptText(ConversationContext context) {
-            return null;
-        }
-    }
-
-    private class TestNumericPrompt extends NumericPrompt {
-        public Number result;
-
-        @Override
-        protected Prompt acceptValidatedInput(ConversationContext context, Number input) {
-            result = input;
-            return null;
-        }
-
-        @Override
-        public String getPromptText(ConversationContext context) {
-            return null;
-        }
-    }
-
-    private class TestRegexPrompt extends RegexPrompt {
-        public String result;
-
-        public TestRegexPrompt(String pattern) {
-            super(pattern);
-        }
-
-        @Override
-        protected Prompt acceptValidatedInput(ConversationContext context, String input) {
-            result = input;
-            return null;
-        }
-
-        @Override
-        public String getPromptText(ConversationContext context) {
-            return null;
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/event/PlayerChatTabCompleteEventTest.java b/src/test/java/org/bukkit/event/PlayerChatTabCompleteEventTest.java
deleted file mode 100644
index dd5fb243b7af23115908a534bec13e8f455f64b2..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/event/PlayerChatTabCompleteEventTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package org.bukkit.event;
-
-import static org.hamcrest.CoreMatchers.*;
-import static org.junit.Assert.*;
-import com.google.common.collect.ImmutableList;
-import org.bukkit.event.player.PlayerChatTabCompleteEvent;
-import org.bukkit.plugin.messaging.TestPlayer;
-import org.junit.Test;
-
-public class PlayerChatTabCompleteEventTest {
-
-    @Test
-    public void testGetLastToken() {
-        assertThat(getToken("Hello everyone!"), is("everyone!"));
-        assertThat(getToken(" welcome to the show..."), is("show..."));
-        assertThat(getToken("The whitespace is here "), is(""));
-        assertThat(getToken("Too much whitespace is here  "), is(""));
-        assertThat(getToken("The_whitespace_is_missing"), is("The_whitespace_is_missing"));
-        assertThat(getToken(""), is(""));
-        assertThat(getToken(" "), is(""));
-    }
-
-    private String getToken(String message) {
-        return new PlayerChatTabCompleteEvent(TestPlayer.getInstance(), message, ImmutableList.<String>of()).getLastToken();
-    }
-}
diff --git a/src/test/java/org/bukkit/event/SyntheticEventTest.java b/src/test/java/org/bukkit/event/SyntheticEventTest.java
deleted file mode 100644
index d402cb59f508205ebe9ee450594826b04cecb90b..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/event/SyntheticEventTest.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package org.bukkit.event;
-
-import org.bukkit.TestServer;
-import org.bukkit.plugin.PluginLoader;
-import org.bukkit.plugin.SimplePluginManager;
-import org.bukkit.plugin.TestPlugin;
-import org.bukkit.plugin.java.JavaPluginLoader;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class SyntheticEventTest {
-    @SuppressWarnings("deprecation")
-    @Test
-    public void test() {
-        final JavaPluginLoader loader = new JavaPluginLoader(TestServer.getInstance());
-        TestPlugin plugin = new TestPlugin(getClass().getName()) {
-            @Override
-            public PluginLoader getPluginLoader() {
-                return loader;
-            }
-        };
-        SimplePluginManager pluginManager = new SimplePluginManager(TestServer.getInstance(), null);
-
-        TestEvent event = new TestEvent(false);
-        Impl impl = new Impl();
-
-        pluginManager.registerEvents(impl, plugin);
-        pluginManager.callEvent(event);
-
-        Assert.assertEquals(1, impl.callCount);
-    }
-
-    public abstract static class Base<E extends Event> implements Listener {
-        int callCount = 0;
-
-        public void accept(E evt) {
-            callCount++;
-        }
-    }
-
-    public static class Impl extends Base<TestEvent> {
-        @Override
-        @EventHandler
-        public void accept(TestEvent evt) {
-            super.accept(evt);
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/event/TestEvent.java b/src/test/java/org/bukkit/event/TestEvent.java
deleted file mode 100644
index 25904f5f8170bcfdc4b39860e4e8b5715aaf6909..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/event/TestEvent.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package org.bukkit.event;
-
-
-public class TestEvent extends Event {
-    private static final HandlerList handlers = new HandlerList();
-
-    public TestEvent(boolean async) {
-        super(async);
-    }
-
-    @Override
-    public HandlerList getHandlers() {
-        return handlers;
-    }
-
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
-}
diff --git a/src/test/java/org/bukkit/metadata/FixedMetadataValueTest.java b/src/test/java/org/bukkit/metadata/FixedMetadataValueTest.java
deleted file mode 100644
index e8cea99fd0eb966e60b0a8e1ebceca6dce6ff50a..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/metadata/FixedMetadataValueTest.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package org.bukkit.metadata;
-
-import static org.junit.Assert.*;
-import org.bukkit.plugin.Plugin;
-import org.bukkit.plugin.TestPlugin;
-import org.junit.Test;
-
-public class FixedMetadataValueTest {
-    private Plugin plugin = new TestPlugin("X");
-    private FixedMetadataValue subject;
-
-    @Test
-    public void testBasic() {
-        subject = new FixedMetadataValue(plugin, new Integer(50));
-        assertSame(plugin, subject.getOwningPlugin());
-        assertEquals(new Integer(50), subject.value());
-    }
-
-    @Test
-    public void testNumberTypes() {
-        subject = new FixedMetadataValue(plugin, new Integer(5));
-        assertEquals(new Integer(5), subject.value());
-        assertEquals(5, subject.asInt());
-        assertEquals(true, subject.asBoolean());
-        assertEquals(5, subject.asByte());
-        assertEquals(5.0, subject.asFloat(), 0.1e-8);
-        assertEquals(5.0D, subject.asDouble(), 0.1e-8D);
-        assertEquals(5L, subject.asLong());
-        assertEquals(5, subject.asShort());
-        assertEquals("5", subject.asString());
-    }
-
-    @Test
-    public void testInvalidateDoesNothing() {
-        Object o = new Object();
-        subject = new FixedMetadataValue(plugin, o);
-        subject.invalidate();
-        assertSame(o, subject.value());
-    }
-}
diff --git a/src/test/java/org/bukkit/metadata/LazyMetadataValueTest.java b/src/test/java/org/bukkit/metadata/LazyMetadataValueTest.java
deleted file mode 100644
index bc8a18eea6c0c61ad07bdc44b2a7c38f84117da6..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/metadata/LazyMetadataValueTest.java
+++ /dev/null
@@ -1,138 +0,0 @@
-package org.bukkit.metadata;
-
-import static org.junit.Assert.*;
-import java.util.concurrent.Callable;
-import org.bukkit.plugin.TestPlugin;
-import org.junit.Test;
-
-public class LazyMetadataValueTest {
-    private LazyMetadataValue subject;
-    private TestPlugin plugin = new TestPlugin("x");
-
-    @Test
-    public void testLazyInt() {
-        int value = 10;
-        subject = makeSimpleCallable(value);
-
-        assertEquals(value, subject.value());
-    }
-
-    @Test
-    public void testLazyDouble() {
-        double value = 10.5;
-        subject = makeSimpleCallable(value);
-
-        assertEquals(value, (Double) subject.value(), 0.01);
-    }
-
-    @Test
-    public void testLazyString() {
-        String value = "TEN";
-        subject = makeSimpleCallable(value);
-
-        assertEquals(value, subject.value());
-    }
-
-    @Test
-    public void testLazyBoolean() {
-        boolean value = false;
-        subject = makeSimpleCallable(value);
-
-        assertEquals(value, subject.value());
-    }
-
-    @Test(expected = MetadataEvaluationException.class)
-    public void testEvalException() {
-        subject = new LazyMetadataValue(plugin, LazyMetadataValue.CacheStrategy.CACHE_AFTER_FIRST_EVAL, new Callable<Object>() {
-            @Override
-            public Object call() throws Exception {
-                throw new RuntimeException("Gotcha!");
-            }
-        });
-        subject.value();
-    }
-
-    @Test
-    public void testCacheStrategyCacheAfterFirstEval() {
-        final Counter counter = new Counter();
-        final int value = 10;
-        subject = new LazyMetadataValue(plugin, LazyMetadataValue.CacheStrategy.CACHE_AFTER_FIRST_EVAL, new Callable<Object>() {
-            @Override
-            public Object call() throws Exception {
-                counter.increment();
-                return value;
-            }
-        });
-
-        subject.value();
-        subject.value();
-        assertEquals(value, subject.value());
-        assertEquals(1, counter.value());
-
-        subject.invalidate();
-        subject.value();
-        assertEquals(2, counter.value());
-    }
-
-    @Test
-    public void testCacheStrategyNeverCache() {
-        final Counter counter = new Counter();
-        final int value = 10;
-        subject = new LazyMetadataValue(plugin, LazyMetadataValue.CacheStrategy.NEVER_CACHE, new Callable<Object>() {
-            @Override
-            public Object call() throws Exception {
-                counter.increment();
-                return value;
-            }
-        });
-
-        subject.value();
-        subject.value();
-        assertEquals(value, subject.value());
-        assertEquals(3, counter.value());
-    }
-
-    @Test
-    public void testCacheStrategyEternally() {
-        final Counter counter = new Counter();
-        final int value = 10;
-        subject = new LazyMetadataValue(plugin, LazyMetadataValue.CacheStrategy.CACHE_ETERNALLY, new Callable<Object>() {
-            @Override
-            public Object call() throws Exception {
-                counter.increment();
-                return value;
-            }
-        });
-
-        subject.value();
-        subject.value();
-        assertEquals(value, subject.value());
-        assertEquals(1, counter.value());
-
-        subject.invalidate();
-        subject.value();
-        assertEquals(value, subject.value());
-        assertEquals(1, counter.value());
-    }
-
-    private LazyMetadataValue makeSimpleCallable(final Object value) {
-        return new LazyMetadataValue(plugin, new Callable<Object>() {
-            @Override
-            public Object call() throws Exception {
-                return value;
-            }
-        });
-    }
-
-    private class Counter {
-        private int c = 0;
-
-        public void increment() {
-            c++;
-        }
-
-        public int value() {
-            return c;
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/metadata/MetadataConversionTest.java b/src/test/java/org/bukkit/metadata/MetadataConversionTest.java
deleted file mode 100644
index a9c10a2fd9fb37f2f7223fed138b2e2bfdaaef12..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/metadata/MetadataConversionTest.java
+++ /dev/null
@@ -1,102 +0,0 @@
-//    Copyright (C) 2011  Ryan Michela
-//
-//    This program is free software: you can redistribute it and/or modify
-//    it under the terms of the GNU General Public License as published by
-//    the Free Software Foundation, either version 3 of the License, or
-//    (at your option) any later version.
-//
-//    This program is distributed in the hope that it will be useful,
-//    but WITHOUT ANY WARRANTY; without even the implied warranty of
-//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//    GNU General Public License for more details.
-//
-//    You should have received a copy of the GNU General Public License
-//    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-package org.bukkit.metadata;
-
-import static org.junit.Assert.*;
-import org.bukkit.plugin.Plugin;
-import org.bukkit.plugin.TestPlugin;
-import org.junit.Test;
-
-/**
- */
-public class MetadataConversionTest {
-    private Plugin plugin = new TestPlugin("x");
-    private FixedMetadataValue subject;
-
-    private void setSubject(Object value) {
-        subject = new FixedMetadataValue(plugin, value);
-    }
-
-    @Test
-    public void testFromInt() {
-        setSubject(10);
-
-        assertEquals(10, subject.asInt());
-        assertEquals(10, subject.asFloat(), 0.000001);
-        assertEquals(10, subject.asDouble(), 0.000001);
-        assertEquals(10, subject.asLong());
-        assertEquals(10, subject.asShort());
-        assertEquals(10, subject.asByte());
-        assertEquals(true, subject.asBoolean());
-        assertEquals("10", subject.asString());
-    }
-
-    @Test
-    public void testFromFloat() {
-        setSubject(10.5);
-
-        assertEquals(10, subject.asInt());
-        assertEquals(10.5, subject.asFloat(), 0.000001);
-        assertEquals(10.5, subject.asDouble(), 0.000001);
-        assertEquals(10, subject.asLong());
-        assertEquals(10, subject.asShort());
-        assertEquals(10, subject.asByte());
-        assertEquals(true, subject.asBoolean());
-        assertEquals("10.5", subject.asString());
-    }
-
-    @Test
-    public void testFromNumericString() {
-        setSubject("10");
-
-        assertEquals(10, subject.asInt());
-        assertEquals(10, subject.asFloat(), 0.000001);
-        assertEquals(10, subject.asDouble(), 0.000001);
-        assertEquals(10, subject.asLong());
-        assertEquals(10, subject.asShort());
-        assertEquals(10, subject.asByte());
-        assertEquals(false, subject.asBoolean());
-        assertEquals("10", subject.asString());
-    }
-
-    @Test
-    public void testFromNonNumericString() {
-        setSubject("true");
-
-        assertEquals(0, subject.asInt());
-        assertEquals(0, subject.asFloat(), 0.000001);
-        assertEquals(0, subject.asDouble(), 0.000001);
-        assertEquals(0, subject.asLong());
-        assertEquals(0, subject.asShort());
-        assertEquals(0, subject.asByte());
-        assertEquals(true, subject.asBoolean());
-        assertEquals("true", subject.asString());
-    }
-
-    @Test
-    public void testFromNull() {
-        setSubject(null);
-
-        assertEquals(0, subject.asInt());
-        assertEquals(0, subject.asFloat(), 0.000001);
-        assertEquals(0, subject.asDouble(), 0.000001);
-        assertEquals(0, subject.asLong());
-        assertEquals(0, subject.asShort());
-        assertEquals(0, subject.asByte());
-        assertEquals(false, subject.asBoolean());
-        assertEquals("", subject.asString());
-    }
-}
diff --git a/src/test/java/org/bukkit/metadata/MetadataStoreTest.java b/src/test/java/org/bukkit/metadata/MetadataStoreTest.java
deleted file mode 100644
index 12373ff16ca71bc437929ea5c4486c2c6bd93d09..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/metadata/MetadataStoreTest.java
+++ /dev/null
@@ -1,141 +0,0 @@
-package org.bukkit.metadata;
-
-import static org.junit.Assert.*;
-import java.util.List;
-import java.util.concurrent.Callable;
-import org.bukkit.plugin.Plugin;
-import org.bukkit.plugin.TestPlugin;
-import org.junit.Test;
-
-public class MetadataStoreTest {
-    private Plugin pluginX = new TestPlugin("x");
-    private Plugin pluginY = new TestPlugin("y");
-
-    StringMetadataStore subject = new StringMetadataStore();
-
-    @Test
-    public void testMetadataStore() {
-        subject.setMetadata("subject", "key", new FixedMetadataValue(pluginX, 10));
-
-        assertTrue(subject.hasMetadata("subject", "key"));
-        List<MetadataValue> values = subject.getMetadata("subject", "key");
-        assertEquals(10, values.get(0).value());
-    }
-
-    @Test
-    public void testMetadataNotPresent() {
-        assertFalse(subject.hasMetadata("subject", "key"));
-        List<MetadataValue> values = subject.getMetadata("subject", "key");
-        assertTrue(values.isEmpty());
-    }
-
-    @Test
-    public void testInvalidateAll() {
-        final Counter counter = new Counter();
-
-        subject.setMetadata("subject", "key", new LazyMetadataValue(pluginX, new Callable<Object>() {
-            @Override
-            public Object call() throws Exception {
-                counter.increment();
-                return 10;
-            }
-        }));
-
-        assertTrue(subject.hasMetadata("subject", "key"));
-        subject.getMetadata("subject", "key").get(0).value();
-        subject.invalidateAll(pluginX);
-        subject.getMetadata("subject", "key").get(0).value();
-        assertEquals(2, counter.value());
-    }
-
-    @Test
-    public void testInvalidateAllButActuallyNothing() {
-        final Counter counter = new Counter();
-
-        subject.setMetadata("subject", "key", new LazyMetadataValue(pluginX, new Callable<Object>() {
-            @Override
-            public Object call() throws Exception {
-                counter.increment();
-                return 10;
-            }
-        }));
-
-        assertTrue(subject.hasMetadata("subject", "key"));
-        subject.getMetadata("subject", "key").get(0).value();
-        subject.invalidateAll(pluginY);
-        subject.getMetadata("subject", "key").get(0).value();
-        assertEquals(1, counter.value());
-    }
-
-    @Test
-    public void testMetadataReplace() {
-        subject.setMetadata("subject", "key", new FixedMetadataValue(pluginX, 10));
-        subject.setMetadata("subject", "key", new FixedMetadataValue(pluginY, 10));
-        subject.setMetadata("subject", "key", new FixedMetadataValue(pluginX, 20));
-
-        for (MetadataValue mv : subject.getMetadata("subject", "key")) {
-            if (mv.getOwningPlugin().equals(pluginX)) {
-                assertEquals(20, mv.value());
-            }
-            if (mv.getOwningPlugin().equals(pluginY)) {
-                assertEquals(10, mv.value());
-            }
-        }
-    }
-
-    @Test
-    public void testMetadataRemove() {
-        subject.setMetadata("subject", "key", new FixedMetadataValue(pluginX, 10));
-        subject.setMetadata("subject", "key", new FixedMetadataValue(pluginY, 20));
-        subject.removeMetadata("subject", "key", pluginX);
-
-        assertTrue(subject.hasMetadata("subject", "key"));
-        assertEquals(1, subject.getMetadata("subject", "key").size());
-        assertEquals(20, subject.getMetadata("subject", "key").get(0).value());
-    }
-
-    @Test
-    public void testMetadataRemoveLast() {
-        subject.setMetadata("subject", "key", new FixedMetadataValue(pluginX, 10));
-        subject.removeMetadata("subject", "key", pluginX);
-
-        assertFalse(subject.hasMetadata("subject", "key"));
-        assertEquals(0, subject.getMetadata("subject", "key").size());
-    }
-
-    @Test
-    public void testMetadataRemoveForNonExistingPlugin() {
-        subject.setMetadata("subject", "key", new FixedMetadataValue(pluginX, 10));
-        subject.removeMetadata("subject", "key", pluginY);
-
-        assertTrue(subject.hasMetadata("subject", "key"));
-        assertEquals(1, subject.getMetadata("subject", "key").size());
-        assertEquals(10, subject.getMetadata("subject", "key").get(0).value());
-    }
-
-    @Test
-    public void testHasMetadata() {
-        subject.setMetadata("subject", "key", new FixedMetadataValue(pluginX, 10));
-        assertTrue(subject.hasMetadata("subject", "key"));
-        assertFalse(subject.hasMetadata("subject", "otherKey"));
-    }
-
-    private class StringMetadataStore extends MetadataStoreBase<String> implements MetadataStore<String> {
-        @Override
-        protected String disambiguate(String subject, String metadataKey) {
-            return subject + ":" + metadataKey;
-        }
-    }
-
-    private class Counter {
-        int c = 0;
-
-        public void increment() {
-            c++;
-        }
-
-        public int value() {
-            return c;
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/metadata/MetadataValueAdapterTest.java b/src/test/java/org/bukkit/metadata/MetadataValueAdapterTest.java
deleted file mode 100644
index c1e78568a86525e922a49a802aa5da85b4b6ae4a..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/metadata/MetadataValueAdapterTest.java
+++ /dev/null
@@ -1,103 +0,0 @@
-package org.bukkit.metadata;
-
-import static org.junit.Assert.*;
-import org.bukkit.plugin.Plugin;
-import org.bukkit.plugin.TestPlugin;
-import org.junit.Test;
-
-public class MetadataValueAdapterTest {
-    private TestPlugin plugin = new TestPlugin("x");
-
-    @Test
-    public void testAdapterBasics() {
-        IncrementingMetaValue mv = new IncrementingMetaValue(plugin);
-        // check getOwningPlugin
-        assertEquals(mv.getOwningPlugin(), this.plugin);
-
-        // Check value-getting and invalidation.
-        assertEquals(new Integer(1), mv.value());
-        assertEquals(new Integer(2), mv.value());
-        mv.invalidate();
-        assertEquals(new Integer(1), mv.value());
-    }
-
-    @Test
-    public void testAdapterConversions() {
-        IncrementingMetaValue mv = new IncrementingMetaValue(plugin);
-
-        assertEquals(1, mv.asInt());
-        assertEquals(2L, mv.asLong());
-        assertEquals(3.0, mv.asFloat(), 0.001);
-        assertEquals(4, mv.asByte());
-        assertEquals(5.0, mv.asDouble(), 0.001);
-        assertEquals(6, mv.asShort());
-        assertEquals("7", mv.asString());
-    }
-
-    /** Boolean conversion is non-trivial, we want to test it thoroughly. */
-    @Test
-    public void testBooleanConversion() {
-        // null is False.
-        assertEquals(false, simpleValue(null).asBoolean());
-
-        // String to boolean.
-        assertEquals(true, simpleValue("True").asBoolean());
-        assertEquals(true, simpleValue("TRUE").asBoolean());
-        assertEquals(false, simpleValue("false").asBoolean());
-
-        // Number to boolean.
-        assertEquals(true, simpleValue(1).asBoolean());
-        assertEquals(true, simpleValue(5.0).asBoolean());
-        assertEquals(false, simpleValue(0).asBoolean());
-        assertEquals(false, simpleValue(0.1).asBoolean());
-
-        // Boolean as boolean, of course.
-        assertEquals(true, simpleValue(Boolean.TRUE).asBoolean());
-        assertEquals(false, simpleValue(Boolean.FALSE).asBoolean());
-
-        // any object that is not null and not a Boolean, String, or Number is true.
-        assertEquals(true, simpleValue(new Object()).asBoolean());
-    }
-
-    /** Test String conversions return an empty string when given null. */
-    @Test
-    public void testStringConversionNull() {
-        assertEquals("", simpleValue(null).asString());
-    }
-
-    /**
-     * Get a fixed value MetadataValue.
-     *
-     * @param value the value to wrap
-     * @return the fixed value
-     */
-    private MetadataValue simpleValue(Object value) {
-        return new FixedMetadataValue(plugin, value);
-    }
-
-    /**
-     * A sample non-trivial MetadataValueAdapter implementation.
-     *
-     * The rationale for implementing an incrementing value is to have a value
-     * which changes with every call to value(). This is important for testing
-     * because we want to make sure all the tested conversions are calling the
-     * value() method exactly once and no caching is going on.
-     */
-    class IncrementingMetaValue extends MetadataValueAdapter {
-        private int internalValue = 0;
-
-        protected IncrementingMetaValue(Plugin owningPlugin) {
-            super(owningPlugin);
-        }
-
-        @Override
-        public Object value() {
-            return ++internalValue;
-        }
-
-        @Override
-        public void invalidate() {
-            internalValue = 0;
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/plugin/PluginManagerTest.java b/src/test/java/org/bukkit/plugin/PluginManagerTest.java
deleted file mode 100644
index 1941c9f49e9514c1236c5f4ea9f7af47f7be85c5..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/plugin/PluginManagerTest.java
+++ /dev/null
@@ -1,184 +0,0 @@
-package org.bukkit.plugin;
-
-import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-import org.bukkit.TestServer;
-import org.bukkit.event.Event;
-import org.bukkit.event.TestEvent;
-import org.bukkit.permissions.Permission;
-import org.junit.After;
-import org.junit.Test;
-
-public class PluginManagerTest {
-    private class MutableObject {
-        volatile Object value = null;
-    }
-
-    private static final PluginManager pm = TestServer.getInstance().getPluginManager();
-
-    private final MutableObject store = new MutableObject();
-/* // Paper start - remove unneeded test
-    @Test
-    public void testAsyncSameThread() {
-        final Event event = new TestEvent(true);
-        try {
-            pm.callEvent(event);
-        } catch (IllegalStateException ex) {
-            assertThat(event.getEventName() + " cannot be triggered asynchronously from primary server thread.", is(ex.getMessage()));
-            return;
-        }
-        throw new IllegalStateException("No exception thrown");
-    }*/ // Paper end
-
-    @Test
-    public void testSyncSameThread() {
-        final Event event = new TestEvent(false);
-        pm.callEvent(event);
-    }
-/* // Paper start - remove unneeded test
-    @Test
-    public void testAsyncLocked() throws InterruptedException {
-        final Event event = new TestEvent(true);
-        Thread secondThread = new Thread(
-            new Runnable() {
-                @Override
-                public void run() {
-                    try {
-                        synchronized (pm) {
-                            pm.callEvent(event);
-                        }
-                    } catch (Throwable ex) {
-                        store.value = ex;
-                    }
-                }
-            }
-        );
-        secondThread.start();
-        secondThread.join();
-        assertThat(store.value, is(instanceOf(IllegalStateException.class)));
-        assertThat(event.getEventName() + " cannot be triggered asynchronously from inside synchronized code.", is(((Throwable) store.value).getMessage()));
-    }
-
-    @Test
-    public void testAsyncUnlocked() throws InterruptedException {
-        final Event event = new TestEvent(true);
-        Thread secondThread = new Thread(
-            new Runnable() {
-                @Override
-                public void run() {
-                    try {
-                        pm.callEvent(event);
-                    } catch (Throwable ex) {
-                        store.value = ex;
-                    }
-                }
-            }
-        );
-        secondThread.start();
-        secondThread.join();
-        if (store.value != null) {
-            throw new RuntimeException((Throwable) store.value);
-        }
-    }
-
-    @Test
-    public void testSyncUnlocked() throws InterruptedException {
-        final Event event = new TestEvent(false);
-        Thread secondThread = new Thread(
-            new Runnable() {
-                @Override
-                public void run() {
-                    try {
-                        pm.callEvent(event);
-                    } catch (Throwable ex) {
-                        store.value = ex;
-                        assertThat(event.getEventName() + " cannot be triggered asynchronously from another thread.", is(ex.getMessage()));
-                        return;
-                    }
-                }
-            }
-        );
-        secondThread.start();
-        secondThread.join();
-        if (store.value == null) {
-            throw new IllegalStateException("No exception thrown");
-        }
-    }
-
-    @Test
-    public void testSyncLocked() throws InterruptedException {
-        final Event event = new TestEvent(false);
-        Thread secondThread = new Thread(
-            new Runnable() {
-                @Override
-                public void run() {
-                    try {
-                        synchronized (pm) {
-                            pm.callEvent(event);
-                        }
-                    } catch (Throwable ex) {
-                        store.value = ex;
-                        assertThat(event.getEventName() + " cannot be triggered asynchronously from another thread.", is(ex.getMessage()));
-                        return;
-                    }
-                }
-            }
-        );
-        secondThread.start();
-        secondThread.join();
-        if (store.value == null) {
-            throw new IllegalStateException("No exception thrown");
-        }
-    } */ // Paper
-
-    @Test
-    public void testRemovePermissionByNameLower() {
-        this.testRemovePermissionByName("lower");
-    }
-
-    @Test
-    public void testRemovePermissionByNameUpper() {
-        this.testRemovePermissionByName("UPPER");
-    }
-
-    @Test
-    public void testRemovePermissionByNameCamel() {
-        this.testRemovePermissionByName("CaMeL");
-    }
-
-    public void testRemovePermissionByPermissionLower() {
-        this.testRemovePermissionByPermission("lower");
-    }
-
-    @Test
-    public void testRemovePermissionByPermissionUpper() {
-        this.testRemovePermissionByPermission("UPPER");
-    }
-
-    @Test
-    public void testRemovePermissionByPermissionCamel() {
-        this.testRemovePermissionByPermission("CaMeL");
-    }
-
-    private void testRemovePermissionByName(final String name) {
-        final Permission perm = new Permission(name);
-        pm.addPermission(perm);
-        assertThat("Permission \"" + name + "\" was not added", pm.getPermission(name), is(perm));
-        pm.removePermission(name);
-        assertThat("Permission \"" + name + "\" was not removed", pm.getPermission(name), is(nullValue()));
-    }
-
-    private void testRemovePermissionByPermission(final String name) {
-        final Permission perm = new Permission(name);
-        pm.addPermission(perm);
-        assertThat("Permission \"" + name + "\" was not added", pm.getPermission(name), is(perm));
-        pm.removePermission(perm);
-        assertThat("Permission \"" + name + "\" was not removed", pm.getPermission(name), is(nullValue()));
-    }
-
-    @After
-    public void tearDown() {
-        pm.clearPlugins();
-        assertThat(pm.getPermissions(), is(empty()));
-    }
-}
diff --git a/src/test/java/org/bukkit/plugin/TestPlugin.java b/src/test/java/org/bukkit/plugin/TestPlugin.java
deleted file mode 100644
index 6d450897187e810070f633e832034763a102a0b0..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/plugin/TestPlugin.java
+++ /dev/null
@@ -1,124 +0,0 @@
-package org.bukkit.plugin;
-
-import java.io.File;
-import java.io.InputStream;
-import java.util.List;
-import org.bukkit.Server;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandSender;
-import org.bukkit.configuration.file.FileConfiguration;
-import org.bukkit.generator.ChunkGenerator;
-
-public class TestPlugin extends PluginBase {
-    private boolean enabled = true;
-
-    private final String pluginName;
-
-    public TestPlugin(String pluginName) {
-        this.pluginName = pluginName;
-    }
-
-    public void setEnabled(boolean enabled) {
-        this.enabled = enabled;
-    }
-
-    @Override
-    public File getDataFolder() {
-        throw new UnsupportedOperationException("Not supported.");
-    }
-
-    @Override
-    public PluginDescriptionFile getDescription() {
-        return new PluginDescriptionFile(pluginName, "1.0", "test.test");
-    }
-
-    @Override
-    public FileConfiguration getConfig() {
-        throw new UnsupportedOperationException("Not supported.");
-    }
-
-    @Override
-    public InputStream getResource(String filename) {
-        throw new UnsupportedOperationException("Not supported.");
-    }
-
-    @Override
-    public void saveConfig() {
-        throw new UnsupportedOperationException("Not supported.");
-    }
-
-    @Override
-    public void saveDefaultConfig() {
-        throw new UnsupportedOperationException("Not supported.");
-    }
-
-    @Override
-    public void saveResource(String resourcePath, boolean replace) {
-        throw new UnsupportedOperationException("Not supported.");
-    }
-
-    @Override
-    public void reloadConfig() {
-        throw new UnsupportedOperationException("Not supported.");
-    }
-
-    @Override
-    public PluginLogger getLogger() {
-        throw new UnsupportedOperationException("Not supported.");
-    }
-
-    @Override
-    public PluginLoader getPluginLoader() {
-        throw new UnsupportedOperationException("Not supported.");
-    }
-
-    @Override
-    public Server getServer() {
-        throw new UnsupportedOperationException("Not supported.");
-    }
-
-    @Override
-    public boolean isEnabled() {
-        return enabled;
-    }
-
-    @Override
-    public void onDisable() {
-        throw new UnsupportedOperationException("Not supported.");
-    }
-
-    @Override
-    public void onLoad() {
-        throw new UnsupportedOperationException("Not supported.");
-    }
-
-    @Override
-    public void onEnable() {
-        throw new UnsupportedOperationException("Not supported.");
-    }
-
-    @Override
-    public boolean isNaggable() {
-        throw new UnsupportedOperationException("Not supported.");
-    }
-
-    @Override
-    public void setNaggable(boolean canNag) {
-        throw new UnsupportedOperationException("Not supported.");
-    }
-
-    @Override
-    public ChunkGenerator getDefaultWorldGenerator(String worldName, String id) {
-        throw new UnsupportedOperationException("Not supported.");
-    }
-
-    @Override
-    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
-        throw new UnsupportedOperationException("Not supported.");
-    }
-
-    @Override
-    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {
-        throw new UnsupportedOperationException("Not supported.");
-    }
-}
diff --git a/src/test/java/org/bukkit/plugin/TimedRegisteredListenerTest.java b/src/test/java/org/bukkit/plugin/TimedRegisteredListenerTest.java
deleted file mode 100644
index 351fc4a9f45745984d1d4811ba836959a3f3eadb..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/plugin/TimedRegisteredListenerTest.java
+++ /dev/null
@@ -1,56 +0,0 @@
-package org.bukkit.plugin;
-
-import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-import org.bukkit.event.Event;
-import org.bukkit.event.EventException;
-import org.bukkit.event.EventPriority;
-import org.bukkit.event.Listener;
-import org.bukkit.event.block.BlockBreakEvent;
-import org.bukkit.event.player.PlayerEvent;
-import org.bukkit.event.player.PlayerInteractEvent;
-import org.bukkit.event.player.PlayerMoveEvent;
-import org.junit.Test;
-
-public class TimedRegisteredListenerTest {
-
-    @Test
-    public void testEventClass() throws EventException {
-        Listener listener = new Listener() {};
-        EventExecutor executor = new EventExecutor() {
-            @Override
-            public void execute(Listener listener, Event event) {}
-        };
-        TestPlugin plugin = new TestPlugin("Test");
-
-        PlayerInteractEvent interactEvent = new PlayerInteractEvent(null, null, null, null, null);
-        PlayerMoveEvent moveEvent = new PlayerMoveEvent(null, null, null);
-        BlockBreakEvent breakEvent = new BlockBreakEvent(null, null);
-
-        TimedRegisteredListener trl = new TimedRegisteredListener(listener, executor, EventPriority.NORMAL, plugin, false);
-
-        // Ensure that the correct event type is reported for a single event
-        trl.callEvent(interactEvent);
-        assertThat(trl.getEventClass(), is((Object) PlayerInteractEvent.class));
-        // Ensure that no superclass is used in lieu of the actual event, after two identical event types
-        trl.callEvent(interactEvent);
-        assertThat(trl.getEventClass(), is((Object) PlayerInteractEvent.class));
-        // Ensure that the closest superclass of the two events is chosen
-        trl.callEvent(moveEvent);
-        assertThat(trl.getEventClass(), is((Object) PlayerEvent.class));
-        // As above, so below
-        trl.callEvent(breakEvent);
-        assertThat(trl.getEventClass(), is((Object) Event.class));
-        // In the name of being thorough, check that it never travels down the hierarchy again.
-        trl.callEvent(breakEvent);
-        assertThat(trl.getEventClass(), is((Object) Event.class));
-
-        trl = new TimedRegisteredListener(listener, executor, EventPriority.NORMAL, plugin, false);
-
-        trl.callEvent(breakEvent);
-        assertThat(trl.getEventClass(), is((Object) BlockBreakEvent.class));
-        // Test moving up the class hierarchy by more than one class at a time
-        trl.callEvent(moveEvent);
-        assertThat(trl.getEventClass(), is((Object) Event.class));
-    }
-}
diff --git a/src/test/java/org/bukkit/plugin/messaging/StandardMessengerTest.java b/src/test/java/org/bukkit/plugin/messaging/StandardMessengerTest.java
deleted file mode 100644
index 7e2335ed8acc692af1e70eddcf97ee7a56e30f68..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/plugin/messaging/StandardMessengerTest.java
+++ /dev/null
@@ -1,305 +0,0 @@
-package org.bukkit.plugin.messaging;
-
-import static org.hamcrest.CoreMatchers.*;
-import static org.junit.Assert.*;
-import java.util.Collection;
-import org.bukkit.entity.Player;
-import org.bukkit.plugin.TestPlugin;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class StandardMessengerTest {
-    public StandardMessenger getMessenger() {
-        return new StandardMessenger();
-    }
-
-    private int count = 0;
-    public TestPlugin getPlugin() {
-        return new TestPlugin("" + count++);
-    }
-
-    @Test
-    public void testIsReservedChannel() {
-        Messenger messenger = getMessenger();
-
-        assertTrue(messenger.isReservedChannel("minecraft:register"));
-        assertFalse(messenger.isReservedChannel("test:register"));
-        assertTrue(messenger.isReservedChannel("minecraft:unregister"));
-        assertFalse(messenger.isReservedChannel("test:unregister")); // Paper - fix typo
-        assertFalse(messenger.isReservedChannel("minecraft:something")); // Paper - now less strict
-        assertFalse(messenger.isReservedChannel("minecraft:brand"));
-    }
-
-    @Test
-    public void testRegisterAndUnregisterOutgoingPluginChannel() {
-        Messenger messenger = getMessenger();
-        TestPlugin plugin = getPlugin();
-
-        assertFalse(messenger.isOutgoingChannelRegistered(plugin, "test:foo"));
-        messenger.registerOutgoingPluginChannel(plugin, "test:foo");
-        assertTrue(messenger.isOutgoingChannelRegistered(plugin, "test:foo"));
-        assertFalse(messenger.isOutgoingChannelRegistered(plugin, "test:bar"));
-
-        messenger.unregisterOutgoingPluginChannel(plugin, "test:foo");
-        assertFalse(messenger.isOutgoingChannelRegistered(plugin, "test:foo"));
-    }
-
-    @Test(expected = ReservedChannelException.class)
-    public void testReservedOutgoingRegistration() {
-        Messenger messenger = getMessenger();
-        TestPlugin plugin = getPlugin();
-
-        messenger.registerOutgoingPluginChannel(plugin, "minecraft:register");
-    }
-
-    @Test
-    public void testUnregisterOutgoingPluginChannel_Plugin() {
-        Messenger messenger = getMessenger();
-        TestPlugin plugin = getPlugin();
-
-        assertFalse(messenger.isOutgoingChannelRegistered(plugin, "test:foo"));
-        messenger.registerOutgoingPluginChannel(plugin, "test:foo");
-        messenger.registerOutgoingPluginChannel(plugin, "test:bar");
-        assertTrue(messenger.isOutgoingChannelRegistered(plugin, "test:foo"));
-        assertTrue(messenger.isOutgoingChannelRegistered(plugin, "test:bar"));
-
-        messenger.unregisterOutgoingPluginChannel(plugin);
-        assertFalse(messenger.isOutgoingChannelRegistered(plugin, "test:foo"));
-        assertFalse(messenger.isOutgoingChannelRegistered(plugin, "test:bar"));
-    }
-
-    @Test
-    public void testRegisterIncomingPluginChannel() {
-        Messenger messenger = getMessenger();
-        TestPlugin plugin = getPlugin();
-        TestMessageListener listener = new TestMessageListener("test:foo", "test:bar".getBytes());
-        Player player = TestPlayer.getInstance();
-        PluginMessageListenerRegistration registration = messenger.registerIncomingPluginChannel(plugin, "test:foo", listener);
-
-        assertTrue(registration.isValid());
-        assertTrue(messenger.isIncomingChannelRegistered(plugin, "test:foo"));
-        messenger.dispatchIncomingMessage(player, "test:foo", "test:bar".getBytes());
-        assertTrue(listener.hasReceived());
-
-        messenger.unregisterIncomingPluginChannel(plugin, "test:foo", listener);
-        listener.reset();
-
-        assertFalse(registration.isValid());
-        assertFalse(messenger.isIncomingChannelRegistered(plugin, "test:foo"));
-        messenger.dispatchIncomingMessage(player, "test:foo", "test:bar".getBytes());
-        assertFalse(listener.hasReceived());
-    }
-
-    @Test(expected = ReservedChannelException.class)
-    public void testReservedIncomingRegistration() {
-        Messenger messenger = getMessenger();
-        TestPlugin plugin = getPlugin();
-
-        messenger.registerIncomingPluginChannel(plugin, "minecraft:register", new TestMessageListener("test:foo", "test:bar".getBytes()));
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testDuplicateIncomingRegistration() {
-        Messenger messenger = getMessenger();
-        TestPlugin plugin = getPlugin();
-        TestMessageListener listener = new TestMessageListener("test:foo", "test:bar".getBytes());
-
-        messenger.registerIncomingPluginChannel(plugin, "test:baz", listener);
-        messenger.registerIncomingPluginChannel(plugin, "test:baz", listener);
-    }
-
-    @Test
-    public void testUnregisterIncomingPluginChannel_Plugin_String() {
-        Messenger messenger = getMessenger();
-        TestPlugin plugin = getPlugin();
-        TestMessageListener listener1 = new TestMessageListener("test:foo", "test:bar".getBytes());
-        TestMessageListener listener2 = new TestMessageListener("test:baz", "test:qux".getBytes());
-        Player player = TestPlayer.getInstance();
-        PluginMessageListenerRegistration registration1 = messenger.registerIncomingPluginChannel(plugin, "test:foo", listener1);
-        PluginMessageListenerRegistration registration2 = messenger.registerIncomingPluginChannel(plugin, "test:baz", listener2);
-
-        assertTrue(registration1.isValid());
-        assertTrue(registration2.isValid());
-        messenger.dispatchIncomingMessage(player, "test:foo", "test:bar".getBytes());
-        messenger.dispatchIncomingMessage(player, "test:baz", "test:qux".getBytes());
-        assertTrue(listener1.hasReceived());
-        assertTrue(listener2.hasReceived());
-
-        messenger.unregisterIncomingPluginChannel(plugin, "test:foo");
-        listener1.reset();
-        listener2.reset();
-
-        assertFalse(registration1.isValid());
-        assertTrue(registration2.isValid());
-        messenger.dispatchIncomingMessage(player, "test:foo", "test:bar".getBytes());
-        messenger.dispatchIncomingMessage(player, "test:baz", "test:qux".getBytes());
-        assertFalse(listener1.hasReceived());
-        assertTrue(listener2.hasReceived());
-    }
-
-    @Test
-    public void testUnregisterIncomingPluginChannel_Plugin() {
-        Messenger messenger = getMessenger();
-        TestPlugin plugin = getPlugin();
-        TestMessageListener listener1 = new TestMessageListener("test:foo", "test:bar".getBytes());
-        TestMessageListener listener2 = new TestMessageListener("test:baz", "test:qux".getBytes());
-        Player player = TestPlayer.getInstance();
-        PluginMessageListenerRegistration registration1 = messenger.registerIncomingPluginChannel(plugin, "test:foo", listener1);
-        PluginMessageListenerRegistration registration2 = messenger.registerIncomingPluginChannel(plugin, "test:baz", listener2);
-
-        assertTrue(registration1.isValid());
-        assertTrue(registration2.isValid());
-        messenger.dispatchIncomingMessage(player, "test:foo", "test:bar".getBytes());
-        messenger.dispatchIncomingMessage(player, "test:baz", "test:qux".getBytes());
-        assertTrue(listener1.hasReceived());
-        assertTrue(listener2.hasReceived());
-
-        messenger.unregisterIncomingPluginChannel(plugin);
-        listener1.reset();
-        listener2.reset();
-
-        assertFalse(registration1.isValid());
-        assertFalse(registration2.isValid());
-        messenger.dispatchIncomingMessage(player, "test:foo", "test:bar".getBytes());
-        messenger.dispatchIncomingMessage(player, "test:baz", "test:qux".getBytes());
-        assertFalse(listener1.hasReceived());
-        assertFalse(listener2.hasReceived());
-    }
-
-    @Test
-    public void testGetOutgoingChannels() {
-        Messenger messenger = getMessenger();
-        TestPlugin plugin1 = getPlugin();
-        TestPlugin plugin2 = getPlugin();
-
-        assertEquals(messenger.getOutgoingChannels());
-
-        messenger.registerOutgoingPluginChannel(plugin1, "test:foo");
-        messenger.registerOutgoingPluginChannel(plugin1, "test:bar");
-        messenger.registerOutgoingPluginChannel(plugin2, "test:baz");
-        messenger.registerOutgoingPluginChannel(plugin2, "test:baz");
-
-        assertEquals(messenger.getOutgoingChannels(), "test:foo", "test:bar", "test:baz");
-    }
-
-    @Test
-    public void testGetOutgoingChannels_Plugin() {
-        Messenger messenger = getMessenger();
-        TestPlugin plugin1 = getPlugin();
-        TestPlugin plugin2 = getPlugin();
-        TestPlugin plugin3 = getPlugin();
-
-        messenger.registerOutgoingPluginChannel(plugin1, "test:foo");
-        messenger.registerOutgoingPluginChannel(plugin1, "test:bar");
-        messenger.registerOutgoingPluginChannel(plugin2, "test:baz");
-        messenger.registerOutgoingPluginChannel(plugin2, "test:qux");
-
-        assertEquals(messenger.getOutgoingChannels(plugin1), "test:foo", "test:bar");
-        assertEquals(messenger.getOutgoingChannels(plugin2), "test:baz", "test:qux");
-        assertEquals(messenger.getOutgoingChannels(plugin3));
-    }
-
-    @Test
-    public void testGetIncomingChannels() {
-        Messenger messenger = getMessenger();
-        TestPlugin plugin1 = getPlugin();
-        TestPlugin plugin2 = getPlugin();
-
-        assertEquals(messenger.getIncomingChannels());
-
-        messenger.registerIncomingPluginChannel(plugin1, "test:foo", new TestMessageListener("test:foo", "test:bar".getBytes()));
-        messenger.registerIncomingPluginChannel(plugin1, "test:bar", new TestMessageListener("test:foo", "test:bar".getBytes()));
-        messenger.registerIncomingPluginChannel(plugin2, "test:baz", new TestMessageListener("test:foo", "test:bar".getBytes()));
-        messenger.registerIncomingPluginChannel(plugin2, "test:baz", new TestMessageListener("test:foo", "test:bar".getBytes()));
-
-        assertEquals(messenger.getIncomingChannels(), "test:foo", "test:bar", "test:baz");
-    }
-
-    @Test
-    public void testGetIncomingChannels_Plugin() {
-        Messenger messenger = getMessenger();
-        TestPlugin plugin1 = getPlugin();
-        TestPlugin plugin2 = getPlugin();
-        TestPlugin plugin3 = getPlugin();
-
-        messenger.registerIncomingPluginChannel(plugin1, "test:foo", new TestMessageListener("test:foo", "test:bar".getBytes()));
-        messenger.registerIncomingPluginChannel(plugin1, "test:bar", new TestMessageListener("test:foo", "test:bar".getBytes()));
-        messenger.registerIncomingPluginChannel(plugin2, "test:baz", new TestMessageListener("test:foo", "test:bar".getBytes()));
-        messenger.registerIncomingPluginChannel(plugin2, "test:qux", new TestMessageListener("test:foo", "test:bar".getBytes()));
-
-        assertEquals(messenger.getIncomingChannels(plugin1), "test:foo", "test:bar");
-        assertEquals(messenger.getIncomingChannels(plugin2), "test:baz", "test:qux");
-        assertEquals(messenger.getIncomingChannels(plugin3));
-    }
-
-    @Test
-    public void testGetIncomingChannelRegistrations_Plugin() {
-        Messenger messenger = getMessenger();
-        TestPlugin plugin1 = getPlugin();
-        TestPlugin plugin2 = getPlugin();
-        TestPlugin plugin3 = getPlugin();
-        PluginMessageListenerRegistration registration1 = messenger.registerIncomingPluginChannel(plugin1, "test:foo", new TestMessageListener("test:foo", "test:bar".getBytes()));
-        PluginMessageListenerRegistration registration2 = messenger.registerIncomingPluginChannel(plugin1, "test:bar", new TestMessageListener("test:foo", "test:bar".getBytes()));
-        PluginMessageListenerRegistration registration3 = messenger.registerIncomingPluginChannel(plugin2, "test:baz", new TestMessageListener("test:foo", "test:bar".getBytes()));
-        PluginMessageListenerRegistration registration4 = messenger.registerIncomingPluginChannel(plugin2, "test:qux", new TestMessageListener("test:foo", "test:bar".getBytes()));
-
-        assertEquals(messenger.getIncomingChannelRegistrations(plugin1), registration1, registration2);
-        assertEquals(messenger.getIncomingChannelRegistrations(plugin2), registration3, registration4);
-        assertEquals(messenger.getIncomingChannels(plugin3));
-    }
-
-    @Test
-    public void testGetIncomingChannelRegistrations_String() {
-        Messenger messenger = getMessenger();
-        TestPlugin plugin1 = getPlugin();
-        TestPlugin plugin2 = getPlugin();
-        PluginMessageListenerRegistration registration1 = messenger.registerIncomingPluginChannel(plugin1, "test:foo", new TestMessageListener("test:foo", "test:bar".getBytes()));
-        PluginMessageListenerRegistration registration2 = messenger.registerIncomingPluginChannel(plugin1, "test:bar", new TestMessageListener("test:foo", "test:bar".getBytes()));
-        PluginMessageListenerRegistration registration3 = messenger.registerIncomingPluginChannel(plugin2, "test:foo", new TestMessageListener("test:foo", "test:bar".getBytes()));
-        PluginMessageListenerRegistration registration4 = messenger.registerIncomingPluginChannel(plugin2, "test:bar", new TestMessageListener("test:foo", "test:bar".getBytes()));
-
-        assertEquals(messenger.getIncomingChannelRegistrations("test:foo"), registration1, registration3);
-        assertEquals(messenger.getIncomingChannelRegistrations("test:bar"), registration2, registration4);
-        assertEquals(messenger.getIncomingChannelRegistrations("test:baz"));
-    }
-
-    @Test
-    public void testGetIncomingChannelRegistrations_Plugin_String() {
-        Messenger messenger = getMessenger();
-        TestPlugin plugin1 = getPlugin();
-        TestPlugin plugin2 = getPlugin();
-        TestPlugin plugin3 = getPlugin();
-        PluginMessageListenerRegistration registration1 = messenger.registerIncomingPluginChannel(plugin1, "test:foo", new TestMessageListener("test:foo", "test:bar".getBytes()));
-        PluginMessageListenerRegistration registration2 = messenger.registerIncomingPluginChannel(plugin1, "test:foo", new TestMessageListener("test:foo", "test:bar".getBytes()));
-        PluginMessageListenerRegistration registration3 = messenger.registerIncomingPluginChannel(plugin1, "test:bar", new TestMessageListener("test:foo", "test:bar".getBytes()));
-        PluginMessageListenerRegistration registration4 = messenger.registerIncomingPluginChannel(plugin2, "test:bar", new TestMessageListener("test:foo", "test:bar".getBytes()));
-        PluginMessageListenerRegistration registration5 = messenger.registerIncomingPluginChannel(plugin2, "test:baz", new TestMessageListener("test:foo", "test:bar".getBytes()));
-        PluginMessageListenerRegistration registration6 = messenger.registerIncomingPluginChannel(plugin2, "test:baz", new TestMessageListener("test:foo", "test:bar".getBytes()));
-
-        assertEquals(messenger.getIncomingChannelRegistrations(plugin1, "test:foo"), registration1, registration2);
-        assertEquals(messenger.getIncomingChannelRegistrations(plugin1, "test:bar"), registration3);
-        assertEquals(messenger.getIncomingChannelRegistrations(plugin2, "test:bar"), registration4);
-        assertEquals(messenger.getIncomingChannelRegistrations(plugin2, "test:baz"), registration5, registration6);
-        assertEquals(messenger.getIncomingChannelRegistrations(plugin1, "test:baz"));
-        assertEquals(messenger.getIncomingChannelRegistrations(plugin3, "test:qux"));
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testInvalidChannel() {
-        Messenger messenger = getMessenger();
-        TestPlugin plugin = getPlugin();
-
-        messenger.registerOutgoingPluginChannel(plugin, "foo");
-    }
-
-    @Test
-    public void testValidateAndCorrectChannel() {
-        Assert.assertEquals("bungeecord:main", StandardMessenger.validateAndCorrectChannel("BungeeCord"));
-        Assert.assertEquals("BungeeCord", StandardMessenger.validateAndCorrectChannel("bungeecord:main"));
-    }
-
-    private static <T> void assertEquals(Collection<T> actual, T... expected) {
-        assertThat("Size of the array", actual.size(), is(expected.length));
-        assertThat(actual, hasItems(expected));
-    }
-}
diff --git a/src/test/java/org/bukkit/plugin/messaging/TestMessageListener.java b/src/test/java/org/bukkit/plugin/messaging/TestMessageListener.java
deleted file mode 100644
index 7a5b6108d56b8350d1aa419caf25fe6c653066b4..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/plugin/messaging/TestMessageListener.java
+++ /dev/null
@@ -1,30 +0,0 @@
-package org.bukkit.plugin.messaging;
-
-import static org.junit.Assert.*;
-import org.bukkit.entity.Player;
-
-public class TestMessageListener implements PluginMessageListener {
-    private final String channel;
-    private final byte[] message;
-    private boolean received = false;
-
-    public TestMessageListener(String channel, byte[] message) {
-        this.channel = channel;
-        this.message = message;
-    }
-
-    @Override
-    public void onPluginMessageReceived(String channel, Player player, byte[] message) {
-        assertEquals(this.channel, channel);
-        assertArrayEquals(this.message, message);
-        this.received = true;
-    }
-
-    public boolean hasReceived() {
-        return received;
-    }
-
-    public void reset() {
-        received = false;
-    }
-}
diff --git a/src/test/java/org/bukkit/plugin/messaging/TestPlayer.java b/src/test/java/org/bukkit/plugin/messaging/TestPlayer.java
deleted file mode 100644
index 1b7642dc1c55c6bf87018b67d8c368478c0b9ca1..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/plugin/messaging/TestPlayer.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package org.bukkit.plugin.messaging;
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.Method;
-import java.lang.reflect.Proxy;
-import java.util.HashMap;
-import org.bukkit.entity.Player;
-
-
-public final class TestPlayer implements InvocationHandler {
-    private static interface MethodHandler {
-        Object handle(TestPlayer server, Object[] args);
-    }
-    private static final Constructor<? extends Player> constructor;
-    private static final HashMap<Method, MethodHandler> methods = new HashMap<Method, MethodHandler>();
-    static {
-        try {
-            /*
-            methods.put(Player.class.getMethod("methodName"),
-                new MethodHandler() {
-                    public Object handle(TestPlayer server, Object[] args) {
-                    }
-                });
-            */
-            constructor = Proxy.getProxyClass(Player.class.getClassLoader(), Player.class).asSubclass(Player.class).getConstructor(InvocationHandler.class);
-        } catch (Throwable t) {
-            throw new Error(t);
-        }
-    }
-
-    private TestPlayer() {};
-
-    public static Player getInstance() {
-        try {
-            return constructor.newInstance(new TestPlayer());
-        } catch (Throwable t) {
-            throw new RuntimeException(t);
-        }
-    }
-
-    @Override
-    public Object invoke(Object proxy, Method method, Object[] args) {
-        MethodHandler handler = methods.get(method);
-        if (handler != null) {
-            return handler.handle(this, args);
-        }
-        throw new UnsupportedOperationException(String.valueOf(method));
-    }
-}
diff --git a/src/test/java/org/bukkit/util/BoundingBoxTest.java b/src/test/java/org/bukkit/util/BoundingBoxTest.java
deleted file mode 100644
index 2d50a9ed66d40c9c538f5e767d9e128394f5dc3b..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/util/BoundingBoxTest.java
+++ /dev/null
@@ -1,204 +0,0 @@
-package org.bukkit.util;
-
-import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-import java.util.Map;
-import org.bukkit.Location;
-import org.bukkit.block.BlockFace;
-import org.junit.Test;
-
-public class BoundingBoxTest {
-
-    private static final double delta = 1.0 / 1000000;
-
-    @Test
-    public void testConstruction() {
-        BoundingBox expected = new BoundingBox(-1, -1, -1, 1, 2, 3);
-        assertThat(expected.getMin(), is(new Vector(-1, -1, -1)));
-        assertThat(expected.getMax(), is(new Vector(1, 2, 3)));
-        assertThat(expected.getCenter(), is(new Vector(0.0D, 0.5D, 1.0D)));
-        assertThat(expected.getWidthX(), is(2.0D));
-        assertThat(expected.getHeight(), is(3.0D));
-        assertThat(expected.getWidthZ(), is(4.0D));
-        assertThat(expected.getVolume(), is(24.0D));
-
-        assertThat(BoundingBox.of(new Vector(-1, -1, -1), new Vector(1, 2, 3)), is(expected));
-        assertThat(BoundingBox.of(new Vector(1, 2, 3), new Vector(-1, -1, -1)), is(expected));
-        assertThat(BoundingBox.of(new Location(null, -1, -1, -1), new Location(null, 1, 2, 3)), is(expected));
-        assertThat(BoundingBox.of(new Vector(0.0D, 0.5D, 1.0D), 1.0D, 1.5D, 2.0D), is(expected));
-        assertThat(BoundingBox.of(new Location(null, 0.0D, 0.5D, 1.0D), 1.0D, 1.5D, 2.0D), is(expected));
-    }
-
-    @Test
-    public void testContains() {
-        BoundingBox aabb = new BoundingBox(-1, -1, -1, 1, 2, 3);
-        assertThat(aabb.contains(-0.5D, 0.0D, 0.5D), is(true));
-        assertThat(aabb.contains(-1.0D, -1.0D, -1.0D), is(true));
-        assertThat(aabb.contains(1.0D, 2.0D, 3.0D), is(false));
-        assertThat(aabb.contains(-1.0D, 1.0D, 4.0D), is(false));
-        assertThat(aabb.contains(new Vector(-0.5D, 0.0D, 0.5D)), is(true));
-
-        assertThat(aabb.contains(new BoundingBox(-0.5D, -0.5D, -0.5D, 0.5D, 1.0D, 2.0D)), is(true));
-        assertThat(aabb.contains(aabb), is(true));
-        assertThat(aabb.contains(new BoundingBox(-1, -1, -1, 1, 1, 3)), is(true));
-        assertThat(aabb.contains(new BoundingBox(-2, -1, -1, 1, 2, 3)), is(false));
-        assertThat(aabb.contains(new Vector(-0.5D, -0.5D, -0.5D), new Vector(0.5D, 1.0D, 2.0D)), is(true));
-    }
-
-    @Test
-    public void testOverlaps() {
-        BoundingBox aabb = new BoundingBox(-1, -1, -1, 1, 2, 3);
-        assertThat(aabb.contains(aabb), is(true));
-        assertThat(aabb.overlaps(new BoundingBox(-2, -2, -2, 0, 0, 0)), is(true));
-        assertThat(aabb.overlaps(new BoundingBox(0.5D, 1.5D, 2.5D, 1, 2, 3)), is(true));
-        assertThat(aabb.overlaps(new BoundingBox(0.5D, 1.5D, 2.5D, 2, 3, 4)), is(true));
-        assertThat(aabb.overlaps(new BoundingBox(-2, -2, -2, -1, -1, -1)), is(false));
-        assertThat(aabb.overlaps(new BoundingBox(1, 2, 3, 2, 3, 4)), is(false));
-        assertThat(aabb.overlaps(new Vector(0.5D, 1.5D, 2.5D), new Vector(1, 2, 3)), is(true));
-    }
-
-    @Test
-    public void testDegenerate() {
-        BoundingBox aabb = new BoundingBox(0, 0, 0, 0, 0, 0);
-        assertThat(aabb.getWidthX(), is(0.0D));
-        assertThat(aabb.getHeight(), is(0.0D));
-        assertThat(aabb.getWidthZ(), is(0.0D));
-        assertThat(aabb.getVolume(), is(0.0D));
-    }
-
-    @Test
-    public void testShift() {
-        BoundingBox aabb = new BoundingBox(0, 0, 0, 1, 1, 1);
-        assertThat(aabb.clone().shift(1, 2, 3), is(new BoundingBox(1, 2, 3, 2, 3, 4)));
-        assertThat(aabb.clone().shift(-1, -2, -3), is(new BoundingBox(-1, -2, -3, 0, -1, -2)));
-        assertThat(aabb.clone().shift(new Vector(1, 2, 3)), is(new BoundingBox(1, 2, 3, 2, 3, 4)));
-        assertThat(aabb.clone().shift(new Location(null, 1, 2, 3)), is(new BoundingBox(1, 2, 3, 2, 3, 4)));
-    }
-
-    @Test
-    public void testUnion() {
-        BoundingBox aabb1 = new BoundingBox(0, 0, 0, 1, 1, 1);
-        assertThat(aabb1.clone().union(new BoundingBox(-2, -2, -2, -1, -1, -1)), is(new BoundingBox(-2, -2, -2, 1, 1, 1)));
-        assertThat(aabb1.clone().union(1, 2, 3), is(new BoundingBox(0, 0, 0, 1, 2, 3)));
-        assertThat(aabb1.clone().union(new Vector(1, 2, 3)), is(new BoundingBox(0, 0, 0, 1, 2, 3)));
-        assertThat(aabb1.clone().union(new Location(null, 1, 2, 3)), is(new BoundingBox(0, 0, 0, 1, 2, 3)));
-    }
-
-    @Test
-    public void testIntersection() {
-        BoundingBox aabb = new BoundingBox(-1, -1, -1, 1, 2, 3);
-        assertThat(aabb.clone().intersection(new BoundingBox(-2, -2, -2, 4, 4, 4)), is(aabb));
-        assertThat(aabb.clone().intersection(new BoundingBox(-2, -2, -2, 1, 1, 1)), is(new BoundingBox(-1, -1, -1, 1, 1, 1)));
-    }
-
-    @Test
-    public void testExpansion() {
-        BoundingBox aabb = new BoundingBox(0, 0, 0, 2, 2, 2);
-        assertThat(aabb.clone().expand(1, 2, 3, 1, 2, 3), is(new BoundingBox(-1, -2, -3, 3, 4, 5)));
-        assertThat(aabb.clone().expand(-1, -2, -3, 1, 2, 3), is(new BoundingBox(1, 2, 3, 3, 4, 5)));
-        assertThat(aabb.clone().expand(1, 2, 3, -1, -2, -3), is(new BoundingBox(-1, -2, -3, 1, 0, -1)));
-        assertThat(aabb.clone().expand(-1, -2, -3, -0.5D, -0.5, -3), is(new BoundingBox(1, 1.5D, 1, 1.5D, 1.5D, 1)));
-
-        assertThat(aabb.clone().expand(1, 2, 3), is(new BoundingBox(-1, -2, -3, 3, 4, 5)));
-        assertThat(aabb.clone().expand(-0.1, -0.5, -2), is(new BoundingBox(0.1D, 0.5D, 1, 1.9D, 1.5D, 1)));
-        assertThat(aabb.clone().expand(new Vector(1, 2, 3)), is(new BoundingBox(-1, -2, -3, 3, 4, 5)));
-
-        assertThat(aabb.clone().expand(1), is(new BoundingBox(-1, -1, -1, 3, 3, 3)));
-        assertThat(aabb.clone().expand(-0.5D), is(new BoundingBox(0.5D, 0.5D, 0.5D, 1.5D, 1.5D, 1.5D)));
-
-        assertThat(aabb.clone().expand(1, 0, 0, 0.5D), is(new BoundingBox(0, 0, 0, 2.5D, 2, 2)));
-        assertThat(aabb.clone().expand(1, 0, 0, -0.5D), is(new BoundingBox(0, 0, 0, 1.5D, 2, 2)));
-        assertThat(aabb.clone().expand(-1, 0, 0, 0.5D), is(new BoundingBox(-0.5D, 0, 0, 2, 2, 2)));
-        assertThat(aabb.clone().expand(-1, 0, 0, -0.5D), is(new BoundingBox(0.5D, 0, 0, 2, 2, 2)));
-
-        assertThat(aabb.clone().expand(0, 1, 0, 0.5D), is(new BoundingBox(0, 0, 0, 2, 2.5D, 2)));
-        assertThat(aabb.clone().expand(0, 1, 0, -0.5D), is(new BoundingBox(0, 0, 0, 2, 1.5D, 2)));
-        assertThat(aabb.clone().expand(0, -1, 0, 0.5D), is(new BoundingBox(0, -0.5D, 0, 2, 2, 2)));
-        assertThat(aabb.clone().expand(0, -1, 0, -0.5D), is(new BoundingBox(0, 0.5D, 0, 2, 2, 2)));
-
-        assertThat(aabb.clone().expand(0, 0, 1, 0.5D), is(new BoundingBox(0, 0, 0, 2, 2, 2.5D)));
-        assertThat(aabb.clone().expand(0, 0, 1, -0.5D), is(new BoundingBox(0, 0, 0, 2, 2, 1.5D)));
-        assertThat(aabb.clone().expand(0, 0, -1, 0.5D), is(new BoundingBox(0, 0, -0.5D, 2, 2, 2)));
-        assertThat(aabb.clone().expand(0, 0, -1, -0.5D), is(new BoundingBox(0, 0, 0.5D, 2, 2, 2)));
-
-        assertThat(aabb.clone().expand(new Vector(1, 0, 0), 0.5D), is(new BoundingBox(0, 0, 0, 2.5D, 2, 2)));
-        assertThat(aabb.clone().expand(BlockFace.EAST, 0.5D), is(new BoundingBox(0, 0, 0, 2.5D, 2, 2)));
-        assertThat(aabb.clone().expand(BlockFace.NORTH_NORTH_WEST, 1.0D), is(aabb.clone().expand(BlockFace.NORTH_NORTH_WEST.getDirection(), 1.0D)));
-        assertThat(aabb.clone().expand(BlockFace.SELF, 1.0D), is(aabb));
-
-        BoundingBox expanded = aabb.clone().expand(BlockFace.NORTH_WEST, 1.0D);
-        assertThat(expanded.getWidthX(), is(closeTo(aabb.getWidthX() + Math.sqrt(0.5D), delta)));
-        assertThat(expanded.getWidthZ(), is(closeTo(aabb.getWidthZ() + Math.sqrt(0.5D), delta)));
-        assertThat(expanded.getHeight(), is(aabb.getHeight()));
-
-        assertThat(aabb.clone().expandDirectional(1, 2, 3), is(new BoundingBox(0, 0, 0, 3, 4, 5)));
-        assertThat(aabb.clone().expandDirectional(-1, -2, -3), is(new BoundingBox(-1, -2, -3, 2, 2, 2)));
-        assertThat(aabb.clone().expandDirectional(new Vector(1, 2, 3)), is(new BoundingBox(0, 0, 0, 3, 4, 5)));
-    }
-
-    @Test
-    public void testRayTrace() {
-        BoundingBox aabb = new BoundingBox(-1, -1, -1, 1, 1, 1);
-
-        assertThat(aabb.rayTrace(new Vector(-2, 0, 0), new Vector(1, 0, 0), 10),
-                is(new RayTraceResult(new Vector(-1, 0, 0), BlockFace.WEST)));
-        assertThat(aabb.rayTrace(new Vector(2, 0, 0), new Vector(-1, 0, 0), 10),
-                is(new RayTraceResult(new Vector(1, 0, 0), BlockFace.EAST)));
-
-        assertThat(aabb.rayTrace(new Vector(0, -2, 0), new Vector(0, 1, 0), 10),
-                is(new RayTraceResult(new Vector(0, -1, 0), BlockFace.DOWN)));
-        assertThat(aabb.rayTrace(new Vector(0, 2, 0), new Vector(0, -1, 0), 10),
-                is(new RayTraceResult(new Vector(0, 1, 0), BlockFace.UP)));
-
-        assertThat(aabb.rayTrace(new Vector(0, 0, -2), new Vector(0, 0, 1), 10),
-                is(new RayTraceResult(new Vector(0, 0, -1), BlockFace.NORTH)));
-        assertThat(aabb.rayTrace(new Vector(0, 0, 2), new Vector(0, 0, -1), 10),
-                is(new RayTraceResult(new Vector(0, 0, 1), BlockFace.SOUTH)));
-
-        assertThat(aabb.rayTrace(new Vector(0, 0, 0), new Vector(1, 0, 0), 10),
-                is(new RayTraceResult(new Vector(1, 0, 0), BlockFace.EAST)));
-        assertThat(aabb.rayTrace(new Vector(0, 0, 0), new Vector(-1, 0, 0), 10),
-                is(new RayTraceResult(new Vector(-1, 0, 0), BlockFace.WEST)));
-
-        assertThat(aabb.rayTrace(new Vector(0, 0, 0), new Vector(0, 1, 0), 10),
-                is(new RayTraceResult(new Vector(0, 1, 0), BlockFace.UP)));
-        assertThat(aabb.rayTrace(new Vector(0, 0, 0), new Vector(0, -1, 0), 10),
-                is(new RayTraceResult(new Vector(0, -1, 0), BlockFace.DOWN)));
-
-        assertThat(aabb.rayTrace(new Vector(0, 0, 0), new Vector(0, 0, 1), 10),
-                is(new RayTraceResult(new Vector(0, 0, 1), BlockFace.SOUTH)));
-        assertThat(aabb.rayTrace(new Vector(0, 0, 0), new Vector(0, 0, -1), 10),
-                is(new RayTraceResult(new Vector(0, 0, -1), BlockFace.NORTH)));
-
-        assertThat(aabb.rayTrace(new Vector(-2, -2, -2), new Vector(1, 0, 0), 10), is(nullValue()));
-        assertThat(aabb.rayTrace(new Vector(-2, -2, -2), new Vector(0, 1, 0), 10), is(nullValue()));
-        assertThat(aabb.rayTrace(new Vector(-2, -2, -2), new Vector(0, 0, 1), 10), is(nullValue()));
-
-        assertThat(aabb.rayTrace(new Vector(0, 0, -3), new Vector(1, 0, 1), 10), is(nullValue()));
-        assertThat(aabb.rayTrace(new Vector(0, 0, -2), new Vector(1, 0, 2), 10),
-                is(new RayTraceResult(new Vector(0.5D, 0, -1), BlockFace.NORTH)));
-
-        // corner/edge hits yield unspecified block face:
-        assertThat(aabb.rayTrace(new Vector(2, 2, 2), new Vector(-1, -1, -1), 10),
-                anyOf(is(new RayTraceResult(new Vector(1, 1, 1), BlockFace.EAST)),
-                        is(new RayTraceResult(new Vector(1, 1, 1), BlockFace.UP)),
-                        is(new RayTraceResult(new Vector(1, 1, 1), BlockFace.SOUTH))));
-
-        assertThat(aabb.rayTrace(new Vector(-2, -2, -2), new Vector(1, 1, 1), 10),
-                anyOf(is(new RayTraceResult(new Vector(-1, -1, -1), BlockFace.WEST)),
-                        is(new RayTraceResult(new Vector(-1, -1, -1), BlockFace.DOWN)),
-                        is(new RayTraceResult(new Vector(-1, -1, -1), BlockFace.NORTH))));
-
-        assertThat(aabb.rayTrace(new Vector(0, 0, -2), new Vector(1, 0, 1), 10),
-                anyOf(is(new RayTraceResult(new Vector(1, 0, -1), BlockFace.NORTH)),
-                        is(new RayTraceResult(new Vector(1, 0, -1), BlockFace.EAST))));
-    }
-
-    @Test
-    public void testSerialization() {
-        BoundingBox aabb = new BoundingBox(-1, -1, -1, 1, 1, 1);
-        Map<String, Object> serialized = aabb.serialize();
-        BoundingBox deserialized = BoundingBox.deserialize(serialized);
-        assertThat(deserialized, is(aabb));
-    }
-}
diff --git a/src/test/java/org/bukkit/util/StringUtilStartsWithTest.java b/src/test/java/org/bukkit/util/StringUtilStartsWithTest.java
deleted file mode 100644
index 229c67c769f50ba68b4d9681f984b4bc668619c2..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/util/StringUtilStartsWithTest.java
+++ /dev/null
@@ -1,83 +0,0 @@
-package org.bukkit.util;
-
-import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-import com.google.common.collect.ImmutableList;
-import java.util.List;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameter;
-import org.junit.runners.Parameterized.Parameters;
-
-@RunWith(Parameterized.class)
-public class StringUtilStartsWithTest {
-
-    @Parameters(name = "{index}: {0} startsWith {1} == {2}")
-    public static List<Object[]> data() {
-        return ImmutableList.<Object[]>of(
-            new Object[] {
-                "Apple",
-                "Apples",
-                false
-            },
-            new Object[] {
-                "Apples",
-                "Apple",
-                true
-            },
-            new Object[] {
-                "Apple",
-                "Apple",
-                true
-            },
-            new Object[] {
-                "Apple",
-                "apples",
-                false
-            },
-            new Object[] {
-                "apple",
-                "Apples",
-                false
-            },
-            new Object[] {
-                "apple",
-                "apples",
-                false
-            },
-            new Object[] {
-                "Apples",
-                "apPL",
-                true
-            },
-            new Object[] {
-                "123456789",
-                "1234567",
-                true
-            },
-            new Object[] {
-                "",
-                "",
-                true
-            },
-            new Object[] {
-                "string",
-                "",
-                true
-            }
-        );
-    }
-
-    @Parameter(0)
-    public String base;
-    @Parameter(1)
-    public String prefix;
-    @Parameter(2)
-    public boolean result;
-
-    @Test
-    public void testFor() {
-        assertThat(base + " starts with " + prefix + ": " + result, StringUtil.startsWithIgnoreCase(base, prefix), is(result));
-    }
-}
diff --git a/src/test/java/org/bukkit/util/StringUtilTest.java b/src/test/java/org/bukkit/util/StringUtilTest.java
deleted file mode 100644
index 6476dd2d1b6d37c3390400d8dea94016b309d69f..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/util/StringUtilTest.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package org.bukkit.util;
-
-import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-import com.google.common.collect.ImmutableList;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import org.junit.Test;
-
-public class StringUtilTest {
-
-    @Test(expected = NullPointerException.class)
-    public void nullPrefixTest() {
-        StringUtil.startsWithIgnoreCase("String", null);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void nullStringTest() {
-        StringUtil.startsWithIgnoreCase(null, "String");
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void nullCollectionTest() {
-        StringUtil.copyPartialMatches("Token", ImmutableList.<String>of(), null);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void nullIterableTest() {
-        StringUtil.copyPartialMatches("Token", null, new ArrayList<String>());
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void nullTokenTest() {
-        StringUtil.copyPartialMatches(null, ImmutableList.<String>of(), new ArrayList<String>());
-    }
-
-    @Test
-    public void copyTokenTest() {
-        String token = "ab";
-        List<String> original = ImmutableList.of("ab12", "aC561", "AB5195", "Ab76", "", "a");
-        List<String> expected = ImmutableList.of("ab12", "AB5195", "Ab76");
-        List<String> list = new ArrayList<String>();
-        assertThat(StringUtil.copyPartialMatches(token, original, list), is(expected));
-        assertThat(StringUtil.copyPartialMatches(token, original, list), is(sameInstance(list)));
-        assertThat(list.size(), is(expected.size() * 2));
-    }
-
-    @Test(expected = UnsupportedOperationException.class)
-    public void copyUnsupportedTest() {
-        StringUtil.copyPartialMatches("token", ImmutableList.of("token1", "token2"), ImmutableList.of());
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void copyNullTest() {
-        StringUtil.copyPartialMatches("token", Arrays.asList("token1", "token2", null), new ArrayList<String>());
-    }
-}
diff --git a/src/test/java/org/bukkit/util/VectorTest.java b/src/test/java/org/bukkit/util/VectorTest.java
deleted file mode 100644
index 9b846deba8eb3ff43c444da70a9d7ca3d1b43b0a..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/util/VectorTest.java
+++ /dev/null
@@ -1,125 +0,0 @@
-package org.bukkit.util;
-
-import static org.junit.Assert.*;
-import org.bukkit.block.BlockFace;
-import org.junit.Test;
-
-public class VectorTest {
-
-    @Test
-    public void testNormalisedVectors() {
-        assertFalse(new Vector(1, 0, 0).multiply(1.1).isNormalized());
-
-        assertTrue(new Vector(1, 1, 1).normalize().isNormalized());
-        assertTrue(new Vector(1, 0, 0).isNormalized());
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testNullVectorAxis() {
-        new Vector(0, 1, 0).rotateAroundAxis(null, Math.PI);
-    }
-
-    @Test
-    public void testBypassingAxisVector() {
-        new Vector(0, 1, 0).rotateAroundNonUnitAxis(new Vector(1, 1, 1), Math.PI); // This will result some weird result, but there may be some use for it for some people
-    }
-
-    @Test
-    public void testResizeAxis() {
-        Vector axis = new Vector(0, 10, 0);
-        assertEquals(BlockFace.EAST.getDirection().rotateAroundAxis(axis, Math.PI * 0.5), BlockFace.NORTH.getDirection());
-    }
-
-    /**
-     * As west to east are the x axis in Minecraft, rotating around it from up
-     * should lead to up -> south -> down -> north.
-     */
-    @Test
-    public void testRotationAroundX() {
-        Vector vector = BlockFace.UP.getDirection();
-        assertEquals(BlockFace.SOUTH.getDirection(), vector.clone().rotateAroundX(Math.PI * 0.5)); // Should rotate around x axis for 1/4 of a circle.
-        assertEquals(BlockFace.DOWN.getDirection(), vector.clone().rotateAroundX(Math.PI * 1.0)); // Should rotate around x axis for 2/4 of a circle.
-        assertEquals(BlockFace.NORTH.getDirection(), vector.clone().rotateAroundX(Math.PI * 1.5)); // Should rotate around x axis for 3/4 of a circle.
-        assertEquals(BlockFace.UP.getDirection(), vector.clone().rotateAroundX(Math.PI * 2.0)); // Should rotate around x axis for 4/4 of a circle.
-    }
-
-    /**
-     * As up to down are the y axis in Minecraft, rotating around it from up
-     * should lead to east (positive x) -> south -> west -> north.
-     */
-    @Test
-    public void testRotationAroundY() {
-        Vector vector = BlockFace.EAST.getDirection();
-        assertEquals(BlockFace.NORTH.getDirection(), vector.clone().rotateAroundY(Math.PI * 0.5)); // Should rotate around x axis for 1/4 of a circle.
-        assertEquals(BlockFace.WEST.getDirection(), vector.clone().rotateAroundY(Math.PI * 1.0)); // Should rotate around x axis for 2/4 of a circle.
-        assertEquals(BlockFace.SOUTH.getDirection(), vector.clone().rotateAroundY(Math.PI * 1.5)); // Should rotate around x axis for 3/4 of a circle.
-        assertEquals(BlockFace.EAST.getDirection(), vector.clone().rotateAroundY(Math.PI * 2.0)); // Should rotate around x axis for 4/4 of a circle.
-    }
-
-    /**
-     * As up to down are the y axis in Minecraft, rotating around it from up
-     * should lead to east (positive x) -> south -> west -> north.
-     */
-    @Test
-    public void testRotationAroundYUsingCustomAxis() {
-        Vector vector = BlockFace.EAST.getDirection();
-        Vector axis = BlockFace.UP.getDirection();
-        assertEquals(BlockFace.NORTH.getDirection(), vector.clone().rotateAroundAxis(axis, Math.PI * 0.5)); // Should rotate around x axis for 1/4 of a circle.
-        assertEquals(BlockFace.WEST.getDirection(), vector.clone().rotateAroundAxis(axis, Math.PI * 1.0)); // Should rotate around x axis for 2/4 of a circle.
-        assertEquals(BlockFace.SOUTH.getDirection(), vector.clone().rotateAroundAxis(axis, Math.PI * 1.5)); // Should rotate around x axis for 3/4 of a circle.
-        assertEquals(BlockFace.EAST.getDirection(), vector.clone().rotateAroundAxis(axis, Math.PI * 2.0)); // Should rotate around x axis for 4/4 of a circle.
-    }
-
-    /**
-     * As south to north are the z axis in Minecraft, rotating around it from up
-     * should lead to up (positive y) -> west -> down -> east.
-     */
-    @Test
-    public void testRotationAroundZ() {
-        Vector vector = BlockFace.UP.getDirection();
-        assertEquals(BlockFace.WEST.getDirection(), vector.clone().rotateAroundZ(Math.PI * 0.5)); // Should rotate around x axis for 1/4 of a circle.
-        assertEquals(BlockFace.DOWN.getDirection(), vector.clone().rotateAroundZ(Math.PI * 1.0)); // Should rotate around x axis for 2/4 of a circle.
-        assertEquals(BlockFace.EAST.getDirection(), vector.clone().rotateAroundZ(Math.PI * 1.5)); // Should rotate around x axis for 3/4 of a circle.
-        assertEquals(BlockFace.UP.getDirection(), vector.clone().rotateAroundZ(Math.PI * 2.0)); // Should rotate around x axis for 4/4 of a circle.
-    }
-
-    @Test
-    public void testRotationAroundAxis() {
-        Vector axis = new Vector(1, 0, 1);
-        assertEquals(new Vector(0, 1, 0).rotateAroundNonUnitAxis(axis, Math.PI * 0.5), new Vector(-1, 0, 1));
-    }
-
-    @Test
-    public void testRotationAroundAxisNonUnit() {
-        Vector axis = new Vector(0, 2, 0);
-        Vector v = BlockFace.EAST.getDirection();
-
-        assertEquals(v.rotateAroundNonUnitAxis(axis, Math.PI * 0.5), BlockFace.NORTH.getDirection().multiply(2));
-    }
-
-    /**
-     * This will be a bit tricky to prove so we will try to simply see if the
-     * vectors have correct angle to each other This will work with any two
-     * vectors, as the rotation will keep the angle the same.
-     */
-    @Test
-    public void testRotationAroundCustomAngle() {
-        Vector axis = new Vector(-30, 1, 2000).normalize();
-        Vector v = new Vector(53, 12, 98);
-
-        float a = v.angle(axis);
-        double stepSize = Math.PI / 21;
-        for (int i = 0; i < 42; i++) {
-            v.rotateAroundAxis(axis, stepSize);
-            assertEquals(a, v.angle(axis), Vector.getEpsilon());
-        }
-    }
-
-    @Test
-    public void testSmallAngle() {
-        Vector a = new Vector(-0.13154885489775203, 0.0, 0.12210868381700482);
-        Vector b = new Vector(-0.7329152226448059, -0.0, 0.6803199648857117);
-
-        assertTrue(Double.isFinite(a.angle(b)));
-    }
-}
diff --git a/src/test/java/org/bukkit/util/io/BukkitObjectStreamTest.java b/src/test/java/org/bukkit/util/io/BukkitObjectStreamTest.java
deleted file mode 100644
index d3edb72ff83d68b86390b0e9f7e40035482f353a..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/util/io/BukkitObjectStreamTest.java
+++ /dev/null
@@ -1,170 +0,0 @@
-package org.bukkit.util.io;
-
-import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-import com.google.common.collect.ImmutableList;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.util.List;
-import org.bukkit.Color;
-import org.bukkit.FireworkEffect;
-import org.bukkit.FireworkEffect.Type;
-import org.bukkit.configuration.serialization.ConfigurationSerializable;
-import org.bukkit.util.Vector;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameter;
-import org.junit.runners.Parameterized.Parameters;
-import org.yaml.snakeyaml.external.biz.base64Coder.Base64Coder;
-
-@RunWith(Parameterized.class)
-public class BukkitObjectStreamTest {
-
-    @Parameters(name = "{index}: {0}")
-    public static List<Object[]> data() {
-        return ImmutableList.<Object[]>of(
-            new Object[] {
-                Color.class.getName(),
-                "rO0ABXNyADZjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0LkltbXV0YWJsZUxpc3QkU2VyaWFsaXplZEZvcm0AAAAAAAAAAAIAAVsACGVsZW1lbnRzdAATW0xqYXZhL2xhbmcvT2JqZWN0O3hwdXIAE1tMamF2YS5sYW5nLk9iamVjdDuQzlifEHMpbAIAAHhwAAAABXNyABpvcmcuYnVra2l0LnV0aWwuaW8uV3JhcHBlcvJQR+zxEm8FAgABTAADbWFwdAAPTGphdmEvdXRpbC9NYXA7eHBzcgA1Y29tLmdvb2dsZS5jb21tb24uY29sbGVjdC5JbW11dGFibGVNYXAkU2VyaWFsaXplZEZvcm0AAAAAAAAAAAIAAlsABGtleXNxAH4AAVsABnZhbHVlc3EAfgABeHB1cQB+AAMAAAAEdAACPT10AANSRUR0AARCTFVFdAAFR1JFRU51cQB+AAMAAAAEdAAFQ29sb3JzcgARamF2YS5sYW5nLkludGVnZXIS4qCk94GHOAIAAUkABXZhbHVleHIAEGphdmEubGFuZy5OdW1iZXKGrJUdC5TgiwIAAHhwAAAA/3NxAH4AEQAAAP9zcQB+ABEAAAD/c3EAfgAFc3EAfgAIdXEAfgADAAAABHEAfgALcQB+AAxxAH4ADXEAfgAOdXEAfgADAAAABHEAfgAQc3EAfgARAAAAAHNxAH4AEQAAAIBzcQB+ABEAAACAc3EAfgAFc3EAfgAIdXEAfgADAAAABHEAfgALcQB+AAxxAH4ADXEAfgAOdXEAfgADAAAABHEAfgAQc3EAfgARAAAAgHNxAH4AEQAAAIBxAH4AGnNxAH4ABXNxAH4ACHVxAH4AAwAAAARxAH4AC3EAfgAMcQB+AA1xAH4ADnVxAH4AAwAAAARxAH4AEHNxAH4AEQAAAP9xAH4AGnEAfgAac3EAfgAFc3EAfgAIdXEAfgADAAAABHEAfgALcQB+AAxxAH4ADXEAfgAOdXEAfgADAAAABHEAfgAQc3EAfgARAAAA/3EAfgAac3EAfgARAAAApQ==",
-                ImmutableList.of(
-                    Color.WHITE,
-                    Color.TEAL,
-                    Color.PURPLE,
-                    Color.RED,
-                    Color.ORANGE
-                    )
-            },
-            new Object[] {
-                FireworkEffect.class.getName(),
-                "rO0ABXNyADZjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0LkltbXV0YWJsZUxpc3QkU2VyaWFsaXplZEZvcm0AAAAAAAAAAAIAAVsACGVsZW1lbnRzdAATW0xqYXZhL2xhbmcvT2JqZWN0O3hwdXIAE1tMamF2YS5sYW5nLk9iamVjdDuQzlifEHMpbAIAAHhwAAAAA3NyABpvcmcuYnVra2l0LnV0aWwuaW8uV3JhcHBlcvJQR+zxEm8FAgABTAADbWFwdAAPTGphdmEvdXRpbC9NYXA7eHBzcgA1Y29tLmdvb2dsZS5jb21tb24uY29sbGVjdC5JbW11dGFibGVNYXAkU2VyaWFsaXplZEZvcm0AAAAAAAAAAAIAAlsABGtleXNxAH4AAVsABnZhbHVlc3EAfgABeHB1cQB+AAMAAAAGdAACPT10AAdmbGlja2VydAAFdHJhaWx0AAZjb2xvcnN0AAtmYWRlLWNvbG9yc3QABHR5cGV1cQB+AAMAAAAGdAAIRmlyZXdvcmtzcgARamF2YS5sYW5nLkJvb2xlYW7NIHKA1Zz67gIAAVoABXZhbHVleHABc3EAfgATAHNxAH4AAHVxAH4AAwAAAAJzcQB+AAVzcQB+AAh1cQB+AAMAAAAEcQB+AAt0AANSRUR0AARCTFVFdAAFR1JFRU51cQB+AAMAAAAEdAAFQ29sb3JzcgARamF2YS5sYW5nLkludGVnZXIS4qCk94GHOAIAAUkABXZhbHVleHIAEGphdmEubGFuZy5OdW1iZXKGrJUdC5TgiwIAAHhwAAAAAHEAfgAicQB+ACJzcQB+AAVzcQB+AAh1cQB+AAMAAAAEcQB+AAtxAH4AG3EAfgAccQB+AB11cQB+AAMAAAAEcQB+AB9zcQB+ACAAAADAc3EAfgAgAAAAwHNxAH4AIAAAAMBzcQB+AAB1cQB+AAMAAAABc3EAfgAFc3EAfgAIdXEAfgADAAAABHEAfgALcQB+ABtxAH4AHHEAfgAddXEAfgADAAAABHEAfgAfc3EAfgAgAAAA/3NxAH4AIAAAAP9zcQB+ACAAAAD/dAAKQkFMTF9MQVJHRXNxAH4ABXNxAH4ACHVxAH4AAwAAAAZxAH4AC3EAfgAMcQB+AA1xAH4ADnEAfgAPcQB+ABB1cQB+AAMAAAAGcQB+ABJxAH4AFXEAfgAVc3EAfgAAdXEAfgADAAAAAXNxAH4ABXNxAH4ACHVxAH4AAwAAAARxAH4AC3EAfgAbcQB+ABxxAH4AHXVxAH4AAwAAAARxAH4AH3EAfgAic3EAfgAgAAAAgHEAfgAic3EAfgAAdXEAfgADAAAAAHQABEJBTExzcQB+AAVzcQB+AAh1cQB+AAMAAAAGcQB+AAtxAH4ADHEAfgANcQB+AA5xAH4AD3EAfgAQdXEAfgADAAAABnEAfgAScQB+ABRxAH4AFHNxAH4AAHVxAH4AAwAAAAFzcQB+AAVzcQB+AAh1cQB+AAMAAAAEcQB+AAtxAH4AG3EAfgAccQB+AB11cQB+AAMAAAAEcQB+AB9zcQB+ACAAAACAcQB+ACJxAH4AInEAfgA/dAAHQ1JFRVBFUg==",
-                ImmutableList.of(
-                    FireworkEffect.builder()
-                        .withColor(Color.BLACK, Color.SILVER)
-                        .with(Type.BALL_LARGE)
-                        .withFade(Color.WHITE)
-                        .withFlicker()
-                        .build(),
-                    FireworkEffect.builder()
-                        .withColor(Color.NAVY)
-                        .build(),
-                    FireworkEffect.builder()
-                        .withColor(Color.MAROON)
-                        .withTrail()
-                        .withFlicker()
-                        .with(Type.CREEPER)
-                        .build()
-                    ),
-            },
-            new Object[] {
-                Vector.class.getName(),
-                "rO0ABXNyADZjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0LkltbXV0YWJsZUxpc3QkU2VyaWFsaXplZEZvcm0AAAAAAAAAAAIAAVsACGVsZW1lbnRzdAATW0xqYXZhL2xhbmcvT2JqZWN0O3hwdXIAE1tMamF2YS5sYW5nLk9iamVjdDuQzlifEHMpbAIAAHhwAAAABHNyABpvcmcuYnVra2l0LnV0aWwuaW8uV3JhcHBlcvJQR+zxEm8FAgABTAADbWFwdAAPTGphdmEvdXRpbC9NYXA7eHBzcgA1Y29tLmdvb2dsZS5jb21tb24uY29sbGVjdC5JbW11dGFibGVNYXAkU2VyaWFsaXplZEZvcm0AAAAAAAAAAAIAAlsABGtleXNxAH4AAVsABnZhbHVlc3EAfgABeHB1cQB+AAMAAAAEdAACPT10AAF4dAABeXQAAXp1cQB+AAMAAAAEdAAGVmVjdG9yc3IAEGphdmEubGFuZy5Eb3VibGWAs8JKKWv7BAIAAUQABXZhbHVleHIAEGphdmEubGFuZy5OdW1iZXKGrJUdC5TgiwIAAHhwAAAAAAAAAABzcQB+ABEAAAAAAAAAAHNxAH4AEQAAAAAAAAAAc3EAfgAFc3EAfgAIdXEAfgADAAAABHEAfgALcQB+AAxxAH4ADXEAfgAOdXEAfgADAAAABHEAfgAQc3EAfgARQIOFwo9cKPZzcQB+ABFAtCKcKPXCj3NxAH4AEUBzrpeNT987c3EAfgAFc3EAfgAIdXEAfgADAAAABHEAfgALcQB+AAxxAH4ADXEAfgAOdXEAfgADAAAABHEAfgAQc3EAfgARwEQTMzMzMzNzcQB+ABFASYAAAAAAAHNxAH4AEcCjqG3UQTVUc3EAfgAFc3EAfgAIdXEAfgADAAAABHEAfgALcQB+AAxxAH4ADXEAfgAOdXEAfgADAAAABHEAfgAQc3EAfgARQd/////AAABzcQB+ABHB4AAAAAAAAHNxAH4AEQAAAAAAAAAA",
-                ImmutableList.of(
-                    new Vector(0, 0, 0),
-                    new Vector(624.72, 5154.61, 314.912),
-                    new Vector(-40.15, 51, -2516.21451),
-                    new Vector(Integer.MAX_VALUE, Integer.MIN_VALUE, 0)
-                    )
-            });
-    }
-
-    @Parameter(0)
-    public String className;
-
-    @Parameter(1)
-    public String preEncoded;
-
-    @Parameter(2)
-    public List<ConfigurationSerializable> object;
-
-    @Test
-    public void checkSerlialization() throws Throwable {
-        // If this test fails, you may start your trek to debug by commenting the '@Ignore' on the next method
-        // (and of course, you would read those comments too)
-        final ByteArrayOutputStream out = new ByteArrayOutputStream();
-        ObjectOutputStream oos = null;
-        try {
-            oos = new BukkitObjectOutputStream(out);
-            oos.writeObject(object);
-        } finally {
-            if (oos != null) {
-                try {
-                    oos.close();
-                } catch (IOException e) {
-                }
-            }
-        }
-
-        final byte[] preEncodedArray = Base64Coder.decode(preEncoded);
-
-        final Object readBack;
-        final Object preEncoded;
-
-        ObjectInputStream ois = null;
-        ObjectInputStream preois = null;
-        try {
-            ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());
-            ByteArrayInputStream preIn = new ByteArrayInputStream(preEncodedArray);
-            ois = new BukkitObjectInputStream(in);
-            preois = new BukkitObjectInputStream(preIn);
-
-            readBack = ois.readObject();
-            preEncoded = preois.readObject();
-        } finally {
-            if (ois != null) {
-                try {
-                    ois.close();
-                } catch (IOException ex) {
-                }
-            }
-            if (preois != null) {
-                try {
-                    preois.close();
-                } catch (IOException ex) {
-                }
-            }
-        }
-
-        assertThat(object, is(readBack));
-        assertThat(object, is(preEncoded));
-    }
-
-    @Ignore
-    @Test
-    public void preEncoded() throws Throwable {
-        // This test is placed in the case that a necessary change is made to change the encoding format
-        // Just remove the ignore (or run manually) and it'll give you the new pre-encoded values
-
-        // It really does not matter if the encoded array is different per system (hence why this test is set to not run),
-        // as long as all systems can deserialize it.
-
-        // The entire reason the pre-encoded string was added is to make a build (test) fail if someone accidentally makes it not backward-compatible
-
-        final ByteArrayOutputStream out = new ByteArrayOutputStream();
-        ObjectOutputStream oos = null;
-        try {
-            oos = new BukkitObjectOutputStream(out);
-            oos.writeObject(object);
-            oos.flush();
-        } finally {
-            if (oos != null) {
-                try {
-                    oos.close();
-                } catch (IOException e) {
-                }
-            }
-        }
-
-        final String string = new String(Base64Coder.encode(out.toByteArray()));
-        try {
-            assertThat(preEncoded, is(string));
-        } catch (Throwable t) {
-            System.out.println(className + ": \"" + string + "\"");
-            throw t;
-        }
-    }
-}
