From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: xVorttex <sigamatute@gmail.com>
Date: Tue, 24 Sep 2024 21:41:30 +0300
Subject: [PATCH] Purpur updates


diff --git a/src/main/java/net/minecraft/server/level/PlayerChunkMap.java b/src/main/java/net/minecraft/server/level/PlayerChunkMap.java
index d876c5037b4704a174606629c80ba1142c77a50c..112d2a13b1c4c24bf8aa5dd5813f41bea91a278f 100644
--- a/src/main/java/net/minecraft/server/level/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/PlayerChunkMap.java
@@ -1,53 +1,20 @@
 package net.minecraft.server.level;
 
-import co.aikar.timings.Timing; // Paper
-import com.destroystokyo.paper.PaperWorldConfig; // Paper
+import co.aikar.timings.Timing;
+import com.destroystokyo.paper.PaperWorldConfig;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.ComparisonChain; // Paper
 import com.google.common.collect.Lists;
-import com.google.common.collect.Queues;
-import com.google.common.collect.Sets;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Either;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2ByteMap;
-import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap; // Paper
-import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
+import it.unimi.dsi.fastutil.longs.*;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
-import it.unimi.dsi.fastutil.longs.LongIterator;
-import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
-import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator;
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
-import java.io.File;
-import java.io.IOException;
-import java.io.Writer;
-import java.util.HashMap; // Paper
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map; // Paper
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Queue;
-import java.util.Set;
-import java.util.concurrent.CancellationException;
-import java.util.UUID; // Paper
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.CompletionException;
-import java.util.concurrent.Executor;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.BooleanSupplier;
-import java.util.function.Consumer;
-import java.util.function.IntFunction;
-import java.util.function.IntSupplier;
-import java.util.function.Supplier;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
-import javax.annotation.Nullable;
+import it.unimi.dsi.fastutil.objects.ObjectRBTreeSet;
+import it.unimi.dsi.fastutil.objects.Reference2BooleanOpenHashMap;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportSystemDetails;
 import net.minecraft.ReportedException;
@@ -56,19 +23,11 @@ import net.minecraft.core.BlockPosition;
 import net.minecraft.core.SectionPosition;
 import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.network.protocol.Packet;
-import net.minecraft.network.protocol.game.PacketDebug;
-import net.minecraft.network.protocol.game.PacketPlayOutAttachEntity;
-import net.minecraft.network.protocol.game.PacketPlayOutLightUpdate;
-import net.minecraft.network.protocol.game.PacketPlayOutMapChunk;
-import net.minecraft.network.protocol.game.PacketPlayOutMount;
-import net.minecraft.network.protocol.game.PacketPlayOutViewCentre;
-import net.minecraft.network.protocol.game.PacketPlayOutViewDistance;
+import net.minecraft.network.protocol.game.*;
 import net.minecraft.server.MCUtil;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.progress.WorldLoadListener;
-import net.minecraft.server.network.PlayerConnection;
 import net.minecraft.util.CSVWriter;
-import net.minecraft.util.EntitySlice;
 import net.minecraft.util.MathHelper;
 import net.minecraft.util.profiling.GameProfilerFiller;
 import net.minecraft.util.thread.IAsyncTaskHandler;
@@ -84,15 +43,7 @@ import net.minecraft.world.entity.player.EntityHuman;
 import net.minecraft.world.level.ChunkCoordIntPair;
 import net.minecraft.world.level.GameRules;
 import net.minecraft.world.level.World;
-import net.minecraft.world.level.chunk.Chunk;
-import net.minecraft.world.level.chunk.ChunkConverter;
-import net.minecraft.world.level.chunk.ChunkGenerator;
-import net.minecraft.world.level.chunk.ChunkSection;
-import net.minecraft.world.level.chunk.ChunkStatus;
-import net.minecraft.world.level.chunk.IChunkAccess;
-import net.minecraft.world.level.chunk.ILightAccess;
-import net.minecraft.world.level.chunk.ProtoChunk;
-import net.minecraft.world.level.chunk.ProtoChunkExtension;
+import net.minecraft.world.level.chunk.*;
 import net.minecraft.world.level.chunk.storage.ChunkRegionLoader;
 import net.minecraft.world.level.chunk.storage.IChunkLoader;
 import net.minecraft.world.level.chunk.storage.RegionFile;
@@ -101,16 +52,26 @@ import net.minecraft.world.level.levelgen.structure.templatesystem.DefinedStruct
 import net.minecraft.world.level.storage.Convertable;
 import net.minecraft.world.level.storage.WorldDataServer;
 import net.minecraft.world.level.storage.WorldPersistentData;
-import net.minecraft.world.phys.Vec3D;
-import it.unimi.dsi.fastutil.objects.ObjectRBTreeSet; // Paper
-import it.unimi.dsi.fastutil.objects.Reference2BooleanOpenHashMap; // Tuinity
 import org.apache.commons.lang3.mutable.MutableBoolean;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
-
-import org.bukkit.entity.Player; // CraftBukkit
+import org.bukkit.entity.Player;
 import org.spigotmc.AsyncCatcher;
 
+import javax.annotation.Nullable;
+import java.io.File;
+import java.io.IOException;
+import java.io.Writer;
+import java.util.*;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.*;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
 public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     private static final Logger LOGGER = LogManager.getLogger();
@@ -140,6 +101,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             return super.get(k);
         }
     }
+
     // Paper end
     // Tuinity - Don't copy
     private final Long2ObjectLinkedOpenHashMap<PlayerChunk> pendingUnload;
@@ -149,7 +111,12 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     private final IAsyncTaskHandler<Runnable> executor;
     final java.util.concurrent.Executor mainInvokingExecutor; // Paper
     public final ChunkGenerator chunkGenerator;
-    private final Supplier<WorldPersistentData> l; public final Supplier<WorldPersistentData> getWorldPersistentDataSupplier() { return this.l; } // Paper - OBFHELPER
+    private final Supplier<WorldPersistentData> l;
+
+    public final Supplier<WorldPersistentData> getWorldPersistentDataSupplier() {
+        return this.l;
+    } // Paper - OBFHELPER
+
     private final VillagePlace m;
     public final LongSet unloadQueue;
     private boolean updatingChunksModified;
@@ -158,24 +125,37 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     public final Mailbox<ChunkTaskQueueSorter.a<Runnable>> mailboxMain; // Paper - private -> public
     // Paper start
     final Mailbox<ChunkTaskQueueSorter.a<Runnable>> mailboxLight;
+
     public void addLightTask(PlayerChunk playerchunk, Runnable run) {
         this.mailboxLight.a(ChunkTaskQueueSorter.a(playerchunk, run));
     }
+
     // Paper end
     public final WorldLoadListener worldLoadListener;
-    public final PlayerChunkMap.a chunkDistanceManager; public final ChunkMapDistance getChunkDistanceManager() { return this.chunkDistanceManager; } // Paper - OBFHELPER
+    public final PlayerChunkMap.a chunkDistanceManager;
+
+    public final ChunkMapDistance getChunkDistanceManager() {
+        return this.chunkDistanceManager;
+    } // Paper - OBFHELPER
+
     private final AtomicInteger u;
     public final DefinedStructureManager definedStructureManager; // Paper - private -> public
     private final File w;
     private final PlayerMap playerMap;
     public final Int2ObjectMap<PlayerChunkMap.EntityTracker> trackedEntities;
     private final Long2ByteMap z;
-    private final Queue<Runnable> A; private final Queue<Runnable> getUnloadQueueTasks() { return this.A; } // Paper - OBFHELPER
+    private final Queue<Runnable> A;
+
+    private final Queue<Runnable> getUnloadQueueTasks() {
+        return this.A;
+    } // Paper - OBFHELPER
+
     int viewDistance; // Paper - private -> package private
     public final com.destroystokyo.paper.util.PlayerMobDistanceMap playerMobDistanceMap; // Paper
 
     // CraftBukkit start - recursion-safe executor for Chunk loadCallback() and unloadCallback()
     public final CallbackExecutor callbackExecutor = new CallbackExecutor();
+
     public static final class CallbackExecutor implements java.util.concurrent.Executor, Runnable {
         // Tuinity start - revert paper's change
         private Runnable queued;
@@ -203,13 +183,16 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             }
         }
         // Paper end
-    };
+    }
+
+    ;
     // CraftBukkit end
 
     final CallbackExecutor chunkLoadConversionCallbackExecutor = new CallbackExecutor(); // Paper
 
     // Paper start - distance maps
     private final com.destroystokyo.paper.util.misc.PooledLinkedHashSets<EntityPlayer> pooledLinkedPlayerHashSets = new com.destroystokyo.paper.util.misc.PooledLinkedHashSets<>();
+
     // Paper start - use distance map to optimise tracker
     public static boolean isLegacyTrackingEntity(Entity entity) {
         return entity.isLegacyTrackingEntity;
@@ -218,7 +201,11 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     // inlined EnumMap, TrackingRange.TrackingRangeType
     static final org.spigotmc.TrackingRange.TrackingRangeType[] TRACKING_RANGE_TYPES = org.spigotmc.TrackingRange.TrackingRangeType.values();
     public final com.destroystokyo.paper.util.misc.PlayerAreaMap[] playerEntityTrackerTrackMaps;
-    final int[] entityTrackerTrackRanges; public int getEntityTrackerRange(final int ordinal) { return this.entityTrackerTrackRanges[ordinal]; } // Tuinity - public read
+    final int[] entityTrackerTrackRanges;
+
+    public int getEntityTrackerRange(final int ordinal) {
+        return this.entityTrackerTrackRanges[ordinal];
+    } // Tuinity - public read
 
     private int convertSpigotRangeToVanilla(final int vanilla) {
         return MinecraftServer.getServer().applyTrackingRangeScale(vanilla);
@@ -358,7 +345,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             }
             final boolean ret = this.navigators.add(navigator);
             if (ret) {
-                final DataRegionData data = (DataRegionData)section.getRegion().regionData;
+                final DataRegionData data = (DataRegionData) section.getRegion().regionData;
                 if (!data.addToNavigators(navigator)) {
                     throw new IllegalStateException();
                 }
@@ -372,7 +359,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             }
             final boolean ret = this.navigators.remove(navigator);
             if (ret) {
-                final DataRegionData data = (DataRegionData)section.getRegion().regionData;
+                final DataRegionData data = (DataRegionData) section.getRegion().regionData;
                 if (!data.removeFromNavigators(navigator)) {
                     throw new IllegalStateException();
                 }
@@ -384,11 +371,11 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         @Override
         public void removeFromRegion(final com.tuinity.tuinity.chunk.SingleThreadChunkRegionManager.RegionSection section,
                                      final com.tuinity.tuinity.chunk.SingleThreadChunkRegionManager.Region from) {
-            final DataRegionSectionData sectionData = (DataRegionSectionData)section.sectionData;
-            final DataRegionData fromData = (DataRegionData)from.regionData;
+            final DataRegionSectionData sectionData = (DataRegionSectionData) section.sectionData;
+            final DataRegionData fromData = (DataRegionData) from.regionData;
             // Tuinity start - optimise notify()
             if (sectionData.navigators != null) {
-                for (final Iterator<EntityInsentient> iterator = sectionData.navigators.unsafeIterator(com.tuinity.tuinity.util.maplist.IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS); iterator.hasNext();) {
+                for (final Iterator<EntityInsentient> iterator = sectionData.navigators.unsafeIterator(com.tuinity.tuinity.util.maplist.IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS); iterator.hasNext(); ) {
                     if (!fromData.removeFromNavigators(iterator.next())) {
                         throw new IllegalStateException();
                     }
@@ -401,12 +388,12 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         public void addToRegion(final com.tuinity.tuinity.chunk.SingleThreadChunkRegionManager.RegionSection section,
                                 final com.tuinity.tuinity.chunk.SingleThreadChunkRegionManager.Region oldRegion,
                                 final com.tuinity.tuinity.chunk.SingleThreadChunkRegionManager.Region newRegion) {
-            final DataRegionSectionData sectionData = (DataRegionSectionData)section.sectionData;
-            final DataRegionData oldRegionData = oldRegion == null ? null : (DataRegionData)oldRegion.regionData;
-            final DataRegionData newRegionData = (DataRegionData)newRegion.regionData;
+            final DataRegionSectionData sectionData = (DataRegionSectionData) section.sectionData;
+            final DataRegionData oldRegionData = oldRegion == null ? null : (DataRegionData) oldRegion.regionData;
+            final DataRegionData newRegionData = (DataRegionData) newRegion.regionData;
             // Tuinity start - optimise notify()
             if (sectionData.navigators != null) {
-                for (final Iterator<EntityInsentient> iterator = sectionData.navigators.unsafeIterator(com.tuinity.tuinity.util.maplist.IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS); iterator.hasNext();) {
+                for (final Iterator<EntityInsentient> iterator = sectionData.navigators.unsafeIterator(com.tuinity.tuinity.util.maplist.IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS); iterator.hasNext(); ) {
                     if (!newRegionData.addToNavigators(iterator.next())) {
                         throw new IllegalStateException();
                     }
@@ -418,6 +405,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     // Tuiniy end
 
     private final java.util.concurrent.ExecutorService lightThread;
+
     public PlayerChunkMap(WorldServer worldserver, Convertable.ConversionSession convertable_conversionsession, DataFixer datafixer, DefinedStructureManager definedstructuremanager, Executor executor, IAsyncTaskHandler<Runnable> iasynctaskhandler, ILightAccess ilightaccess, ChunkGenerator chunkgenerator, WorldLoadListener worldloadlistener, Supplier<WorldPersistentData> supplier, int i, boolean flag) {
         super(new File(convertable_conversionsession.a(worldserver.getDimensionKey()), "region"), datafixer, flag);
         //this.visibleChunks = this.updatingChunks.clone(); // Paper - no more cloning
@@ -450,12 +438,13 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
         this.worldLoadListener = worldloadlistener;
         // Paper start - use light thread
-        String threadName = ((WorldDataServer)this.world.getWorldData()).getName() + " - Light"; // Tuinity - make sure playerchunkmap instance is not retained by the thread factory
-        ThreadedMailbox<Runnable> lightthreaded; ThreadedMailbox<Runnable> threadedmailbox1 = lightthreaded = ThreadedMailbox.a(lightThread = java.util.concurrent.Executors.newSingleThreadExecutor(r -> {
+        String threadName = ((WorldDataServer) this.world.getWorldData()).getName() + " - Light"; // Tuinity - make sure playerchunkmap instance is not retained by the thread factory
+        ThreadedMailbox<Runnable> lightthreaded;
+        ThreadedMailbox<Runnable> threadedmailbox1 = lightthreaded = ThreadedMailbox.a(lightThread = java.util.concurrent.Executors.newSingleThreadExecutor(r -> {
             Thread thread = new Thread(r);
             thread.setName(threadName); // Tuinity - make sure playerchunkmap instance is not retained by the thread factory
             thread.setDaemon(true);
-            thread.setPriority(Thread.NORM_PRIORITY+1);
+            thread.setPriority(Thread.NORM_PRIORITY + 1);
             return thread;
         }), "light");
         // Paper end
@@ -465,7 +454,8 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         this.mailboxMain = this.p.a(mailbox, false);
         this.mailboxLight = this.p.a(lightthreaded, false);// Paper
         this.lightEngine = new LightEngineThreaded(ilightaccess, this, this.world.getDimensionManager().hasSkyLight(), threadedmailbox1, this.p.a(threadedmailbox1, false));
-        this.chunkDistanceManager = new PlayerChunkMap.a(executor, iasynctaskhandler); this.chunkDistanceManager.chunkMap = this; // Paper
+        this.chunkDistanceManager = new PlayerChunkMap.a(executor, iasynctaskhandler);
+        this.chunkDistanceManager.chunkMap = this; // Paper
         this.l = supplier;
         this.m = new VillagePlace(new File(this.w, "poi"), datafixer, flag, this.world); // Paper
         this.setViewDistance(i);
@@ -511,35 +501,35 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         // Paper end - use distance map to optimise entity tracker
         // Paper start - optimise PlayerChunkMap#isOutsideRange
         this.playerChunkTickRangeMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets,
-            (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
-             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
-                PlayerChunk playerChunk = PlayerChunkMap.this.getUpdatingChunk(MCUtil.getCoordinateKey(rangeX, rangeZ));
-                if (playerChunk != null) {
-                    playerChunk.playersInChunkTickRange = newState;
-                }
-            },
-            (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
-             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
-                PlayerChunk playerChunk = PlayerChunkMap.this.getUpdatingChunk(MCUtil.getCoordinateKey(rangeX, rangeZ));
-                if (playerChunk != null) {
-                    playerChunk.playersInChunkTickRange = newState;
-                }
-            });
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    PlayerChunk playerChunk = PlayerChunkMap.this.getUpdatingChunk(MCUtil.getCoordinateKey(rangeX, rangeZ));
+                    if (playerChunk != null) {
+                        playerChunk.playersInChunkTickRange = newState;
+                    }
+                },
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    PlayerChunk playerChunk = PlayerChunkMap.this.getUpdatingChunk(MCUtil.getCoordinateKey(rangeX, rangeZ));
+                    if (playerChunk != null) {
+                        playerChunk.playersInChunkTickRange = newState;
+                    }
+                });
         this.playerMobSpawnMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets,
-            (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
-             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
-                PlayerChunk playerChunk = PlayerChunkMap.this.getUpdatingChunk(MCUtil.getCoordinateKey(rangeX, rangeZ));
-                if (playerChunk != null) {
-                    playerChunk.playersInMobSpawnRange = newState;
-                }
-            },
-            (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
-             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
-                PlayerChunk playerChunk = PlayerChunkMap.this.getUpdatingChunk(MCUtil.getCoordinateKey(rangeX, rangeZ));
-                if (playerChunk != null) {
-                    playerChunk.playersInMobSpawnRange = newState;
-                }
-            });
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    PlayerChunk playerChunk = PlayerChunkMap.this.getUpdatingChunk(MCUtil.getCoordinateKey(rangeX, rangeZ));
+                    if (playerChunk != null) {
+                        playerChunk.playersInMobSpawnRange = newState;
+                    }
+                },
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    PlayerChunk playerChunk = PlayerChunkMap.this.getUpdatingChunk(MCUtil.getCoordinateKey(rangeX, rangeZ));
+                    if (playerChunk != null) {
+                        playerChunk.playersInMobSpawnRange = newState;
+                    }
+                });
         // Paper end - optimise PlayerChunkMap#isOutsideRange
         // Paper start - no-tick view distance
         this.setNoTickViewDistance(this.world.paperConfig.noTickViewDistance);
@@ -551,22 +541,23 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         // Tuinity end
         // Tuinity start - optimise checkDespawn
         this.playerGeneralAreaMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets,
-            (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
-             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
-                Chunk chunk = PlayerChunkMap.this.world.getChunkProvider().getChunkAtIfCachedImmediately(rangeX, rangeZ);
-                if (chunk != null) {
-                    chunk.updateGeneralAreaCache(newState);
-                }
-            },
-            (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
-             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
-                Chunk chunk = PlayerChunkMap.this.world.getChunkProvider().getChunkAtIfCachedImmediately(rangeX, rangeZ);
-                if (chunk != null) {
-                    chunk.updateGeneralAreaCache(newState);
-                }
-            });
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    Chunk chunk = PlayerChunkMap.this.world.getChunkProvider().getChunkAtIfCachedImmediately(rangeX, rangeZ);
+                    if (chunk != null) {
+                        chunk.updateGeneralAreaCache(newState);
+                    }
+                },
+                (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                    Chunk chunk = PlayerChunkMap.this.world.getChunkProvider().getChunkAtIfCachedImmediately(rangeX, rangeZ);
+                    if (chunk != null) {
+                        chunk.updateGeneralAreaCache(newState);
+                    }
+                });
         // Tuinity end - optimise checkDespawn
     }
+
     // Paper start - Chunk Prioritization
     public void queueHolderUpdate(PlayerChunk playerchunk) {
         Runnable runnable = () -> {
@@ -682,8 +673,8 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         if (!this.world.paperConfig.perPlayerMobSpawns) {
             return;
         }
-        int chunkX = (int)Math.floor(entity.locX()) >> 4;
-        int chunkZ = (int)Math.floor(entity.locZ()) >> 4;
+        int chunkX = (int) Math.floor(entity.locX()) >> 4;
+        int chunkZ = (int) Math.floor(entity.locZ()) >> 4;
         int index = entity.getEntityType().getEnumCreatureType().ordinal();
 
         for (EntityPlayer player : this.playerMobDistanceMap.getPlayersInRange(chunkX, chunkZ)) {
@@ -695,7 +686,10 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         return entityPlayer.mobCounts[enumCreatureType.ordinal()];
     }
 
-    private static double getDistanceSquaredFromChunk(ChunkCoordIntPair chunkPos, Entity entity) { return a(chunkPos, entity); } // Paper - OBFHELPER
+    private static double getDistanceSquaredFromChunk(ChunkCoordIntPair chunkPos, Entity entity) {
+        return a(chunkPos, entity);
+    } // Paper - OBFHELPER
+
     private static double a(ChunkCoordIntPair chunkcoordintpair, Entity entity) {
         double d0 = (double) (chunkcoordintpair.x * 16 + 8);
         double d1 = (double) (chunkcoordintpair.z * 16 + 8);
@@ -742,9 +736,11 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     private static final boolean DEBUG_ASYNC_VISIBLE_CHUNKS = Boolean.getBoolean("paper.debug-async-visible-chunks");
     private boolean isIterating = false;
     private boolean hasPendingVisibleUpdate = false;
+
     public void forEachVisibleChunk(java.util.function.Consumer<PlayerChunk> consumer) {
         throw new UnsupportedOperationException(); // Tuinity - Don't copy
     }
+
     public Long2ObjectLinkedOpenHashMap<PlayerChunk> getVisibleChunks() {
         // Tuinity start - Don't copy (except in rare cases)
         synchronized (this.updatingChunks) {
@@ -764,7 +760,10 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         // Tuinity end - Don't copy
     }
 
-    protected final IntSupplier getPrioritySupplier(long i) { return c(i); } // Paper - OBFHELPER
+    protected final IntSupplier getPrioritySupplier(long i) {
+        return c(i);
+    } // Paper - OBFHELPER
+
     protected IntSupplier c(long i) {
         return () -> {
             PlayerChunk playerchunk = this.getVisibleChunk(i);
@@ -858,7 +857,10 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     @Nullable
     private PlayerChunk a(long i, int j, @Nullable PlayerChunk playerchunk, int k) {
         com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Chunk holder update"); // Tuinity
-        if (this.unloadingPlayerChunk) { MinecraftServer.LOGGER.fatal("Cannot tick distance manager while unloading playerchunks", new Throwable()); throw new IllegalStateException("Cannot tick distance manager while unloading playerchunks"); } // Tuinity
+        if (this.unloadingPlayerChunk) {
+            MinecraftServer.LOGGER.fatal("Cannot tick distance manager while unloading playerchunks", new Throwable());
+            throw new IllegalStateException("Cannot tick distance manager while unloading playerchunks");
+        } // Tuinity
         if (k > PlayerChunkMap.GOLDEN_TICKET && j > PlayerChunkMap.GOLDEN_TICKET) {
             return playerchunk;
         } else {
@@ -912,7 +914,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     // Paper start - incremental autosave
     final ObjectRBTreeSet<PlayerChunk> autoSaveQueue = new ObjectRBTreeSet<>((playerchunk1, playerchunk2) -> {
-        int timeCompare =  Long.compare(playerchunk1.lastAutoSaveTime, playerchunk2.lastAutoSaveTime);
+        int timeCompare = Long.compare(playerchunk1.lastAutoSaveTime, playerchunk2.lastAutoSaveTime);
         if (timeCompare != 0) {
             return timeCompare;
         }
@@ -927,7 +929,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         long currentTick = this.world.getTime();
         long maxSaveTime = currentTick - this.world.paperConfig.autoSavePeriod;
 
-        for (Iterator<PlayerChunk> iterator = this.autoSaveQueue.iterator(); iterator.hasNext();) {
+        for (Iterator<PlayerChunk> iterator = this.autoSaveQueue.iterator(); iterator.hasNext(); ) {
             PlayerChunk playerchunk = iterator.next();
             if (playerchunk.lastAutoSaveTime > maxSaveTime) {
                 break;
@@ -937,7 +939,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
             IChunkAccess ichunkaccess = playerchunk.getChunkSave().getNow(null);
             if (ichunkaccess instanceof Chunk) {
-                boolean shouldSave = ((Chunk)ichunkaccess).lastSaved <= maxSaveTime;
+                boolean shouldSave = ((Chunk) ichunkaccess).lastSaved <= maxSaveTime;
 
                 if (shouldSave && this.saveChunk(ichunkaccess)) {
                     ++savedThisTick;
@@ -1019,13 +1021,13 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         GameProfilerFiller gameprofilerfiller = this.world.getMethodProfiler();
 
         try (Timing ignored = this.world.timings.poiUnload.startTiming()) { // Paper
-        gameprofilerfiller.enter("poi");
-        this.m.a(booleansupplier);
+            gameprofilerfiller.enter("poi");
+            this.m.a(booleansupplier);
         } // Paper
         gameprofilerfiller.exitEnter("chunk_unload");
         if (!this.world.isSavingDisabled()) {
             try (Timing ignored = this.world.timings.chunkUnload.startTiming()) { // Paper
-            this.b(booleansupplier);
+                this.b(booleansupplier);
             }// Paper
         }
 
@@ -1037,7 +1039,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         // Spigot start
         org.spigotmc.SlackActivityAccountant activityAccountant = this.world.getMinecraftServer().slackActivityAccountant;
         activityAccountant.startActivity(0.5);
-        int targetSize = Math.min(this.unloadQueue.size() - 100,  (int) (this.unloadQueue.size() * UNLOAD_QUEUE_RESIZE_FACTOR)); // Paper - Make more aggressive
+        int targetSize = Math.min(this.unloadQueue.size() - 100, (int) (this.unloadQueue.size() * UNLOAD_QUEUE_RESIZE_FACTOR)); // Paper - Make more aggressive
         // Spigot end
         while (longiterator.hasNext()) { // Spigot
             long j = longiterator.nextLong();
@@ -1061,7 +1063,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         Runnable runnable;
 
         int queueTarget = Math.min(this.getUnloadQueueTasks().size() - 100, (int) (this.getUnloadQueueTasks().size() * UNLOAD_QUEUE_RESIZE_FACTOR)); // Paper - Target this queue as well
-        while ((booleansupplier.getAsBoolean() || this.getUnloadQueueTasks().size() > queueTarget) && (runnable = (Runnable)this.getUnloadQueueTasks().poll()) != null) { // Paper - Target this queue as well
+        while ((booleansupplier.getAsBoolean() || this.getUnloadQueueTasks().size() > queueTarget) && (runnable = (Runnable) this.getUnloadQueueTasks().poll()) != null) { // Paper - Target this queue as well
             runnable.run();
         }
 
@@ -1079,7 +1081,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         }
 
         com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(this.world, chunkPos.x, chunkPos.z,
-            poiData, null, com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY); // Tuinity - use normal priority
+                poiData, null, com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY); // Tuinity - use normal priority
 
         if (!chunk.isNeedsSaving()) {
             return;
@@ -1114,7 +1116,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         }
 
         this.world.asyncChunkTaskManager.scheduleChunkSave(chunkPos.x, chunkPos.z, com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY, // Tuinity - use normal priority
-            asyncSaveData, chunk);
+                asyncSaveData, chunk);
 
         chunk.setLastSaved(this.world.getTime());
         chunk.setNeedsSaving(false);
@@ -1136,47 +1138,49 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 boolean unloadingBefore = this.unloadingPlayerChunk;
                 this.unloadingPlayerChunk = true;
                 try {
-                // Tuinity end - do not allow ticket level changes while unloading chunks
-                // Tuinity start
-                boolean removed;
-                if ((removed = this.pendingUnload.remove(i, playerchunk)) && ichunkaccess != null) { // Tuinity end
+                    // Tuinity end - do not allow ticket level changes while unloading chunks
                     // Tuinity start
-                    for (int index = 0, len = this.regionManagers.size(); index < len; ++index) {
-                        this.regionManagers.get(index).removeChunk(playerchunk.location.x, playerchunk.location.z);
-                    }
-                    // Tuinity end
-                    this.getVillagePlace().queueUnload(playerchunk.location.pair(), MinecraftServer.currentTickLong + 1); // Tuinity - unload POI data
-                    if (ichunkaccess instanceof Chunk) {
-                        ((Chunk) ichunkaccess).setLoaded(false);
-                    }
+                    boolean removed;
+                    if ((removed = this.pendingUnload.remove(i, playerchunk)) && ichunkaccess != null) { // Tuinity end
+                        // Tuinity start
+                        for (int index = 0, len = this.regionManagers.size(); index < len; ++index) {
+                            this.regionManagers.get(index).removeChunk(playerchunk.location.x, playerchunk.location.z);
+                        }
+                        // Tuinity end
+                        this.getVillagePlace().queueUnload(playerchunk.location.pair(), MinecraftServer.currentTickLong + 1); // Tuinity - unload POI data
+                        if (ichunkaccess instanceof Chunk) {
+                            ((Chunk) ichunkaccess).setLoaded(false);
+                        }
 
-                    //this.saveChunk(ichunkaccess);// Paper - delay
-                    if (this.loadedChunks.remove(i) && ichunkaccess instanceof Chunk) {
-                        Chunk chunk = (Chunk) ichunkaccess;
+                        //this.saveChunk(ichunkaccess);// Paper - delay
+                        if (this.loadedChunks.remove(i) && ichunkaccess instanceof Chunk) {
+                            Chunk chunk = (Chunk) ichunkaccess;
 
-                        this.world.unloadChunk(chunk);
-                    }
-                    this.autoSaveQueue.remove(playerchunk); // Paper
+                            this.world.unloadChunk(chunk);
+                        }
+                        this.autoSaveQueue.remove(playerchunk); // Paper
 
-                    try {
-                        this.asyncSave(ichunkaccess); // Paper - async chunk saving
-                    } catch (Throwable ex) {
-                        LOGGER.fatal("Failed to prepare async save, attempting synchronous save", ex);
-                        this.saveChunk(ichunkaccess);
-                    }
+                        try {
+                            this.asyncSave(ichunkaccess); // Paper - async chunk saving
+                        } catch (Throwable ex) {
+                            LOGGER.fatal("Failed to prepare async save, attempting synchronous save", ex);
+                            this.saveChunk(ichunkaccess);
+                        }
 
-                    this.lightEngine.a(ichunkaccess.getPos());
-                    this.lightEngine.queueUpdate();
-                    this.worldLoadListener.a(ichunkaccess.getPos(), (ChunkStatus) null);
-                } else if (removed) { // Tuinity start
-                    // Tuinity start
-                    for (int index = 0, len = this.regionManagers.size(); index < len; ++index) {
-                        this.regionManagers.get(index).removeChunk(playerchunk.location.x, playerchunk.location.z);
-                    }
-                    // Tuinity end
-                    this.getVillagePlace().queueUnload(playerchunk.location.pair(), MinecraftServer.currentTickLong + 1); // Tuinity - unload POI data
-                } // Tuinity end
-                } finally { this.unloadingPlayerChunk = unloadingBefore; } // Tuinity - do not allow ticket level changes while unloading chunks
+                        this.lightEngine.a(ichunkaccess.getPos());
+                        this.lightEngine.queueUpdate();
+                        this.worldLoadListener.a(ichunkaccess.getPos(), (ChunkStatus) null);
+                    } else if (removed) { // Tuinity start
+                        // Tuinity start
+                        for (int index = 0, len = this.regionManagers.size(); index < len; ++index) {
+                            this.regionManagers.get(index).removeChunk(playerchunk.location.x, playerchunk.location.z);
+                        }
+                        // Tuinity end
+                        this.getVillagePlace().queueUnload(playerchunk.location.pair(), MinecraftServer.currentTickLong + 1); // Tuinity - unload POI data
+                    } // Tuinity end
+                } finally {
+                    this.unloadingPlayerChunk = unloadingBefore;
+                } // Tuinity - do not allow ticket level changes while unloading chunks
 
             }
         };
@@ -1263,18 +1267,20 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 this.getVillagePlace().dequeueUnload(chunkcoordintpair.pair()); // Tuinity
                 // Paper end
 
-                if (chunkHolder.protoChunk != null) {try (Timing ignored2 = this.world.timings.chunkLoadLevelTimer.startTimingIfSync()) { // Paper start - timings // Paper - chunk is created async
+                if (chunkHolder.protoChunk != null) {
+                    try (Timing ignored2 = this.world.timings.chunkLoadLevelTimer.startTimingIfSync()) { // Paper start - timings // Paper - chunk is created async
 
-                    if (true) {
-                        ProtoChunk protochunk = chunkHolder.protoChunk;
+                        if (true) {
+                            ProtoChunk protochunk = chunkHolder.protoChunk;
 
-                        protochunk.setLastSaved(this.world.getTime());
-                        this.a(chunkcoordintpair, protochunk.getChunkStatus().getType());
-                        return Either.left(protochunk);
-                    }
+                            protochunk.setLastSaved(this.world.getTime());
+                            this.a(chunkcoordintpair, protochunk.getChunkStatus().getType());
+                            return Either.left(protochunk);
+                        }
 
-                    PlayerChunkMap.LOGGER.error("Chunk file at {} is missing level data, skipping", chunkcoordintpair);
-                }} // Paper
+                        PlayerChunkMap.LOGGER.error("Chunk file at {} is missing level data, skipping", chunkcoordintpair);
+                    }
+                } // Paper
             } catch (ReportedException reportedexception) {
                 Throwable throwable = reportedexception.getCause();
 
@@ -1379,7 +1385,10 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         // Tuinity end - force competion on the main thread
     }
 
-    protected final void removeLightTicket(ChunkCoordIntPair chunkcoordintpair) { this.c(chunkcoordintpair); } // Tuinity - OBFHELPER
+    protected final void removeLightTicket(ChunkCoordIntPair chunkcoordintpair) {
+        this.c(chunkcoordintpair);
+    } // Tuinity - OBFHELPER
+
     protected void c(ChunkCoordIntPair chunkcoordintpair) {
         this.executor.a(SystemUtils.a(() -> {
             this.chunkDistanceManager.b(TicketType.LIGHT, chunkcoordintpair, 33 + ChunkStatus.a(ChunkStatus.FEATURES), chunkcoordintpair);
@@ -1407,68 +1416,68 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             ChunkStatus chunkstatus = PlayerChunk.getChunkStatus(playerchunk.getTicketLevel());
 
             return !chunkstatus.b(ChunkStatus.FULL) ? PlayerChunk.UNLOADED_CHUNK_ACCESS : either.mapLeft((ichunkaccess) -> {
-            try (Timing ignored = world.timings.chunkPostLoad.startTimingIfSync()) { // Paper
-                ChunkCoordIntPair chunkcoordintpair = playerchunk.i();
-                Chunk chunk;
+                try (Timing ignored = world.timings.chunkPostLoad.startTimingIfSync()) { // Paper
+                    ChunkCoordIntPair chunkcoordintpair = playerchunk.i();
+                    Chunk chunk;
 
-                if (ichunkaccess instanceof ProtoChunkExtension) {
-                    chunk = ((ProtoChunkExtension) ichunkaccess).u();
-                } else {
-                    chunk = new Chunk(this.world, (ProtoChunk) ichunkaccess);
-                    playerchunk.a(new ProtoChunkExtension(chunk));
-                }
-
-                chunk.setLastSaved(this.world.getTime() - 1); // Paper - avoid autosaving newly generated/loaded chunks
+                    if (ichunkaccess instanceof ProtoChunkExtension) {
+                        chunk = ((ProtoChunkExtension) ichunkaccess).u();
+                    } else {
+                        chunk = new Chunk(this.world, (ProtoChunk) ichunkaccess);
+                        playerchunk.a(new ProtoChunkExtension(chunk));
+                    }
 
-                chunk.a(() -> {
-                    return PlayerChunk.getChunkState(playerchunk.getTicketLevel());
-                });
-                chunk.addEntities();
-                if (this.loadedChunks.add(chunkcoordintpair.pair())) {
-                    chunk.setLoaded(true);
-                    this.world.a(chunk.getTileEntities().values());
-                    List<Entity> list = null;
-                    List<Entity>[] aentityslice = chunk.getEntitySlices(); // Spigot
-                    int i = aentityslice.length;
-
-                    for (int j = 0; j < i; ++j) {
-                        List<Entity> entityslice = aentityslice[j]; // Spigot
-                        Iterator iterator = entityslice.iterator();
-
-                        while (iterator.hasNext()) {
-                            Entity entity = (Entity) iterator.next();
-                            // CraftBukkit start - these are spawned serialized (DefinedStructure) and we don't call an add event below at the moment due to ordering complexities
-                            boolean needsRemoval = false;
-                            if (chunk.needsDecoration) {
-                                net.minecraft.server.dedicated.DedicatedServer server = this.world.getServer().getServer();
-                                if (!server.getSpawnNPCs() && entity instanceof net.minecraft.world.entity.npc.NPC) {
-                                    entity.dead = true; // Paper
-                                    needsRemoval = true;
-                                }
+                    chunk.setLastSaved(this.world.getTime() - 1); // Paper - avoid autosaving newly generated/loaded chunks
 
-                                if (!server.getSpawnAnimals() && (entity instanceof net.minecraft.world.entity.animal.EntityAnimal || entity instanceof net.minecraft.world.entity.animal.EntityWaterAnimal)) {
-                                    entity.dead = true; // Paper
-                                    needsRemoval = true;
+                    chunk.a(() -> {
+                        return PlayerChunk.getChunkState(playerchunk.getTicketLevel());
+                    });
+                    chunk.addEntities();
+                    if (this.loadedChunks.add(chunkcoordintpair.pair())) {
+                        chunk.setLoaded(true);
+                        this.world.a(chunk.getTileEntities().values());
+                        List<Entity> list = null;
+                        List<Entity>[] aentityslice = chunk.getEntitySlices(); // Spigot
+                        int i = aentityslice.length;
+
+                        for (int j = 0; j < i; ++j) {
+                            List<Entity> entityslice = aentityslice[j]; // Spigot
+                            Iterator iterator = entityslice.iterator();
+
+                            while (iterator.hasNext()) {
+                                Entity entity = (Entity) iterator.next();
+                                // CraftBukkit start - these are spawned serialized (DefinedStructure) and we don't call an add event below at the moment due to ordering complexities
+                                boolean needsRemoval = false;
+                                if (chunk.needsDecoration) {
+                                    net.minecraft.server.dedicated.DedicatedServer server = this.world.getServer().getServer();
+                                    if (!server.getSpawnNPCs() && entity instanceof net.minecraft.world.entity.npc.NPC) {
+                                        entity.dead = true; // Paper
+                                        needsRemoval = true;
+                                    }
+
+                                    if (!server.getSpawnAnimals() && (entity instanceof net.minecraft.world.entity.animal.EntityAnimal || entity instanceof net.minecraft.world.entity.animal.EntityWaterAnimal)) {
+                                        entity.dead = true; // Paper
+                                        needsRemoval = true;
+                                    }
                                 }
-                            }
-                            // CraftBukkit end
-                            checkDupeUUID(entity); // Paper
-                            if (!(entity instanceof EntityHuman) && (entity.dead || !this.world.addEntityChunk(entity))) { // Paper
-                                if (list == null) {
-                                    list = Lists.newArrayList(new Entity[]{entity});
-                                } else {
-                                    list.add(entity);
+                                // CraftBukkit end
+                                checkDupeUUID(entity); // Paper
+                                if (!(entity instanceof EntityHuman) && (entity.dead || !this.world.addEntityChunk(entity))) { // Paper
+                                    if (list == null) {
+                                        list = Lists.newArrayList(new Entity[]{entity});
+                                    } else {
+                                        list.add(entity);
+                                    }
                                 }
                             }
                         }
-                    }
 
-                    if (list != null) {
-                        list.forEach(chunk::b);
+                        if (list != null) {
+                            list.forEach(chunk::b);
+                        }
                     }
-                }
 
-                return chunk;
+                    return chunk;
                 } // Paper
             });
         }, (runnable) -> {
@@ -1484,8 +1493,8 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     private void checkDupeUUID(Entity entity) {
         PaperWorldConfig.DuplicateUUIDMode mode = world.paperConfig.duplicateUUIDMode;
         if (mode != PaperWorldConfig.DuplicateUUIDMode.WARN
-            && mode != PaperWorldConfig.DuplicateUUIDMode.DELETE
-            && mode != PaperWorldConfig.DuplicateUUIDMode.SAFE_REGEN) {
+                && mode != PaperWorldConfig.DuplicateUUIDMode.DELETE
+                && mode != PaperWorldConfig.DuplicateUUIDMode.SAFE_REGEN) {
             return;
         }
         Entity other = world.getEntity(entity.getUniqueID());
@@ -1494,7 +1503,8 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 && Objects.equals(other.getSaveID(), entity.getSaveID())
                 && entity.getBukkitEntity().getLocation().distance(other.getBukkitEntity().getLocation()) < world.paperConfig.duplicateUUIDDeleteRange
         ) {
-            if (World.DEBUG_ENTITIES) LOGGER.warn("[DUPE-UUID] Duplicate UUID found used by " + other + ", deleted entity " + entity + " because it was near the duplicate and likely an actual duplicate. See https://github.com/PaperMC/Paper/issues/1223 for discussion on what this is about.");
+            if (World.DEBUG_ENTITIES)
+                LOGGER.warn("[DUPE-UUID] Duplicate UUID found used by " + other + ", deleted entity " + entity + " because it was near the duplicate and likely an actual duplicate. See https://github.com/PaperMC/Paper/issues/1223 for discussion on what this is about.");
             entity.dead = true;
             return;
         }
@@ -1502,16 +1512,19 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             switch (mode) {
                 case SAFE_REGEN: {
                     entity.setUUID(UUID.randomUUID());
-                    if (World.DEBUG_ENTITIES) LOGGER.warn("[DUPE-UUID] Duplicate UUID found used by " + other + ", regenerated UUID for " + entity + ". See https://github.com/PaperMC/Paper/issues/1223 for discussion on what this is about.");
+                    if (World.DEBUG_ENTITIES)
+                        LOGGER.warn("[DUPE-UUID] Duplicate UUID found used by " + other + ", regenerated UUID for " + entity + ". See https://github.com/PaperMC/Paper/issues/1223 for discussion on what this is about.");
                     break;
                 }
                 case DELETE: {
-                    if (World.DEBUG_ENTITIES) LOGGER.warn("[DUPE-UUID] Duplicate UUID found used by " + other + ", deleted entity " + entity + ". See https://github.com/PaperMC/Paper/issues/1223 for discussion on what this is about.");
+                    if (World.DEBUG_ENTITIES)
+                        LOGGER.warn("[DUPE-UUID] Duplicate UUID found used by " + other + ", deleted entity " + entity + ". See https://github.com/PaperMC/Paper/issues/1223 for discussion on what this is about.");
                     entity.dead = true;
                     break;
                 }
                 default:
-                    if (World.DEBUG_ENTITIES) LOGGER.warn("[DUPE-UUID] Duplicate UUID found used by " + other + ", doing nothing to " + entity + ". See https://github.com/PaperMC/Paper/issues/1223 for discussion on what this is about.");
+                    if (World.DEBUG_ENTITIES)
+                        LOGGER.warn("[DUPE-UUID] Duplicate UUID found used by " + other + ", doing nothing to " + entity + ". See https://github.com/PaperMC/Paper/issues/1223 for discussion on what this is about.");
                     break;
             }
         }
@@ -1563,48 +1576,48 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     public boolean saveChunk(IChunkAccess ichunkaccess) {
         try (co.aikar.timings.Timing ignored = this.world.timings.chunkSave.startTiming()) { // Paper
-        this.m.a(ichunkaccess.getPos());
-        if (!ichunkaccess.isNeedsSaving()) {
-            return false;
-        } else {
-            ichunkaccess.setLastSaved(this.world.getTime());
-            ichunkaccess.setNeedsSaving(false);
-            ChunkCoordIntPair chunkcoordintpair = ichunkaccess.getPos();
+            this.m.a(ichunkaccess.getPos());
+            if (!ichunkaccess.isNeedsSaving()) {
+                return false;
+            } else {
+                ichunkaccess.setLastSaved(this.world.getTime());
+                ichunkaccess.setNeedsSaving(false);
+                ChunkCoordIntPair chunkcoordintpair = ichunkaccess.getPos();
 
-            try {
-                ChunkStatus chunkstatus = ichunkaccess.getChunkStatus();
+                try {
+                    ChunkStatus chunkstatus = ichunkaccess.getChunkStatus();
 
-                if (chunkstatus.getType() != ChunkStatus.Type.LEVELCHUNK) {
-                    try (co.aikar.timings.Timing ignored1 = this.world.timings.chunkSaveOverwriteCheck.startTiming()) { // Paper
-                    if (this.h(chunkcoordintpair)) {
-                        return false;
-                    }
+                    if (chunkstatus.getType() != ChunkStatus.Type.LEVELCHUNK) {
+                        try (co.aikar.timings.Timing ignored1 = this.world.timings.chunkSaveOverwriteCheck.startTiming()) { // Paper
+                            if (this.h(chunkcoordintpair)) {
+                                return false;
+                            }
 
-                    if (chunkstatus == ChunkStatus.EMPTY && ichunkaccess.h().values().stream().noneMatch(StructureStart::e)) {
-                        return false;
+                            if (chunkstatus == ChunkStatus.EMPTY && ichunkaccess.h().values().stream().noneMatch(StructureStart::e)) {
+                                return false;
+                            }
+                        } // Paper
                     }
-                    } // Paper
-                }
 
-                this.world.getMethodProfiler().c("chunkSave");
-                NBTTagCompound nbttagcompound;
-                try (co.aikar.timings.Timing ignored1 = this.world.timings.chunkSaveDataSerialization.startTiming()) { // Paper
-                    nbttagcompound = ChunkRegionLoader.saveChunk(this.world, ichunkaccess);
-                } // Paper
+                    this.world.getMethodProfiler().c("chunkSave");
+                    NBTTagCompound nbttagcompound;
+                    try (co.aikar.timings.Timing ignored1 = this.world.timings.chunkSaveDataSerialization.startTiming()) { // Paper
+                        nbttagcompound = ChunkRegionLoader.saveChunk(this.world, ichunkaccess);
+                    } // Paper
 
 
-                // Paper start - async chunk io
-                com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(this.world, chunkcoordintpair.x, chunkcoordintpair.z,
-                    null, nbttagcompound, com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY);
-                // Paper end - async chunk io
-                this.a(chunkcoordintpair, chunkstatus.getType());
-                return true;
-            } catch (Exception exception) {
-                PlayerChunkMap.LOGGER.error("Failed to save chunk {},{}", chunkcoordintpair.x, chunkcoordintpair.z, exception);
-                com.destroystokyo.paper.exception.ServerInternalException.reportInternalException(exception); // Paper
-                return false;
+                    // Paper start - async chunk io
+                    com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(this.world, chunkcoordintpair.x, chunkcoordintpair.z,
+                            null, nbttagcompound, com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY);
+                    // Paper end - async chunk io
+                    this.a(chunkcoordintpair, chunkstatus.getType());
+                    return true;
+                } catch (Exception exception) {
+                    PlayerChunkMap.LOGGER.error("Failed to save chunk {},{}", chunkcoordintpair.x, chunkcoordintpair.z, exception);
+                    com.destroystokyo.paper.exception.ServerInternalException.reportInternalException(exception); // Paper
+                    return false;
+                }
             }
-        }
         } // Paper
     }
 
@@ -1735,8 +1748,8 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     public NBTTagCompound read(ChunkCoordIntPair chunkcoordintpair) throws IOException {
         if (Thread.currentThread() != com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE) {
             NBTTagCompound ret = com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE
-                .loadChunkDataAsyncFuture(this.world, chunkcoordintpair.x, chunkcoordintpair.z, com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread(),
-                    false, true, true).join().chunkData;
+                    .loadChunkDataAsyncFuture(this.world, chunkcoordintpair.x, chunkcoordintpair.z, com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread(),
+                            false, true, true).join().chunkData;
 
             if (ret == com.destroystokyo.paper.io.PaperFileIOThread.FAILURE_VALUE) {
                 throw new IOException("See logs for further detail");
@@ -1750,8 +1763,8 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     public void write(ChunkCoordIntPair chunkcoordintpair, NBTTagCompound nbttagcompound) throws IOException {
         if (Thread.currentThread() != com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE) {
             com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(
-                this.world, chunkcoordintpair.x, chunkcoordintpair.z, null, nbttagcompound,
-                com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY); // Tuinity - writes are async, no need for priority
+                    this.world, chunkcoordintpair.x, chunkcoordintpair.z, null, nbttagcompound,
+                    com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY); // Tuinity - writes are async, no need for priority
             return;
         }
         super.write(chunkcoordintpair, nbttagcompound);
@@ -1780,9 +1793,9 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     // Paper start - chunk status cache "api"
     public ChunkStatus getChunkStatusOnDiskIfCached(ChunkCoordIntPair chunkPos) {
         synchronized (this) { // Paper
-        RegionFile regionFile = this.regionFileCache.getRegionFileIfLoaded(chunkPos);
+            RegionFile regionFile = this.regionFileCache.getRegionFileIfLoaded(chunkPos);
 
-        return regionFile == null ? null : regionFile.getStatusIfCached(chunkPos.x, chunkPos.z);
+            return regionFile == null ? null : regionFile.getStatusIfCached(chunkPos.x, chunkPos.z);
         } // Paper
     }
 
@@ -1795,7 +1808,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         // Paper end
         // Paper start - async io
         NBTTagCompound inProgressWrite = com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE
-                                             .getPendingWrite(this.world, chunkPos.x, chunkPos.z, false);
+                .getPendingWrite(this.world, chunkPos.x, chunkPos.z, false);
 
         if (inProgressWrite != null) {
             return ChunkRegionLoader.getStatus(inProgressWrite);
@@ -1834,6 +1847,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         PlayerChunk chunkHolder = this.pendingUnload.get(ChunkCoordIntPair.pair(chunkX, chunkZ));
         return chunkHolder == null ? null : chunkHolder.getAvailableChunkNow();
     }
+
     // Paper end
     // Tuinity start
     public PlayerChunk getUnloadingPlayerChunk(int chunkX, int chunkZ) {
@@ -1854,7 +1868,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         // Paper end
         // Paper start - async io
         NBTTagCompound inProgressWrite = com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE
-            .getPendingWrite(this.world, x, z, false);
+                .getPendingWrite(this.world, x, z, false);
 
         if (inProgressWrite != null) {
             return ChunkRegionLoader.getStatus(inProgressWrite);
@@ -1927,7 +1941,10 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
     // Paper end - optimise isOutsideOfRange
 
-    private boolean cannotLoadChunks(EntityPlayer entityplayer) { return this.b(entityplayer); } // Paper - OBFHELPER
+    private boolean cannotLoadChunks(EntityPlayer entityplayer) {
+        return this.b(entityplayer);
+    } // Paper - OBFHELPER
+
     private boolean b(EntityPlayer entityplayer) {
         return entityplayer.isSpectator() && !this.world.getGameRules().getBoolean(GameRules.SPECTATORS_GENERATE_CHUNKS);
     }
@@ -2073,8 +2090,9 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 if (!(temp instanceof EntityPlayer)) {
                     continue;
                 }
-                EntityPlayer player = (EntityPlayer)temp;
-                if (!this.playerChunkManager.isChunkSent(player, chunkcoordintpair.x, chunkcoordintpair.z)) continue; // Tuinity - replace player chunk management
+                EntityPlayer player = (EntityPlayer) temp;
+                if (!this.playerChunkManager.isChunkSent(player, chunkcoordintpair.x, chunkcoordintpair.z))
+                    continue; // Tuinity - replace player chunk management
                 int viewDistance = this.playerChunkManager.broadcastMap.getLastViewDistance(player); // Tuinity - replace player chunk loader system
                 long lastPosition = this.playerChunkManager.broadcastMap.getLastCoordinate(player); // Tuinity - replace player chunk loader system
 
@@ -2090,8 +2108,9 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 if (!(temp instanceof EntityPlayer)) {
                     continue;
                 }
-                EntityPlayer player = (EntityPlayer)temp;
-                if (!this.playerChunkManager.isChunkSent(player, chunkcoordintpair.x, chunkcoordintpair.z)) continue; // Tuinity - replace player chunk management
+                EntityPlayer player = (EntityPlayer) temp;
+                if (!this.playerChunkManager.isChunkSent(player, chunkcoordintpair.x, chunkcoordintpair.z))
+                    continue; // Tuinity - replace player chunk management
                 players.add(player);
             }
         }
@@ -2104,11 +2123,12 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         // Paper start - ignore and warn about illegal addEntity calls instead of crashing server
         if (!entity.valid || entity.world != this.world || this.trackedEntities.containsKey(entity.getId())) {
             new Throwable("[ERROR] Illegal PlayerChunkMap::addEntity for world " + this.world.getWorld().getName()
-                + ": " + entity  + (this.trackedEntities.containsKey(entity.getId()) ? " ALREADY CONTAINED (This would have crashed your server)" : ""))
-                .printStackTrace();
+                    + ": " + entity + (this.trackedEntities.containsKey(entity.getId()) ? " ALREADY CONTAINED (This would have crashed your server)" : ""))
+                    .printStackTrace();
             return;
         }
-        if (entity instanceof EntityPlayer && ((EntityPlayer) entity).supressTrackerForLogin) return; // Delay adding to tracker until after list packets
+        if (entity instanceof EntityPlayer && ((EntityPlayer) entity).supressTrackerForLogin)
+            return; // Delay adding to tracker until after list packets
         // Paper end
         if (!(entity instanceof EntityComplexPart)) {
             EntityTypes<?> entitytypes = entity.getEntityType();
@@ -2295,7 +2315,10 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
     }
     // Paper end
 
-    public final void sendChunk(EntityPlayer entityplayer, Packet<?>[] apacket, Chunk chunk) { this.a(entityplayer, apacket, chunk); } // Paper - OBFHELPER
+    public final void sendChunk(EntityPlayer entityplayer, Packet<?>[] apacket, Chunk chunk) {
+        this.a(entityplayer, apacket, chunk);
+    } // Paper - OBFHELPER
+
     private void a(EntityPlayer entityplayer, Packet<?>[] apacket, Chunk chunk) {
         if (apacket[0] == null) {
             // Paper start - add 8 for light fix workaround
@@ -2308,60 +2331,60 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
 
             // Paper start - Fix MC-162253
             if (com.tuinity.tuinity.config.TuinityConfig.enableMC162253Workaround) { // Tuinity - hide behind config option, this logic has undesirable network effects
-            final int lightMask = getLightMask(chunk);
-            int i = 1;
-            for (int x = -1; x <= 1; x++) {
-                for (int z = -1; z <= 1; z++) {
-                    if (x == 0 && z == 0) {
-                        continue;
-                    }
+                final int lightMask = getLightMask(chunk);
+                int i = 1;
+                for (int x = -1; x <= 1; x++) {
+                    for (int z = -1; z <= 1; z++) {
+                        if (x == 0 && z == 0) {
+                            continue;
+                        }
 
-                    ++i;
+                        ++i;
 
-                    if (!chunk.isNeighbourLoaded(x, z)) {
-                        continue;
-                    }
+                        if (!chunk.isNeighbourLoaded(x, z)) {
+                            continue;
+                        }
 
-                    final Chunk neighbor = chunk.getRelativeNeighbourIfLoaded(x, z);
-                    final int updateLightMask = lightMask & ~getCeilingLightMask(neighbor);
+                        final Chunk neighbor = chunk.getRelativeNeighbourIfLoaded(x, z);
+                        final int updateLightMask = lightMask & ~getCeilingLightMask(neighbor);
 
-                    if (updateLightMask == 0) {
-                        continue;
-                    }
+                        if (updateLightMask == 0) {
+                            continue;
+                        }
 
-                    apacket[i] = new PacketPlayOutLightUpdate(new ChunkCoordIntPair(chunk.getPos().x + x, chunk.getPos().z + z), lightEngine, updateLightMask, 0, true);
+                        apacket[i] = new PacketPlayOutLightUpdate(new ChunkCoordIntPair(chunk.getPos().x + x, chunk.getPos().z + z), lightEngine, updateLightMask, 0, true);
+                    }
                 }
-            }
-        } // Tuinity - hide behind config option, this logic has undesirable network effects
+            } // Tuinity - hide behind config option, this logic has undesirable network effects
         }
 
         if (com.tuinity.tuinity.config.TuinityConfig.enableMC162253Workaround) { // Tuinity - hide behind config option, this logic has undesirable network effects
-        final int viewDistance = this.playerChunkManager.broadcastMap.getLastViewDistance(entityplayer); // Tuinity - replace player chunk loader
-        final long lastPosition = this.playerChunkManager.broadcastMap.getLastCoordinate(entityplayer); // Tuinity - replace player chunk loader
+            final int viewDistance = this.playerChunkManager.broadcastMap.getLastViewDistance(entityplayer); // Tuinity - replace player chunk loader
+            final long lastPosition = this.playerChunkManager.broadcastMap.getLastCoordinate(entityplayer); // Tuinity - replace player chunk loader
 
-        int j = 1;
-        for (int x = -1; x <= 1; x++) {
-            for (int z = -1; z <= 1; z++) {
-                if (x == 0 && z == 0) {
-                    continue;
-                }
+            int j = 1;
+            for (int x = -1; x <= 1; x++) {
+                for (int z = -1; z <= 1; z++) {
+                    if (x == 0 && z == 0) {
+                        continue;
+                    }
 
-                ++j;
+                    ++j;
 
-                Packet<?> packet = apacket[j];
-                if (packet == null) {
-                    continue;
-                }
+                    Packet<?> packet = apacket[j];
+                    if (packet == null) {
+                        continue;
+                    }
 
-                final int distX = Math.abs(MCUtil.getCoordinateX(lastPosition) - (chunk.getPos().x + x));
-                final int distZ = Math.abs(MCUtil.getCoordinateZ(lastPosition) - (chunk.getPos().z + z));
+                    final int distX = Math.abs(MCUtil.getCoordinateX(lastPosition) - (chunk.getPos().x + x));
+                    final int distZ = Math.abs(MCUtil.getCoordinateZ(lastPosition) - (chunk.getPos().z + z));
 
-                if (Math.max(distX, distZ) > viewDistance) {
-                    continue;
+                    if (Math.max(distX, distZ) > viewDistance) {
+                        continue;
+                    }
+                    entityplayer.playerConnection.sendPacket(packet);
                 }
-                entityplayer.playerConnection.sendPacket(packet);
             }
-        }
         } // Tuinity - hide behind config option, this logic has undesirable network effects
         // Paper end - Fix MC-162253
 
@@ -2385,7 +2408,7 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
             // keep the vanilla logic here - this is REQUIRED or else passengers and their vehicles disappear!
             // (and god knows what the leash thing is)
 
-            if (entity instanceof EntityInsentient && ((EntityInsentient)entity).getLeashHolder() != null) {
+            if (entity instanceof EntityInsentient && ((EntityInsentient) entity).getLeashHolder() != null) {
                 list.add(entity);
             }
 
@@ -2418,7 +2441,10 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
 
     }
 
-    public VillagePlace getVillagePlace() { return this.h(); } // Paper - OBFHELPER
+    public VillagePlace getVillagePlace() {
+        return this.h();
+    } // Paper - OBFHELPER
+
     protected VillagePlace h() {
         return this.m;
     }
@@ -2462,7 +2488,7 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
                     if (!(raw instanceof EntityPlayer)) {
                         continue;
                     }
-                    EntityPlayer player = (EntityPlayer)raw;
+                    EntityPlayer player = (EntityPlayer) raw;
                     this.updatePlayer(player);
                 }
             }
@@ -2566,7 +2592,9 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
                     // CraftBukkit end
 
                     if (flag1 && this.trackedPlayerMap.putIfAbsent(entityplayer, true) == null) { // Paper
-                        this.trackerEntry.b(entityplayer);
+                        if (io.papermc.paper.event.player.PlayerTrackEntityEvent.getHandlerList().getRegisteredListeners().length == 0 ||
+                                new io.papermc.paper.event.player.PlayerTrackEntityEvent(entityplayer.getBukkitEntity(), tracker.getBukkitEntity()).callEvent())
+                            this.trackerEntry.b(entityplayer);
                     }
                 } else if (this.trackedPlayers.remove(entityplayer)) {
                     this.trackerEntry.a(entityplayer);
diff --git a/src/main/java/net/minecraft/server/players/JsonList.java b/src/main/java/net/minecraft/server/players/JsonList.java
index c960852dc60d0598012c5eef0d139fe38bde63fb..707392cdb50ea876a86287c038188c7fcc88a12f 100644
--- a/src/main/java/net/minecraft/server/players/JsonList.java
+++ b/src/main/java/net/minecraft/server/players/JsonList.java
@@ -20,6 +20,8 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.event.server.WhitelistStateUpdateEvent;
 import net.minecraft.SystemUtils;
 import net.minecraft.util.ChatDeserializer;
 import org.apache.logging.log4j.LogManager;
@@ -56,6 +58,11 @@ public abstract class JsonList<K, V extends JsonListEntry<K>> {
     }
 
     public void add(V v0) {
+        if(v0 instanceof WhiteListEntry entry) {
+            if (!new io.papermc.paper.event.server.WhitelistStateUpdateEvent(com.destroystokyo.paper.profile.CraftPlayerProfile.asBukkitCopy(entry.getKey()), io.papermc.paper.event.server.WhitelistStateUpdateEvent.WhitelistStatus.ADDED).callEvent()) {
+                return;
+            }
+        }
         this.d.put(this.a(v0.getKey()), v0);
 
         try {
@@ -78,6 +85,11 @@ public abstract class JsonList<K, V extends JsonListEntry<K>> {
     }
 
     public void remove(K k0) {
+        if(k0 instanceof WhiteListEntry entry) {
+            if (!new io.papermc.paper.event.server.WhitelistStateUpdateEvent(com.destroystokyo.paper.profile.CraftPlayerProfile.asBukkitCopy(entry.getKey()), WhitelistStateUpdateEvent.WhitelistStatus.REMOVED).callEvent()) {
+                return;
+            }
+        }
         this.d.remove(this.a(k0));
 
         try {
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 2815a7fb9d8640ec7e0ff3b54e189a7657e4b6d9..bd98ecc204780a9cecbd5f83e33e040be7d18f44 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -3410,7 +3410,11 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, ne
 
     public void b(EntityPlayer entityplayer) {}
 
-    public void c(EntityPlayer entityplayer) {}
+    public void c(EntityPlayer entityplayer) {
+        if (io.papermc.paper.event.player.PlayerUntrackEntityEvent.getHandlerList().getRegisteredListeners().length > 0) {
+            new io.papermc.paper.event.player.PlayerUntrackEntityEvent(entityplayer.getBukkitEntity(), this.getBukkitEntity()).callEvent();
+        }
+    }
 
     public float a(EnumBlockRotation enumblockrotation) {
         float f = MathHelper.g(this.yaw);
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index f0a16fae2ddba2e3deeb09f04c02972495a53137..ed643c42f611c5929e2ace14f1decb531cb1f693 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -2,6 +2,7 @@ package org.bukkit.craftbukkit.entity;
 
 import com.google.common.base.Function;
 import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
 import java.util.List;
 import java.util.Set;
@@ -11,7 +12,9 @@ import net.minecraft.core.BlockPosition;
 import net.minecraft.nbt.NBTBase;
 import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.network.chat.IChatBaseComponent;
+import net.minecraft.server.level.ChunkProviderServer;
 import net.minecraft.server.level.EntityPlayer;
+import net.minecraft.server.level.PlayerChunkMap;
 import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityAreaEffectCloud;
@@ -159,6 +162,7 @@ import org.bukkit.craftbukkit.persistence.CraftPersistentDataContainer;
 import org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry;
 import org.bukkit.craftbukkit.util.CraftChatMessage;
 import org.bukkit.craftbukkit.util.CraftVector;
+import org.bukkit.entity.Player;
 import org.bukkit.entity.Pose;
 import org.bukkit.event.entity.EntityDamageEvent;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
@@ -172,6 +176,7 @@ import org.bukkit.plugin.Plugin;
 import org.bukkit.util.BoundingBox;
 import org.bukkit.util.NumberConversions;
 import org.bukkit.util.Vector;
+import org.jetbrains.annotations.NotNull;
 
 public abstract class CraftEntity implements org.bukkit.entity.Entity {
     private static PermissibleBase perm;
@@ -434,6 +439,26 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         entity.velocityChanged = true;
     }
 
+    @Override
+    @NotNull
+    public Set<Player> getTrackedBy() {
+        ImmutableSet.Builder<Player> players = ImmutableSet.builder();
+
+        net.minecraft.world.level.World world = ((CraftWorld) this.getWorld()).getHandle();
+        if(!(world.getChunkProvider() instanceof ChunkProviderServer provider))
+            return players.build();
+
+        PlayerChunkMap.EntityTracker entityTracker = provider.playerChunkMap.trackedEntities.get(this.getEntityId());
+
+        if (entityTracker != null) {
+            for (EntityPlayer player : entityTracker.trackedPlayers) {
+                players.add(player.getBukkitEntity());
+            }
+        }
+
+        return players.build();
+    }
+
     // Paper start
     /**
      * Checks if the given velocity is not necessarily safe in all situations.
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 087811c0ab5342e394f1226acc98ae84f8dfeaa5..9aaf0b8a9a2dd2c990ce52b545ada43973ac41c7 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -498,6 +498,11 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         return getHandle().compassTarget;
     }
 
+    @Override
+    public boolean isConnected() {
+        return !this.getHandle().q();
+    }
+
     @Override
     public void chat(String msg) {
         if (getHandle().playerConnection == null) return;
diff --git a/src/main/java/org/bukkit/craftbukkit/map/CraftMapRenderer.java b/src/main/java/org/bukkit/craftbukkit/map/CraftMapRenderer.java
index 1f0b117fc961da0f8f3462ec386def7dffa026ba..775dd1e23d6bb57d244f2c54add178f5feef8069 100644
--- a/src/main/java/org/bukkit/craftbukkit/map/CraftMapRenderer.java
+++ b/src/main/java/org/bukkit/craftbukkit/map/CraftMapRenderer.java
@@ -46,4 +46,9 @@ public class CraftMapRenderer extends MapRenderer {
         }
     }
 
+    @Override
+    public boolean isExplorerMap() {
+        return false;
+    }
+
 }
