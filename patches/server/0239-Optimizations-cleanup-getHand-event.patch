From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: xVorttex <sigamatute@gmail.com>
Date: Fri, 27 Sep 2024 22:19:07 +0300
Subject: [PATCH] Optimizations & cleanup & getHand() event


diff --git a/src/main/java/com/destroystokyo/paper/Metrics.java b/src/main/java/com/destroystokyo/paper/Metrics.java
deleted file mode 100644
index 4d8740678049aa749b42618470e9cc838555528d..0000000000000000000000000000000000000000
--- a/src/main/java/com/destroystokyo/paper/Metrics.java
+++ /dev/null
@@ -1,675 +0,0 @@
-package com.destroystokyo.paper;
-
-import net.minecraft.server.MinecraftServer;
-import org.bukkit.Bukkit;
-import org.bukkit.configuration.file.YamlConfiguration;
-import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.bukkit.plugin.Plugin;
-
-import org.json.simple.JSONArray;
-import org.json.simple.JSONObject;
-
-import javax.net.ssl.HttpsURLConnection;
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
-import java.io.File;
-import java.io.IOException;
-import java.net.URL;
-import java.util.*;
-import java.util.concurrent.Callable;
-import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.TimeUnit;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import java.util.zip.GZIPOutputStream;
-
-/**
- * bStats collects some data for plugin authors.
- *
- * Check out https://bStats.org/ to learn more about bStats!
- */
-public class Metrics {
-
-    // Executor service for requests
-    // We use an executor service because the Bukkit scheduler is affected by server lags
-    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
-
-    // The version of this bStats class
-    public static final int B_STATS_VERSION = 1;
-
-    // The url to which the data is sent
-    private static final String URL = "https://bStats.org/submitData/server-implementation";
-
-    // Should failed requests be logged?
-    private static boolean logFailedRequests = false;
-
-    // The logger for the failed requests
-    private static Logger logger = Logger.getLogger("bStats");
-
-    // The name of the server software
-    private final String name;
-
-    // The uuid of the server
-    private final String serverUUID;
-
-    // A list with all custom charts
-    private final List<CustomChart> charts = new ArrayList<>();
-
-    /**
-     * Class constructor.
-     *
-     * @param name              The name of the server software.
-     * @param serverUUID        The uuid of the server.
-     * @param logFailedRequests Whether failed requests should be logged or not.
-     * @param logger            The logger for the failed requests.
-     */
-    public Metrics(String name, String serverUUID, boolean logFailedRequests, Logger logger) {
-        this.name = name;
-        this.serverUUID = serverUUID;
-        Metrics.logFailedRequests = logFailedRequests;
-        Metrics.logger = logger;
-
-        // Start submitting the data
-        startSubmitting();
-    }
-
-    /**
-     * Adds a custom chart.
-     *
-     * @param chart The chart to add.
-     */
-    public void addCustomChart(CustomChart chart) {
-        if (chart == null) {
-            throw new IllegalArgumentException("Chart cannot be null!");
-        }
-        charts.add(chart);
-    }
-
-    /**
-     * Starts the Scheduler which submits our data every 30 minutes.
-     */
-    private void startSubmitting() {
-        final Runnable submitTask = () -> {
-            if (MinecraftServer.getServer().hasStopped()) {
-                return;
-            }
-            submitData();
-        };
-
-        // Many servers tend to restart at a fixed time at xx:00 which causes an uneven distribution of requests on the
-        // bStats backend. To circumvent this problem, we introduce some randomness into the initial and second delay.
-        // WARNING: You must not modify any part of this Metrics class, including the submit delay or frequency!
-        // WARNING: Modifying this code will get your plugin banned on bStats. Just don't do it!
-        long initialDelay = (long) (1000 * 60 * (3 + Math.random() * 3));
-        long secondDelay = (long) (1000 * 60 * (Math.random() * 30));
-        scheduler.schedule(submitTask, initialDelay, TimeUnit.MILLISECONDS);
-        scheduler.scheduleAtFixedRate(submitTask, initialDelay + secondDelay, 1000 * 60 * 30, TimeUnit.MILLISECONDS);
-    }
-
-    /**
-     * Gets the plugin specific data.
-     *
-     * @return The plugin specific data.
-     */
-    private JSONObject getPluginData() {
-        JSONObject data = new JSONObject();
-
-        data.put("pluginName", name); // Append the name of the server software
-        JSONArray customCharts = new JSONArray();
-        for (CustomChart customChart : charts) {
-            // Add the data of the custom charts
-            JSONObject chart = customChart.getRequestJsonObject();
-            if (chart == null) { // If the chart is null, we skip it
-                continue;
-            }
-            customCharts.add(chart);
-        }
-        data.put("customCharts", customCharts);
-
-        return data;
-    }
-
-    /**
-     * Gets the server specific data.
-     *
-     * @return The server specific data.
-     */
-    private JSONObject getServerData() {
-        // OS specific data
-        String osName = System.getProperty("os.name");
-        String osArch = System.getProperty("os.arch");
-        String osVersion = System.getProperty("os.version");
-        int coreCount = Runtime.getRuntime().availableProcessors();
-
-        JSONObject data = new JSONObject();
-
-        data.put("serverUUID", serverUUID);
-
-        data.put("osName", osName);
-        data.put("osArch", osArch);
-        data.put("osVersion", osVersion);
-        data.put("coreCount", coreCount);
-
-        return data;
-    }
-
-    /**
-     * Collects the data and sends it afterwards.
-     */
-    private void submitData() {
-        final JSONObject data = getServerData();
-
-        JSONArray pluginData = new JSONArray();
-        pluginData.add(getPluginData());
-        data.put("plugins", pluginData);
-
-        try {
-            // We are still in the Thread of the timer, so nothing get blocked :)
-            sendData(data);
-        } catch (Exception e) {
-            // Something went wrong! :(
-            if (logFailedRequests) {
-                logger.log(Level.WARNING, "Could not submit stats of " + name, e);
-            }
-        }
-    }
-
-    /**
-     * Sends the data to the bStats server.
-     *
-     * @param data The data to send.
-     * @throws Exception If the request failed.
-     */
-    private static void sendData(JSONObject data) throws Exception {
-        if (data == null) {
-            throw new IllegalArgumentException("Data cannot be null!");
-        }
-        HttpsURLConnection connection = (HttpsURLConnection) new URL(URL).openConnection();
-
-        // Compress the data to save bandwidth
-        byte[] compressedData = compress(data.toString());
-
-        // Add headers
-        connection.setRequestMethod("POST");
-        connection.addRequestProperty("Accept", "application/json");
-        connection.addRequestProperty("Connection", "close");
-        connection.addRequestProperty("Content-Encoding", "gzip"); // We gzip our request
-        connection.addRequestProperty("Content-Length", String.valueOf(compressedData.length));
-        connection.setRequestProperty("Content-Type", "application/json"); // We send our data in JSON format
-        connection.setRequestProperty("User-Agent", "MC-Server/" + B_STATS_VERSION);
-
-        // Send data
-        connection.setDoOutput(true);
-        DataOutputStream outputStream = new DataOutputStream(connection.getOutputStream());
-        outputStream.write(compressedData);
-        outputStream.flush();
-        outputStream.close();
-
-        connection.getInputStream().close(); // We don't care about the response - Just send our data :)
-    }
-
-    /**
-     * Gzips the given String.
-     *
-     * @param str The string to gzip.
-     * @return The gzipped String.
-     * @throws IOException If the compression failed.
-     */
-    private static byte[] compress(final String str) throws IOException {
-        if (str == null) {
-            return null;
-        }
-        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
-        GZIPOutputStream gzip = new GZIPOutputStream(outputStream);
-        gzip.write(str.getBytes("UTF-8"));
-        gzip.close();
-        return outputStream.toByteArray();
-    }
-
-    /**
-     * Represents a custom chart.
-     */
-    public static abstract class CustomChart {
-
-        // The id of the chart
-        final String chartId;
-
-        /**
-         * Class constructor.
-         *
-         * @param chartId The id of the chart.
-         */
-        CustomChart(String chartId) {
-            if (chartId == null || chartId.isEmpty()) {
-                throw new IllegalArgumentException("ChartId cannot be null or empty!");
-            }
-            this.chartId = chartId;
-        }
-
-        private JSONObject getRequestJsonObject() {
-            JSONObject chart = new JSONObject();
-            chart.put("chartId", chartId);
-            try {
-                JSONObject data = getChartData();
-                if (data == null) {
-                    // If the data is null we don't send the chart.
-                    return null;
-                }
-                chart.put("data", data);
-            } catch (Throwable t) {
-                if (logFailedRequests) {
-                    logger.log(Level.WARNING, "Failed to get data for custom chart with id " + chartId, t);
-                }
-                return null;
-            }
-            return chart;
-        }
-
-        protected abstract JSONObject getChartData() throws Exception;
-
-    }
-
-    /**
-     * Represents a custom simple pie.
-     */
-    public static class SimplePie extends CustomChart {
-
-        private final Callable<String> callable;
-
-        /**
-         * Class constructor.
-         *
-         * @param chartId  The id of the chart.
-         * @param callable The callable which is used to request the chart data.
-         */
-        public SimplePie(String chartId, Callable<String> callable) {
-            super(chartId);
-            this.callable = callable;
-        }
-
-        @Override
-        protected JSONObject getChartData() throws Exception {
-            JSONObject data = new JSONObject();
-            String value = callable.call();
-            if (value == null || value.isEmpty()) {
-                // Null = skip the chart
-                return null;
-            }
-            data.put("value", value);
-            return data;
-        }
-    }
-
-    /**
-     * Represents a custom advanced pie.
-     */
-    public static class AdvancedPie extends CustomChart {
-
-        private final Callable<Map<String, Integer>> callable;
-
-        /**
-         * Class constructor.
-         *
-         * @param chartId  The id of the chart.
-         * @param callable The callable which is used to request the chart data.
-         */
-        public AdvancedPie(String chartId, Callable<Map<String, Integer>> callable) {
-            super(chartId);
-            this.callable = callable;
-        }
-
-        @Override
-        protected JSONObject getChartData() throws Exception {
-            JSONObject data = new JSONObject();
-            JSONObject values = new JSONObject();
-            Map<String, Integer> map = callable.call();
-            if (map == null || map.isEmpty()) {
-                // Null = skip the chart
-                return null;
-            }
-            boolean allSkipped = true;
-            for (Map.Entry<String, Integer> entry : map.entrySet()) {
-                if (entry.getValue() == 0) {
-                    continue; // Skip this invalid
-                }
-                allSkipped = false;
-                values.put(entry.getKey(), entry.getValue());
-            }
-            if (allSkipped) {
-                // Null = skip the chart
-                return null;
-            }
-            data.put("values", values);
-            return data;
-        }
-    }
-
-    /**
-     * Represents a custom drilldown pie.
-     */
-    public static class DrilldownPie extends CustomChart {
-
-        private final Callable<Map<String, Map<String, Integer>>> callable;
-
-        /**
-         * Class constructor.
-         *
-         * @param chartId  The id of the chart.
-         * @param callable The callable which is used to request the chart data.
-         */
-        public DrilldownPie(String chartId, Callable<Map<String, Map<String, Integer>>> callable) {
-            super(chartId);
-            this.callable = callable;
-        }
-
-        @Override
-        public JSONObject getChartData() throws Exception {
-            JSONObject data = new JSONObject();
-            JSONObject values = new JSONObject();
-            Map<String, Map<String, Integer>> map = callable.call();
-            if (map == null || map.isEmpty()) {
-                // Null = skip the chart
-                return null;
-            }
-            boolean reallyAllSkipped = true;
-            for (Map.Entry<String, Map<String, Integer>> entryValues : map.entrySet()) {
-                JSONObject value = new JSONObject();
-                boolean allSkipped = true;
-                for (Map.Entry<String, Integer> valueEntry : map.get(entryValues.getKey()).entrySet()) {
-                    value.put(valueEntry.getKey(), valueEntry.getValue());
-                    allSkipped = false;
-                }
-                if (!allSkipped) {
-                    reallyAllSkipped = false;
-                    values.put(entryValues.getKey(), value);
-                }
-            }
-            if (reallyAllSkipped) {
-                // Null = skip the chart
-                return null;
-            }
-            data.put("values", values);
-            return data;
-        }
-    }
-
-    /**
-     * Represents a custom single line chart.
-     */
-    public static class SingleLineChart extends CustomChart {
-
-        private final Callable<Integer> callable;
-
-        /**
-         * Class constructor.
-         *
-         * @param chartId  The id of the chart.
-         * @param callable The callable which is used to request the chart data.
-         */
-        public SingleLineChart(String chartId, Callable<Integer> callable) {
-            super(chartId);
-            this.callable = callable;
-        }
-
-        @Override
-        protected JSONObject getChartData() throws Exception {
-            JSONObject data = new JSONObject();
-            int value = callable.call();
-            if (value == 0) {
-                // Null = skip the chart
-                return null;
-            }
-            data.put("value", value);
-            return data;
-        }
-
-    }
-
-    /**
-     * Represents a custom multi line chart.
-     */
-    public static class MultiLineChart extends CustomChart {
-
-        private final Callable<Map<String, Integer>> callable;
-
-        /**
-         * Class constructor.
-         *
-         * @param chartId  The id of the chart.
-         * @param callable The callable which is used to request the chart data.
-         */
-        public MultiLineChart(String chartId, Callable<Map<String, Integer>> callable) {
-            super(chartId);
-            this.callable = callable;
-        }
-
-        @Override
-        protected JSONObject getChartData() throws Exception {
-            JSONObject data = new JSONObject();
-            JSONObject values = new JSONObject();
-            Map<String, Integer> map = callable.call();
-            if (map == null || map.isEmpty()) {
-                // Null = skip the chart
-                return null;
-            }
-            boolean allSkipped = true;
-            for (Map.Entry<String, Integer> entry : map.entrySet()) {
-                if (entry.getValue() == 0) {
-                    continue; // Skip this invalid
-                }
-                allSkipped = false;
-                values.put(entry.getKey(), entry.getValue());
-            }
-            if (allSkipped) {
-                // Null = skip the chart
-                return null;
-            }
-            data.put("values", values);
-            return data;
-        }
-
-    }
-
-    /**
-     * Represents a custom simple bar chart.
-     */
-    public static class SimpleBarChart extends CustomChart {
-
-        private final Callable<Map<String, Integer>> callable;
-
-        /**
-         * Class constructor.
-         *
-         * @param chartId  The id of the chart.
-         * @param callable The callable which is used to request the chart data.
-         */
-        public SimpleBarChart(String chartId, Callable<Map<String, Integer>> callable) {
-            super(chartId);
-            this.callable = callable;
-        }
-
-        @Override
-        protected JSONObject getChartData() throws Exception {
-            JSONObject data = new JSONObject();
-            JSONObject values = new JSONObject();
-            Map<String, Integer> map = callable.call();
-            if (map == null || map.isEmpty()) {
-                // Null = skip the chart
-                return null;
-            }
-            for (Map.Entry<String, Integer> entry : map.entrySet()) {
-                JSONArray categoryValues = new JSONArray();
-                categoryValues.add(entry.getValue());
-                values.put(entry.getKey(), categoryValues);
-            }
-            data.put("values", values);
-            return data;
-        }
-
-    }
-
-    /**
-     * Represents a custom advanced bar chart.
-     */
-    public static class AdvancedBarChart extends CustomChart {
-
-        private final Callable<Map<String, int[]>> callable;
-
-        /**
-         * Class constructor.
-         *
-         * @param chartId  The id of the chart.
-         * @param callable The callable which is used to request the chart data.
-         */
-        public AdvancedBarChart(String chartId, Callable<Map<String, int[]>> callable) {
-            super(chartId);
-            this.callable = callable;
-        }
-
-        @Override
-        protected JSONObject getChartData() throws Exception {
-            JSONObject data = new JSONObject();
-            JSONObject values = new JSONObject();
-            Map<String, int[]> map = callable.call();
-            if (map == null || map.isEmpty()) {
-                // Null = skip the chart
-                return null;
-            }
-            boolean allSkipped = true;
-            for (Map.Entry<String, int[]> entry : map.entrySet()) {
-                if (entry.getValue().length == 0) {
-                    continue; // Skip this invalid
-                }
-                allSkipped = false;
-                JSONArray categoryValues = new JSONArray();
-                for (int categoryValue : entry.getValue()) {
-                    categoryValues.add(categoryValue);
-                }
-                values.put(entry.getKey(), categoryValues);
-            }
-            if (allSkipped) {
-                // Null = skip the chart
-                return null;
-            }
-            data.put("values", values);
-            return data;
-        }
-
-    }
-
-    static class PaperMetrics {
-        static void startMetrics() {
-            // Get the config file
-            File configFile = new File(new File((File) MinecraftServer.getServer().options.valueOf("plugins"), "bStats"), "config.yml");
-            YamlConfiguration config = YamlConfiguration.loadConfiguration(configFile);
-
-            // Check if the config file exists
-            if (!config.isSet("serverUuid")) {
-
-                // Add default values
-                config.addDefault("enabled", true);
-                // Every server gets it's unique random id.
-                config.addDefault("serverUuid", UUID.randomUUID().toString());
-                // Should failed request be logged?
-                config.addDefault("logFailedRequests", false);
-
-                // Inform the server owners about bStats
-                config.options().header(
-                        "bStats collects some data for plugin authors like how many servers are using their plugins.\n" +
-                                "To honor their work, you should not disable it.\n" +
-                                "This has nearly no effect on the server performance!\n" +
-                                "Check out https://bStats.org/ to learn more :)"
-                ).copyDefaults(true);
-                try {
-                    config.save(configFile);
-                } catch (IOException ignored) {
-                }
-            }
-            // Load the data
-            String serverUUID = config.getString("serverUuid");
-            boolean logFailedRequests = config.getBoolean("logFailedRequests", false);
-            // Only start Metrics, if it's enabled in the config
-            if (config.getBoolean("enabled", true)) {
-                Metrics metrics = new Metrics("Purpur", serverUUID, logFailedRequests, Bukkit.getLogger()); // Purpur
-
-                metrics.addCustomChart(new Metrics.SimplePie("minecraft_version", () -> {
-                    String minecraftVersion = Bukkit.getVersion();
-                    minecraftVersion = minecraftVersion.substring(minecraftVersion.indexOf("MC: ") + 4, minecraftVersion.length() - 1);
-                    return minecraftVersion;
-                }));
-
-                metrics.addCustomChart(new Metrics.SingleLineChart("players", () -> Bukkit.getOnlinePlayers().size()));
-                metrics.addCustomChart(new Metrics.SimplePie("online_mode", () -> Bukkit.getOnlineMode() ? "online" : (PaperConfig.isProxyOnlineMode() ? "bungee" : "offline"))); // Purpur
-                metrics.addCustomChart(new Metrics.SimplePie("purpur_version", () -> (Metrics.class.getPackage().getImplementationVersion() != null) ? Metrics.class.getPackage().getImplementationVersion() : "unknown")); // Purpur
-
-                metrics.addCustomChart(new Metrics.DrilldownPie("java_version", () -> {
-                    Map<String, Map<String, Integer>> map = new HashMap<>();
-                    String javaVersion = System.getProperty("java.version");
-                    Map<String, Integer> entry = new HashMap<>();
-                    entry.put(javaVersion, 1);
-
-                    // http://openjdk.java.net/jeps/223
-                    // Java decided to change their versioning scheme and in doing so modified the java.version system
-                    // property to return $major[.$minor][.$secuity][-ea], as opposed to 1.$major.0_$identifier
-                    // we can handle pre-9 by checking if the "major" is equal to "1", otherwise, 9+
-                    String majorVersion = javaVersion.split("\\.")[0];
-                    String release;
-
-                    int indexOf = javaVersion.lastIndexOf('.');
-
-                    if (majorVersion.equals("1")) {
-                        release = "Java " + javaVersion.substring(0, indexOf);
-                    } else {
-                        // of course, it really wouldn't be all that simple if they didn't add a quirk, now would it
-                        // valid strings for the major may potentially include values such as -ea to deannotate a pre release
-                        Matcher versionMatcher = Pattern.compile("\\d+").matcher(majorVersion);
-                        if (versionMatcher.find()) {
-                            majorVersion = versionMatcher.group(0);
-                        }
-                        release = "Java " + majorVersion;
-                    }
-                    map.put(release, entry);
-
-                    return map;
-                }));
-
-                metrics.addCustomChart(new Metrics.DrilldownPie("legacy_plugins", () -> {
-                    Map<String, Map<String, Integer>> map = new HashMap<>();
-
-                    // count legacy plugins
-                    int legacy = 0;
-                    for (Plugin plugin : Bukkit.getPluginManager().getPlugins()) {
-                        if (CraftMagicNumbers.isLegacy(plugin.getDescription())) {
-                            legacy++;
-                        }
-                    }
-
-                    // insert real value as lower dimension
-                    Map<String, Integer> entry = new HashMap<>();
-                    entry.put(String.valueOf(legacy), 1);
-
-                    // create buckets as higher dimension
-                    if (legacy == 0) {
-                        map.put("0 \uD83D\uDE0E", entry); // :sunglasses:
-                    } else if (legacy <= 5) {
-                        map.put("1-5", entry);
-                    } else if (legacy <= 10) {
-                        map.put("6-10", entry);
-                    } else if (legacy <= 25) {
-                        map.put("11-25", entry);
-                    } else if (legacy <= 50) {
-                        map.put("26-50", entry);
-                    } else {
-                        map.put("50+ \uD83D\uDE2D", entry); // :cry:
-                    }
-
-                    return map;
-                }));
-            }
-
-        }
-    }
-}
diff --git a/src/main/java/com/destroystokyo/paper/PaperConfig.java b/src/main/java/com/destroystokyo/paper/PaperConfig.java
index 10126cb1c3efa2e6c84f20c0da701a131a5dd4cb..e06925c187a5ce4437cc38962a870d7d39ee1291 100644
--- a/src/main/java/com/destroystokyo/paper/PaperConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperConfig.java
@@ -51,7 +51,6 @@ public class PaperConfig {
     private static boolean verbose;
     private static boolean fatalError;
     /*========================================================================*/
-    private static boolean metricsStarted;
 
     public static void init(File configFile) {
         CONFIG_FILE = configFile;
@@ -95,11 +94,6 @@ public class PaperConfig {
         for (Map.Entry<String, Command> entry : commands.entrySet()) {
             MinecraftServer.getServer().server.getCommandMap().register(entry.getKey(), "Paper", entry.getValue());
         }
-
-        if (!metricsStarted) {
-            Metrics.PaperMetrics.startMetrics();
-            metricsStarted = true;
-        }
     }
 
     static void readConfig(Class<?> clazz, Object instance) {
diff --git a/src/main/java/com/destroystokyo/paper/PaperVersionFetcher.java b/src/main/java/com/destroystokyo/paper/PaperVersionFetcher.java
deleted file mode 100644
index d50b61876f15d95b836b3dd81d9c3492c91a8448..0000000000000000000000000000000000000000
--- a/src/main/java/com/destroystokyo/paper/PaperVersionFetcher.java
+++ /dev/null
@@ -1,139 +0,0 @@
-package com.destroystokyo.paper;
-
-import com.destroystokyo.paper.util.VersionFetcher;
-import com.google.common.base.Charsets;
-import com.google.common.io.Resources;
-import com.google.gson.*;
-import net.kyori.adventure.text.Component;
-import net.kyori.adventure.text.TextComponent;
-import net.kyori.adventure.text.format.NamedTextColor;
-import net.kyori.adventure.text.format.TextDecoration;
-
-import javax.annotation.Nonnull;
-import javax.annotation.Nullable;
-import java.io.*;
-import java.net.HttpURLConnection;
-import java.net.URL;
-import java.util.stream.StreamSupport;
-
-public class PaperVersionFetcher implements VersionFetcher {
-    private static final java.util.regex.Pattern VER_PATTERN = java.util.regex.Pattern.compile("^([0-9\\.]*)\\-.*R"); // R is an anchor, will always give '-R' at end
-    private static final String GITHUB_BRANCH_NAME = "master";
-    private static @Nullable String mcVer;
-
-    @Override
-    public long getCacheTime() {
-        return 720000;
-    }
-
-    @Nonnull
-    @Override
-    public Component getVersionMessage(@Nonnull String serverVersion) {
-        String[] parts = serverVersion.substring("git-Tuinity-".length()).split("[-\\s]"); // Tuinity
-        final Component updateMessage = getUpdateStatusMessage("Spottedleaf/Tuinity", GITHUB_BRANCH_NAME, parts[0]); // Tuinity
-        final Component history = getHistory();
-
-        return history != null ? TextComponent.ofChildren(updateMessage, Component.newline(), history) : updateMessage;
-    }
-
-    private static @Nullable String getMinecraftVersion() {
-        if (mcVer == null) {
-            java.util.regex.Matcher matcher = VER_PATTERN.matcher(org.bukkit.Bukkit.getBukkitVersion());
-            if (matcher.find()) {
-                String result = matcher.group();
-                mcVer = result.substring(0, result.length() - 2); // strip 'R' anchor and trailing '-'
-            } else {
-                org.bukkit.Bukkit.getLogger().warning("Unable to match version to pattern! Report to PaperMC!");
-                org.bukkit.Bukkit.getLogger().warning("Pattern: " + VER_PATTERN.toString());
-                org.bukkit.Bukkit.getLogger().warning("Version: " + org.bukkit.Bukkit.getBukkitVersion());
-            }
-        }
-
-        return mcVer;
-    }
-
-    private static Component getUpdateStatusMessage(@Nonnull String repo, @Nonnull String branch, @Nonnull String versionInfo) {
-        int distance;
-        // Tuinity - we don't have jenkins setup
-            versionInfo = versionInfo.replace("\"", "");
-            distance = fetchDistanceFromGitHub(repo, branch, versionInfo);
-        // Tuinity - we don't have jenkins setup
-
-        switch (distance) {
-            case -1:
-                return Component.text("Error obtaining version information", NamedTextColor.YELLOW);
-            case 0:
-                return Component.text("You are running the latest version", NamedTextColor.GREEN);
-            case -2:
-                return Component.text("Unknown version", NamedTextColor.YELLOW);
-            default:
-                return Component.text("You are " + distance + " version(s) behind", NamedTextColor.YELLOW);
-        }
-    }
-
-    private static int fetchDistanceFromSiteApi(int jenkinsBuild, @Nullable String siteApiVersion) {
-        if (siteApiVersion == null) { return -1; }
-        try {
-            try (BufferedReader reader = Resources.asCharSource(
-                new URL("https://papermc.io/api/v2/projects/paper/versions/" + siteApiVersion),
-                Charsets.UTF_8
-            ).openBufferedStream()) {
-                JsonObject json = new Gson().fromJson(reader, JsonObject.class);
-                JsonArray builds = json.getAsJsonArray("builds");
-                int latest = StreamSupport.stream(builds.spliterator(), false)
-                    .mapToInt(e -> e.getAsInt())
-                    .max()
-                    .getAsInt();
-                return latest - jenkinsBuild;
-            } catch (JsonSyntaxException ex) {
-                ex.printStackTrace();
-                return -1;
-            }
-        } catch (IOException e) {
-            e.printStackTrace();
-            return -1;
-        }
-    }
-
-    // Contributed by Techcable <Techcable@outlook.com> in GH-65
-    private static int fetchDistanceFromGitHub(@Nonnull String repo, @Nonnull String branch, @Nonnull String hash) {
-        try {
-            HttpURLConnection connection = (HttpURLConnection) new URL("https://api.github.com/repos/" + repo + "/compare/" + branch + "..." + hash).openConnection();
-            connection.connect();
-            if (connection.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) return -2; // Unknown commit
-            try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), Charsets.UTF_8))) {
-                JsonObject obj = new Gson().fromJson(reader, JsonObject.class);
-                String status = obj.get("status").getAsString();
-                switch (status) {
-                    case "identical":
-                        return 0;
-                    case "behind":
-                        return obj.get("behind_by").getAsInt();
-                    default:
-                        return -1;
-                }
-            } catch (JsonSyntaxException | NumberFormatException e) {
-                e.printStackTrace();
-                return -1;
-            }
-        } catch (IOException e) {
-            e.printStackTrace();
-            return -1;
-        }
-    }
-
-    @Nullable
-    private Component getHistory() {
-        final VersionHistoryManager.VersionData data = VersionHistoryManager.INSTANCE.getVersionData();
-        if (data == null) {
-            return null;
-        }
-
-        final String oldVersion = data.getOldVersion();
-        if (oldVersion == null) {
-            return null;
-        }
-
-        return Component.text("Previous version: " + oldVersion, NamedTextColor.GRAY, TextDecoration.ITALIC);
-    }
-}
diff --git a/src/main/java/com/destroystokyo/paper/VersionHistoryManager.java b/src/main/java/com/destroystokyo/paper/VersionHistoryManager.java
deleted file mode 100644
index aac3f66cb23d260729c2a48d8710a9de2346aa22..0000000000000000000000000000000000000000
--- a/src/main/java/com/destroystokyo/paper/VersionHistoryManager.java
+++ /dev/null
@@ -1,145 +0,0 @@
-package com.destroystokyo.paper;
-
-import com.google.common.base.MoreObjects;
-import com.google.gson.Gson;
-import com.google.gson.JsonSyntaxException;
-import java.io.BufferedReader;
-import java.io.BufferedWriter;
-import java.io.IOException;
-import java.nio.charset.StandardCharsets;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.nio.file.Paths;
-import java.nio.file.StandardOpenOption;
-import java.util.Objects;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import org.bukkit.Bukkit;
-
-import javax.annotation.Nonnull;
-import javax.annotation.Nullable;
-
-public enum VersionHistoryManager {
-    INSTANCE;
-
-    private final Gson gson = new Gson();
-
-    private final Logger logger = Bukkit.getLogger();
-
-    private VersionData currentData = null;
-
-    VersionHistoryManager() {
-        final Path path = Paths.get("version_history.json");
-
-        if (Files.exists(path)) {
-            // Basic file santiy checks
-            if (!Files.isRegularFile(path)) {
-                if (Files.isDirectory(path)) {
-                    logger.severe(path + " is a directory, cannot be used for version history");
-                } else {
-                    logger.severe(path + " is not a regular file, cannot be used for version history");
-                }
-                // We can't continue
-                return;
-            }
-
-            try (final BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) {
-                currentData = gson.fromJson(reader, VersionData.class);
-            } catch (final IOException e) {
-                logger.log(Level.SEVERE, "Failed to read version history file '" + path + "'", e);
-                return;
-            } catch (final JsonSyntaxException e) {
-                logger.log(Level.SEVERE, "Invalid json syntax for file '" + path + "'", e);
-                return;
-            }
-
-            final String version = Bukkit.getVersion();
-            if (version == null) {
-                logger.severe("Failed to retrieve current version");
-                return;
-            }
-
-            if (!version.equals(currentData.getCurrentVersion())) {
-                // The version appears to have changed
-                currentData.setOldVersion(currentData.getCurrentVersion());
-                currentData.setCurrentVersion(version);
-                writeFile(path);
-            }
-        } else {
-            // File doesn't exist, start fresh
-            currentData = new VersionData();
-            // oldVersion is null
-            currentData.setCurrentVersion(Bukkit.getVersion());
-            writeFile(path);
-        }
-    }
-
-    private void writeFile(@Nonnull final Path path) {
-        try (final BufferedWriter writer = Files.newBufferedWriter(
-            path,
-            StandardCharsets.UTF_8,
-            StandardOpenOption.WRITE,
-            StandardOpenOption.CREATE,
-            StandardOpenOption.TRUNCATE_EXISTING
-        )) {
-            gson.toJson(currentData, writer);
-        } catch (final IOException e) {
-            logger.log(Level.SEVERE, "Failed to write to version history file", e);
-        }
-    }
-
-    @Nullable
-    public VersionData getVersionData() {
-        return currentData;
-    }
-
-    public static class VersionData {
-        private String oldVersion;
-
-        private String currentVersion;
-
-        @Nullable
-        public String getOldVersion() {
-            return oldVersion;
-        }
-
-        public void setOldVersion(@Nullable String oldVersion) {
-            this.oldVersion = oldVersion;
-        }
-
-        @Nullable
-        public String getCurrentVersion() {
-            return currentVersion;
-        }
-
-        public void setCurrentVersion(@Nullable String currentVersion) {
-            this.currentVersion = currentVersion;
-        }
-
-        @Override
-        public String toString() {
-            return MoreObjects.toStringHelper(this)
-                .add("oldVersion", oldVersion)
-                .add("currentVersion", currentVersion)
-                .toString();
-        }
-
-        @Override
-        public boolean equals(@Nullable Object o) {
-            if (this == o) {
-                return true;
-            }
-            if (o == null || getClass() != o.getClass()) {
-                return false;
-            }
-            final VersionData versionData = (VersionData) o;
-            return Objects.equals(oldVersion, versionData.oldVersion) &&
-                Objects.equals(currentVersion, versionData.currentVersion);
-        }
-
-        @Override
-        public int hashCode() {
-            return Objects.hash(oldVersion, currentVersion);
-        }
-    }
-}
diff --git a/src/main/java/net/minecraft/commands/CommandDispatcher.java b/src/main/java/net/minecraft/commands/CommandDispatcher.java
index c5babb19a3b4d20c4f9e414d5654d18c570d2b2d..a7261565046fc50cd138f7c9afb6e5355c2eea08 100644
--- a/src/main/java/net/minecraft/commands/CommandDispatcher.java
+++ b/src/main/java/net/minecraft/commands/CommandDispatcher.java
@@ -191,9 +191,6 @@ public class CommandDispatcher {
             CommandIdleTimeout.a(this.b);
             CommandStop.a(this.b);
             CommandWhitelist.a(this.b);
-            net.pl3x.purpur.command.CreditsCommand.register(getDispatcher()); // Purpur
-            net.pl3x.purpur.command.DemoCommand.register(getDispatcher()); // Purpur
-            net.pl3x.purpur.command.PingCommand.register(getDispatcher()); // Purpur
             net.pl3x.purpur.command.TPSBarCommand.register(getDispatcher()); // Purpur
         }
 
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index de917e53fdbd4d8965237864db5fe8bf63cca61b..b148da0e7383307db6095fb66decc6e33b095af1 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -221,7 +221,6 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
         }
         net.pl3x.purpur.PurpurConfig.registerCommands();
         // Purpur end
-        com.destroystokyo.paper.VersionHistoryManager.INSTANCE.getClass(); // load version history now
         io.papermc.paper.brigadier.PaperBrigadierProviderImpl.INSTANCE.getClass(); // init PaperBrigadierProvider
         // Paper end
         com.tuinity.tuinity.config.TuinityConfig.init((java.io.File) options.valueOf("tuinity-settings")); // Tuinity - Server Config
diff --git a/src/main/java/net/minecraft/server/level/EntityPlayer.java b/src/main/java/net/minecraft/server/level/EntityPlayer.java
index 6d67eff4d584c287c97dfe32832c87bb59725bee..1ee2621461adcc2230eb974da53da0db422f58de 100644
--- a/src/main/java/net/minecraft/server/level/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/level/EntityPlayer.java
@@ -323,7 +323,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
             long l = k * k;
             int i1 = l > 2147483647L ? Integer.MAX_VALUE : (int) l;
             int j1 = this.u(i1);
-            int k1 = (new Random()).nextInt(i1);
+            int k1 = worldserver.random.nextInt(i1);
 
             for (int l1 = 0; l1 < i1; ++l1) {
                 int i2 = (k1 + j1 * l1) % i1;
@@ -361,7 +361,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
             long l = k * k;
             int i1 = l > 2147483647L ? Integer.MAX_VALUE : (int) l;
             int j1 = this.u(i1);
-            int k1 = (new Random()).nextInt(i1);
+            int k1 = worldserver.random.nextInt(i1);
 
             for (int l1 = 0; l1 < i1; ++l1) {
                 int i2 = (k1 + j1 * l1) % i1;
diff --git a/src/main/java/net/minecraft/util/datafix/DataConverterRegistry.java b/src/main/java/net/minecraft/util/datafix/DataConverterRegistry.java
index 28e36ee76da533f8aa0a09cfc4f1fc0f744af715..d84f23adf40a031a0a14078c397ee1b5db1f162e 100644
--- a/src/main/java/net/minecraft/util/datafix/DataConverterRegistry.java
+++ b/src/main/java/net/minecraft/util/datafix/DataConverterRegistry.java
@@ -199,13 +199,13 @@ public class DataConverterRegistry {
 
     private static final BiFunction<Integer, Schema, Schema> a = Schema::new;
     private static final BiFunction<Integer, Schema, Schema> b = DataConverterSchemaNamed::new;
-    private static final DataFixer c = b();
+    private static final DataFixer c;
 
-    private static DataFixer b() {
+    static {
         DataFixerBuilder datafixerbuilder = new DataFixerBuilder(SharedConstants.getGameVersion().getWorldVersion());
 
         a(datafixerbuilder);
-        return datafixerbuilder.build(SystemUtils.e());
+        c = datafixerbuilder.build(SystemUtils.e());
     }
 
     public static DataFixer getDataFixer() { return a(); } // Paper - OBFHELPER
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index bd98ecc204780a9cecbd5f83e33e040be7d18f44..d6cfbbeb0191d2ecdf1b3d733573eab20ae25758 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -158,7 +158,7 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, ne
         @Override
         public synchronized void setSeed(long seed) {
             if (locked) {
-                LogManager.getLogger().error("Ignoring setSeed on Entity.SHARED_RANDOM", new Throwable());
+                LOGGER.error("Ignoring setSeed on Entity.SHARED_RANDOM", new Throwable());
             } else {
                 super.setSeed(seed);
                 locked = true;
diff --git a/src/main/java/net/minecraft/world/entity/EntityLiving.java b/src/main/java/net/minecraft/world/entity/EntityLiving.java
index 158388410ea14b2df95635914844952bd52b8f87..a44e6f9e337c52756f51d159af083af5ff51867b 100644
--- a/src/main/java/net/minecraft/world/entity/EntityLiving.java
+++ b/src/main/java/net/minecraft/world/entity/EntityLiving.java
@@ -3478,7 +3478,8 @@ public abstract class EntityLiving extends Entity {
                 PlayerItemConsumeEvent event = null; // Paper
                 if (this instanceof EntityPlayer) {
                     org.bukkit.inventory.ItemStack craftItem = CraftItemStack.asBukkitCopy(this.activeItem);
-                    event = new PlayerItemConsumeEvent((Player) this.getBukkitEntity(), craftItem); // Paper
+                    org.bukkit.inventory.EquipmentSlot hand = org.bukkit.craftbukkit.CraftEquipmentSlot.getHand(enumhand);
+                    event = new PlayerItemConsumeEvent((Player) this.getBukkitEntity(), craftItem, hand); // Paper
                     world.getServer().getPluginManager().callEvent(event);
 
                     if (event.isCancelled()) {
diff --git a/src/main/java/net/pl3x/purpur/PurpurConfig.java b/src/main/java/net/pl3x/purpur/PurpurConfig.java
index 72c20065e09af656a565c2c1097f26c00b76c1e4..a60719a2710b345aaf267203382a3df216b55c81 100644
--- a/src/main/java/net/pl3x/purpur/PurpurConfig.java
+++ b/src/main/java/net/pl3x/purpur/PurpurConfig.java
@@ -57,7 +57,7 @@ public class PurpurConfig {
         verbose = getBoolean("verbose", false);
 
         commands = new HashMap<>();
-        commands.put("purpur", new PurpurCommand("purpur"));
+        commands.put("vspigot", new PurpurCommand("vspigot"));
 
         version = getInt("config-version", 13);
         set("config-version", 13);
@@ -187,7 +187,7 @@ public class PurpurConfig {
         if (!TimingsManager.hiddenConfigs.contains("settings.seed.end-spike")) TimingsManager.hiddenConfigs.add("settings.seed.end-spike");
     }
 
-    public static String serverModName = "Purpur";
+    public static String serverModName = "VSpigot";
     private static void serverModName() {
         serverModName = getString("settings.server-mod-name", serverModName);
     }
diff --git a/src/main/java/net/pl3x/purpur/PurpurVersionFetcher.java b/src/main/java/net/pl3x/purpur/PurpurVersionFetcher.java
deleted file mode 100644
index cabfcebf9f944f7a2a2a1cffc7401435803a8741..0000000000000000000000000000000000000000
--- a/src/main/java/net/pl3x/purpur/PurpurVersionFetcher.java
+++ /dev/null
@@ -1,119 +0,0 @@
-package net.pl3x.purpur;
-
-import com.destroystokyo.paper.VersionHistoryManager;
-import com.destroystokyo.paper.util.VersionFetcher;
-import com.google.common.base.Charsets;
-import com.google.common.io.Resources;
-import com.google.gson.Gson;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonSyntaxException;
-import net.kyori.adventure.text.Component;
-import net.kyori.adventure.text.TextComponent;
-import net.kyori.adventure.text.format.NamedTextColor;
-import net.kyori.adventure.text.format.TextDecoration;
-
-import javax.annotation.Nonnull;
-import javax.annotation.Nullable;
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.net.HttpURLConnection;
-import java.net.URL;
-
-public class PurpurVersionFetcher implements VersionFetcher {
-    private static final String JENKINS_URL = "https://ci.pl3x.net/job/Purpur/lastSuccessfulBuild/buildNumber";
-    private static final String GITHUB_BRANCH_NAME = "master";
-
-    @Override
-    public long getCacheTime() {
-        return 720000;
-    }
-
-    @Nonnull
-    @Override
-    public Component getVersionMessage(@Nonnull String serverVersion) {
-        String[] parts = serverVersion.substring("git-Purpur-".length()).split("[-\\s]");
-        final Component updateMessage = getUpdateStatusMessage("pl3xgaming/Purpur", GITHUB_BRANCH_NAME, parts[0]);
-        final Component history = getHistory();
-
-        return history != null ? TextComponent.ofChildren(updateMessage, Component.newline(), history) : updateMessage;
-    }
-
-    private static Component getUpdateStatusMessage(@Nonnull String repo, @Nonnull String branch, @Nonnull String versionInfo) {
-        int distance;
-        try {
-            int jenkinsBuild = Integer.parseInt(versionInfo);
-            distance = fetchDistanceFromJenkins(jenkinsBuild);
-        } catch (NumberFormatException ignored) {
-            versionInfo = versionInfo.replace("\"", "");
-            distance = fetchDistanceFromGitHub(repo, branch, versionInfo);
-        }
-
-        switch (distance) {
-            case -1:
-                return Component.text("Error obtaining version information", NamedTextColor.YELLOW);
-            case 0:
-                return Component.text("You are running the latest version", NamedTextColor.GREEN);
-            case -2:
-                return Component.text("Unknown version", NamedTextColor.YELLOW);
-            default:
-                return Component.text("You are " + distance + " version(s) behind", NamedTextColor.YELLOW);
-        }
-    }
-
-    private static int fetchDistanceFromJenkins(int jenkinsBuild) {
-        try {
-            try (BufferedReader reader = Resources.asCharSource(new URL(JENKINS_URL), Charsets.UTF_8).openBufferedStream()) {
-                return Integer.decode(reader.readLine()) - jenkinsBuild;
-            } catch (NumberFormatException ex) {
-                ex.printStackTrace();
-                return -2;
-            }
-        } catch (IOException e) {
-            e.printStackTrace();
-            return -1;
-        }
-    }
-
-    // Contributed by Techcable <Techcable@outlook.com> in GH-65
-    private static int fetchDistanceFromGitHub(@Nonnull String repo, @Nonnull String branch, @Nonnull String hash) {
-        try {
-            HttpURLConnection connection = (HttpURLConnection) new URL("https://api.github.com/repos/" + repo + "/compare/" + branch + "..." + hash).openConnection();
-            connection.connect();
-            if (connection.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) return -2; // Unknown commit
-            try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), Charsets.UTF_8))) {
-                JsonObject obj = new Gson().fromJson(reader, JsonObject.class);
-                String status = obj.get("status").getAsString();
-                switch (status) {
-                    case "identical":
-                        return 0;
-                    case "behind":
-                        return obj.get("behind_by").getAsInt();
-                    default:
-                        return -1;
-                }
-            } catch (JsonSyntaxException | NumberFormatException e) {
-                e.printStackTrace();
-                return -1;
-            }
-        } catch (IOException e) {
-            e.printStackTrace();
-            return -1;
-        }
-    }
-
-    @Nullable
-    private Component getHistory() {
-        final VersionHistoryManager.VersionData data = VersionHistoryManager.INSTANCE.getVersionData();
-        if (data == null) {
-            return null;
-        }
-
-        final String oldVersion = data.getOldVersion();
-        if (oldVersion == null) {
-            return null;
-        }
-
-        return Component.text("Previous version: " + oldVersion, NamedTextColor.GRAY, TextDecoration.ITALIC);
-    }
-}
diff --git a/src/main/java/net/pl3x/purpur/command/CreditsCommand.java b/src/main/java/net/pl3x/purpur/command/CreditsCommand.java
deleted file mode 100644
index ccb7b9de16c75cd2cddd0c4bbf8e4595e3c61dea..0000000000000000000000000000000000000000
--- a/src/main/java/net/pl3x/purpur/command/CreditsCommand.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package net.pl3x.purpur.command;
-
-import net.minecraft.commands.CommandDispatcher;
-import net.minecraft.commands.CommandListenerWrapper;
-import net.minecraft.commands.arguments.ArgumentEntity;
-import net.minecraft.network.protocol.game.PacketPlayOutGameStateChange;
-import net.minecraft.server.level.EntityPlayer;
-import net.pl3x.purpur.PurpurConfig;
-import org.bukkit.craftbukkit.util.CraftChatMessage;
-
-import java.util.Collection;
-import java.util.Collections;
-
-public class CreditsCommand {
-    public static void register(com.mojang.brigadier.CommandDispatcher<CommandListenerWrapper> dispatcher) {
-        dispatcher.register(CommandDispatcher.literal("credits")
-                .requires((listener) -> {
-                    return listener.hasPermission(2);
-                })
-                .executes((context) -> {
-                    return execute(context.getSource(), Collections.singleton(context.getSource().getPlayerOrException()));
-                })
-                .then(CommandDispatcher.argument("targets", ArgumentEntity.players())
-                        .executes((context) -> {
-                            return execute(context.getSource(), ArgumentEntity.getPlayers(context, "targets"));
-                        })
-                )
-        ).setPermission("bukkit.command.credits");
-    }
-
-    private static int execute(CommandListenerWrapper sender, Collection<EntityPlayer> targets) {
-        for (EntityPlayer player : targets) {
-            PacketPlayOutGameStateChange packet = new PacketPlayOutGameStateChange(PacketPlayOutGameStateChange.credits(), 1F);
-            player.viewingCredits = true;
-            player.playerConnection.sendPacket(packet);
-            String output = String.format(PurpurConfig.creditsCommandOutput, player.getProfile().getName());
-            sender.sendMessage(CraftChatMessage.fromStringOrNull(output), false);
-        }
-        return targets.size();
-    }
-}
diff --git a/src/main/java/net/pl3x/purpur/command/DemoCommand.java b/src/main/java/net/pl3x/purpur/command/DemoCommand.java
deleted file mode 100644
index 7ea2e07c95c26528e118541ca2bba4d6117ab28f..0000000000000000000000000000000000000000
--- a/src/main/java/net/pl3x/purpur/command/DemoCommand.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package net.pl3x.purpur.command;
-
-import java.util.Collection;
-import java.util.Collections;
-import net.minecraft.commands.arguments.ArgumentEntity;
-import net.minecraft.commands.CommandDispatcher;
-import net.minecraft.commands.CommandListenerWrapper;
-import net.minecraft.network.protocol.game.PacketPlayOutGameStateChange;
-import net.minecraft.server.level.EntityPlayer;
-import net.pl3x.purpur.PurpurConfig;
-import org.bukkit.craftbukkit.util.CraftChatMessage;
-
-public class DemoCommand {
-    public static void register(com.mojang.brigadier.CommandDispatcher<CommandListenerWrapper> dispatcher) {
-        dispatcher.register(CommandDispatcher.literal("demo")
-                .requires((listener) -> {
-                    return listener.hasPermission(2);
-                })
-                .executes((context) -> {
-                    return execute(context.getSource(), Collections.singleton(context.getSource().getPlayerOrException()));
-                })
-                .then(CommandDispatcher.argument("targets", ArgumentEntity.players())
-                        .executes((context) -> {
-                            return execute(context.getSource(), ArgumentEntity.getPlayers(context, "targets"));
-                        })
-                )
-        ).setPermission("bukkit.command.demo");
-    }
-
-    private static int execute(CommandListenerWrapper sender, Collection<EntityPlayer> targets) {
-        for (EntityPlayer player : targets) {
-            PacketPlayOutGameStateChange packet = new PacketPlayOutGameStateChange(PacketPlayOutGameStateChange.demo(), 0);
-            player.playerConnection.sendPacket(packet);
-            String output = String.format(PurpurConfig.demoCommandOutput, player.getProfile().getName());
-            sender.sendMessage(CraftChatMessage.fromStringOrNull(output), false);
-        }
-        return targets.size();
-    }
-}
diff --git a/src/main/java/net/pl3x/purpur/command/PingCommand.java b/src/main/java/net/pl3x/purpur/command/PingCommand.java
deleted file mode 100644
index 1d636d7c541d127a473d5be2509e5db29936e8ad..0000000000000000000000000000000000000000
--- a/src/main/java/net/pl3x/purpur/command/PingCommand.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package net.pl3x.purpur.command;
-
-import net.minecraft.commands.arguments.ArgumentEntity;
-import net.minecraft.commands.CommandDispatcher;
-import net.minecraft.commands.CommandListenerWrapper;
-import net.minecraft.server.level.EntityPlayer;
-import net.pl3x.purpur.PurpurConfig;
-import org.bukkit.craftbukkit.util.CraftChatMessage;
-
-import java.util.Collection;
-import java.util.Collections;
-
-public class PingCommand {
-    public static void register(com.mojang.brigadier.CommandDispatcher<CommandListenerWrapper> dispatcher) {
-        dispatcher.register(CommandDispatcher.literal("ping")
-                .requires((listener) -> {
-                    return listener.hasPermission(2);
-                })
-                .executes((context) -> {
-                    return execute(context.getSource(), Collections.singleton(context.getSource().getPlayerOrException()));
-                })
-                .then(CommandDispatcher.argument("targets", ArgumentEntity.players())
-                        .executes((context) -> {
-                            return execute(context.getSource(), ArgumentEntity.getPlayers(context, "targets"));
-                        })
-                )
-        ).setPermission("bukkit.command.ping");
-    }
-
-    private static int execute(CommandListenerWrapper sender, Collection<EntityPlayer> targets) {
-        for (EntityPlayer player : targets) {
-            String output = String.format(PurpurConfig.pingCommandOutput, player.getProfile().getName(), player.ping);
-            sender.sendMessage(CraftChatMessage.fromStringOrNull(output), false);
-        }
-        return targets.size();
-    }
-}
diff --git a/src/main/java/net/pl3x/purpur/command/PurpurCommand.java b/src/main/java/net/pl3x/purpur/command/PurpurCommand.java
index 0c35b1dd5147cf86c7ee743b98528e8f4bc0b5e9..6228b558ab1695d32a34a99283d5d2b49a8db7fc 100644
--- a/src/main/java/net/pl3x/purpur/command/PurpurCommand.java
+++ b/src/main/java/net/pl3x/purpur/command/PurpurCommand.java
@@ -18,14 +18,14 @@ public class PurpurCommand extends Command {
     public PurpurCommand(String name) {
         super(name);
         this.description = "Purpur related commands";
-        this.usageMessage = "/purpur [reload | version]";
+        this.usageMessage = "/purpur [reload]";
         this.setPermission("bukkit.command.purpur");
     }
 
     @Override
     public List<String> tabComplete(CommandSender sender, String alias, String[] args, Location location) throws IllegalArgumentException {
         if (args.length == 1) {
-            return Stream.of("reload", "version")
+            return Stream.of("reload")
                     .filter(arg -> arg.startsWith(args[0].toLowerCase()))
                     .collect(Collectors.toList());
         }
@@ -54,11 +54,6 @@ public class PurpurCommand extends Command {
             console.server.reloadCount++;
 
             Command.broadcastCommandMessage(sender, ChatColor.GREEN + "Purpur config reload complete.");
-        } else if (args[0].equalsIgnoreCase("version")) {
-            Command verCmd = org.bukkit.Bukkit.getServer().getCommandMap().getCommand("version");
-            if (verCmd != null) {
-                return verCmd.execute(sender, commandLabel, new String[0]);
-            }
         }
 
         return true;
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftEquipmentSlot.java b/src/main/java/org/bukkit/craftbukkit/CraftEquipmentSlot.java
index bb5a39362a371224994d0eb8319a8aebe4dd6d18..eb5b07670feaa7e136c164a6d240067fb2ba3602 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftEquipmentSlot.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftEquipmentSlot.java
@@ -1,5 +1,6 @@
 package org.bukkit.craftbukkit;
 
+import net.minecraft.world.EnumHand;
 import net.minecraft.world.entity.EnumItemSlot;
 import org.bukkit.inventory.EquipmentSlot;
 
@@ -26,6 +27,10 @@ public class CraftEquipmentSlot {
         return enums[nms.ordinal()];
     }
 
+    public static EquipmentSlot getHand(EnumHand enumhand) {
+        return (enumhand == EnumHand.MAIN_HAND) ? EquipmentSlot.HAND : EquipmentSlot.OFF_HAND;
+    }
+
     public static EnumItemSlot getNMS(EquipmentSlot slot) {
         return slots[slot.ordinal()];
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index eb8500ab9dac149fbca592d250a15eb89f33d6a9..565327531e1792be4828daf045eed58529626487 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -231,7 +231,7 @@ import javax.annotation.Nullable; // Paper
 import javax.annotation.Nonnull; // Paper
 
 public final class CraftServer implements Server {
-    private final String serverName = "Purpur"; // Paper // Tuinity // Purpur
+    private final String serverName = "VSpigot"; // Paper // Tuinity // Purpur
     private final String serverVersion;
     private final String bukkitVersion = Versioning.getBukkitVersion();
     private final Logger logger = Logger.getLogger("Minecraft");
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
index bfe4f7ed53620510b52d4f01c5ea2a3f726942d8..f34761396dee9b57a1a3ec8e5a51787ceccbbabf 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
@@ -395,11 +395,6 @@ public final class CraftMagicNumbers implements UnsafeValues {
         return com.destroystokyo.paper.PaperConfig.timingsServerName;
     }
 
-    @Override
-    public com.destroystokyo.paper.util.VersionFetcher getVersionFetcher() {
-        return new net.pl3x.purpur.PurpurVersionFetcher();
-    }
-
     @Override
     public boolean isSupportedApiVersion(String apiVersion) {
         return apiVersion != null && SUPPORTED_API.contains(apiVersion);
diff --git a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
index 52b18334432f6b0e8a922a794c300b38c9cbb7b2..df3a0356cad7da2ef1a3b5a1d79093e86660c48f 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
@@ -9,21 +9,6 @@ import org.bukkit.Bukkit;
 
 public final class Versioning {
     public static String getBukkitVersion() {
-        String result = "Unknown-Version";
-
-        InputStream stream = Bukkit.class.getClassLoader().getResourceAsStream("META-INF/maven/org.purpurmc.purpur/purpur-api/pom.properties"); // Tuinity // Purpur
-        Properties properties = new Properties();
-
-        if (stream != null) {
-            try {
-                properties.load(stream);
-
-                result = properties.getProperty("version");
-            } catch (IOException ex) {
-                Logger.getLogger(Versioning.class.getName()).log(Level.SEVERE, "Could not get Bukkit version!", ex);
-            }
-        }
-
-        return result;
+        return "1.16.5-R0.1-SNAPSHOT";
     }
 }
diff --git a/src/main/java/org/spigotmc/Metrics.java b/src/main/java/org/spigotmc/Metrics.java
deleted file mode 100644
index c25cbfa7a467dfe5022ea8f887361ef5b85466a3..0000000000000000000000000000000000000000
--- a/src/main/java/org/spigotmc/Metrics.java
+++ /dev/null
@@ -1,641 +0,0 @@
-/*
- * Copyright 2011-2013 Tyler Blair. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are
- * permitted provided that the following conditions are met:
- *
- *    1. Redistributions of source code must retain the above copyright notice, this list of
- *       conditions and the following disclaimer.
- *
- *    2. Redistributions in binary form must reproduce the above copyright notice, this list
- *       of conditions and the following disclaimer in the documentation and/or other materials
- *       provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
- * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * The views and conclusions contained in the software and documentation are those of the
- * authors and contributors and should not be interpreted as representing official policies,
- * either expressed or implied, of anybody else.
- */
-package org.spigotmc;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.OutputStreamWriter;
-import java.io.UnsupportedEncodingException;
-import java.net.Proxy;
-import java.net.URL;
-import java.net.URLConnection;
-import java.net.URLEncoder;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.LinkedHashSet;
-import java.util.Set;
-import java.util.Timer;
-import java.util.TimerTask;
-import java.util.UUID;
-import java.util.concurrent.TimeUnit;
-import java.util.logging.Level;
-import net.minecraft.server.MinecraftServer;
-import org.bukkit.Bukkit;
-import org.bukkit.configuration.InvalidConfigurationException;
-import org.bukkit.configuration.file.YamlConfiguration;
-
-/**
- * <p> The metrics class obtains data about a plugin and submits statistics about it to the metrics backend. </p> <p>
- * Public methods provided by this class: </p>
- * <code>
- * Graph createGraph(String name); <br/>
- * void addCustomData(BukkitMetrics.Plotter plotter); <br/>
- * void start(); <br/>
- * </code>
- */
-public class Metrics {
-
-    /**
-     * The current revision number
-     */
-    private static final int REVISION = 6;
-    /**
-     * The base url of the metrics domain
-     */
-    private static final String BASE_URL = "https://mcstats.spigotmc.org";
-    /**
-     * The url used to report a server's status
-     */
-    private static final String REPORT_URL = "/report/%s";
-    /**
-     * The separator to use for custom data. This MUST NOT change unless you are hosting your own version of metrics and
-     * want to change it.
-     */
-    private static final String CUSTOM_DATA_SEPARATOR = "~~";
-    /**
-     * Interval of time to ping (in minutes)
-     */
-    private static final int PING_INTERVAL = 10;
-    /**
-     * All of the custom graphs to submit to metrics
-     */
-    private final Set<Graph> graphs = Collections.synchronizedSet(new HashSet<Graph>());
-    /**
-     * The default graph, used for addCustomData when you don't want a specific graph
-     */
-    private final Graph defaultGraph = new Graph("Default");
-    /**
-     * The plugin configuration file
-     */
-    private final YamlConfiguration configuration;
-    /**
-     * The plugin configuration file
-     */
-    private final File configurationFile;
-    /**
-     * Unique server id
-     */
-    private final String guid;
-    /**
-     * Debug mode
-     */
-    private final boolean debug;
-    /**
-     * Lock for synchronization
-     */
-    private final Object optOutLock = new Object();
-    /**
-     * The scheduled task
-     */
-    private volatile Timer task = null;
-
-    public Metrics() throws IOException {
-        // load the config
-        configurationFile = getConfigFile();
-        configuration = YamlConfiguration.loadConfiguration(configurationFile);
-
-        // add some defaults
-        configuration.addDefault("opt-out", false);
-        configuration.addDefault("guid", UUID.randomUUID().toString());
-        configuration.addDefault("debug", false);
-
-        // Do we need to create the file?
-        if (configuration.get("guid", null) == null) {
-            configuration.options().header("http://mcstats.org").copyDefaults(true);
-            configuration.save(configurationFile);
-        }
-
-        // Load the guid then
-        guid = configuration.getString("guid");
-        debug = configuration.getBoolean("debug", false);
-    }
-
-    /**
-     * Construct and create a Graph that can be used to separate specific plotters to their own graphs on the metrics
-     * website. Plotters can be added to the graph object returned.
-     *
-     * @param name The name of the graph
-     * @return Graph object created. Will never return NULL under normal circumstances unless bad parameters are given
-     */
-    public Graph createGraph(final String name) {
-        if (name == null) {
-            throw new IllegalArgumentException("Graph name cannot be null");
-        }
-
-        // Construct the graph object
-        final Graph graph = new Graph(name);
-
-        // Now we can add our graph
-        graphs.add(graph);
-
-        // and return back
-        return graph;
-    }
-
-    /**
-     * Add a Graph object to BukkitMetrics that represents data for the plugin that should be sent to the backend
-     *
-     * @param graph The name of the graph
-     */
-    public void addGraph(final Graph graph) {
-        if (graph == null) {
-            throw new IllegalArgumentException("Graph cannot be null");
-        }
-
-        graphs.add(graph);
-    }
-
-    /**
-     * Adds a custom data plotter to the default graph
-     *
-     * @param plotter The plotter to use to plot custom data
-     */
-    public void addCustomData(final Plotter plotter) {
-        if (plotter == null) {
-            throw new IllegalArgumentException("Plotter cannot be null");
-        }
-
-        // Add the plotter to the graph o/
-        defaultGraph.addPlotter(plotter);
-
-        // Ensure the default graph is included in the submitted graphs
-        graphs.add(defaultGraph);
-    }
-
-    /**
-     * Start measuring statistics. This will immediately create an async repeating task as the plugin and send the
-     * initial data to the metrics backend, and then after that it will post in increments of PING_INTERVAL * 1200
-     * ticks.
-     *
-     * @return True if statistics measuring is running, otherwise false.
-     */
-    public boolean start() {
-        synchronized (optOutLock) {
-            // Did we opt out?
-            if (isOptOut()) {
-                return false;
-            }
-
-            // Is metrics already running?
-            if (task != null) {
-                return true;
-            }
-
-            // Begin hitting the server with glorious data
-            task = new Timer("Spigot Metrics Thread", true);
-
-            task.scheduleAtFixedRate(new TimerTask() {
-                private boolean firstPost = true;
-
-                public void run() {
-                    try {
-                        // This has to be synchronized or it can collide with the disable method.
-                        synchronized (optOutLock) {
-                            // Disable Task, if it is running and the server owner decided to opt-out
-                            if (isOptOut() && task != null) {
-                                task.cancel();
-                                task = null;
-                                // Tell all plotters to stop gathering information.
-                                for (Graph graph : graphs) {
-                                    graph.onOptOut();
-                                }
-                            }
-                        }
-
-                        // We use the inverse of firstPost because if it is the first time we are posting,
-                        // it is not a interval ping, so it evaluates to FALSE
-                        // Each time thereafter it will evaluate to TRUE, i.e PING!
-                        postPlugin(!firstPost);
-
-                        // After the first post we set firstPost to false
-                        // Each post thereafter will be a ping
-                        firstPost = false;
-                    } catch (IOException e) {
-                        if (debug) {
-                            Bukkit.getLogger().log(Level.INFO, "[Metrics] " + e.getMessage());
-                        }
-                    }
-                }
-            }, 0, TimeUnit.MINUTES.toMillis(PING_INTERVAL));
-
-            return true;
-        }
-    }
-
-    /**
-     * Has the server owner denied plugin metrics?
-     *
-     * @return true if metrics should be opted out of it
-     */
-    public boolean isOptOut() {
-        synchronized (optOutLock) {
-            try {
-                // Reload the metrics file
-                configuration.load(getConfigFile());
-            } catch (IOException ex) {
-                if (debug) {
-                    Bukkit.getLogger().log(Level.INFO, "[Metrics] " + ex.getMessage());
-                }
-                return true;
-            } catch (InvalidConfigurationException ex) {
-                if (debug) {
-                    Bukkit.getLogger().log(Level.INFO, "[Metrics] " + ex.getMessage());
-                }
-                return true;
-            }
-            return configuration.getBoolean("opt-out", false);
-        }
-    }
-
-    /**
-     * Enables metrics for the server by setting "opt-out" to false in the config file and starting the metrics task.
-     *
-     * @throws java.io.IOException
-     */
-    public void enable() throws IOException {
-        // This has to be synchronized or it can collide with the check in the task.
-        synchronized (optOutLock) {
-            // Check if the server owner has already set opt-out, if not, set it.
-            if (isOptOut()) {
-                configuration.set("opt-out", false);
-                configuration.save(configurationFile);
-            }
-
-            // Enable Task, if it is not running
-            if (task == null) {
-                start();
-            }
-        }
-    }
-
-    /**
-     * Disables metrics for the server by setting "opt-out" to true in the config file and canceling the metrics task.
-     *
-     * @throws java.io.IOException
-     */
-    public void disable() throws IOException {
-        // This has to be synchronized or it can collide with the check in the task.
-        synchronized (optOutLock) {
-            // Check if the server owner has already set opt-out, if not, set it.
-            if (!isOptOut()) {
-                configuration.set("opt-out", true);
-                configuration.save(configurationFile);
-            }
-
-            // Disable Task, if it is running
-            if (task != null) {
-                task.cancel();
-                task = null;
-            }
-        }
-    }
-
-    /**
-     * Gets the File object of the config file that should be used to store data such as the GUID and opt-out status
-     *
-     * @return the File object for the config file
-     */
-    public File getConfigFile() {
-        // I believe the easiest way to get the base folder (e.g craftbukkit set via -P) for plugins to use
-        // is to abuse the plugin object we already have
-        // plugin.getDataFolder() => base/plugins/PluginA/
-        // pluginsFolder => base/plugins/
-        // The base is not necessarily relative to the startup directory.
-        // File pluginsFolder = plugin.getDataFolder().getParentFile();
-
-        // return => base/plugins/PluginMetrics/config.yml
-        return new File(new File((File) MinecraftServer.getServer().options.valueOf("plugins"), "PluginMetrics"), "config.yml");
-    }
-
-    /**
-     * Generic method that posts a plugin to the metrics website
-     */
-    private void postPlugin(final boolean isPing) throws IOException {
-        // Server software specific section
-        String pluginName = "Spigot";
-        boolean onlineMode = Bukkit.getServer().getOnlineMode(); // TRUE if online mode is enabled
-        String pluginVersion = (Metrics.class.getPackage().getImplementationVersion() != null) ? Metrics.class.getPackage().getImplementationVersion() : "unknown";
-        String serverVersion = Bukkit.getVersion();
-        int playersOnline = Bukkit.getServer().getOnlinePlayers().size();
-
-        // END server software specific section -- all code below does not use any code outside of this class / Java
-
-        // Construct the post data
-        final StringBuilder data = new StringBuilder();
-
-        // The plugin's description file containg all of the plugin data such as name, version, author, etc
-        data.append(encode("guid")).append('=').append(encode(guid));
-        encodeDataPair(data, "version", pluginVersion);
-        encodeDataPair(data, "server", serverVersion);
-        encodeDataPair(data, "players", Integer.toString(playersOnline));
-        encodeDataPair(data, "revision", String.valueOf(REVISION));
-
-        // New data as of R6
-        String osname = System.getProperty("os.name");
-        String osarch = System.getProperty("os.arch");
-        String osversion = System.getProperty("os.version");
-        String java_version = System.getProperty("java.version");
-        int coreCount = Runtime.getRuntime().availableProcessors();
-
-        // normalize os arch .. amd64 -> x86_64
-        if (osarch.equals("amd64")) {
-            osarch = "x86_64";
-        }
-
-        encodeDataPair(data, "osname", osname);
-        encodeDataPair(data, "osarch", osarch);
-        encodeDataPair(data, "osversion", osversion);
-        encodeDataPair(data, "cores", Integer.toString(coreCount));
-        encodeDataPair(data, "online-mode", Boolean.toString(onlineMode));
-        encodeDataPair(data, "java_version", java_version);
-
-        // If we're pinging, append it
-        if (isPing) {
-            encodeDataPair(data, "ping", "true");
-        }
-
-        // Acquire a lock on the graphs, which lets us make the assumption we also lock everything
-        // inside of the graph (e.g plotters)
-        synchronized (graphs) {
-            final Iterator<Graph> iter = graphs.iterator();
-
-            while (iter.hasNext()) {
-                final Graph graph = iter.next();
-
-                for (Plotter plotter : graph.getPlotters()) {
-                    // The key name to send to the metrics server
-                    // The format is C-GRAPHNAME-PLOTTERNAME where separator - is defined at the top
-                    // Legacy (R4) submitters use the format Custom%s, or CustomPLOTTERNAME
-                    final String key = String.format("C%s%s%s%s", CUSTOM_DATA_SEPARATOR, graph.getName(), CUSTOM_DATA_SEPARATOR, plotter.getColumnName());
-
-                    // The value to send, which for the foreseeable future is just the string
-                    // value of plotter.getValue()
-                    final String value = Integer.toString(plotter.getValue());
-
-                    // Add it to the http post data :)
-                    encodeDataPair(data, key, value);
-                }
-            }
-        }
-
-        // Create the url
-        URL url = new URL(BASE_URL + String.format(REPORT_URL, encode(pluginName)));
-
-        // Connect to the website
-        URLConnection connection;
-
-        // Mineshafter creates a socks proxy, so we can safely bypass it
-        // It does not reroute POST requests so we need to go around it
-        if (isMineshafterPresent()) {
-            connection = url.openConnection(Proxy.NO_PROXY);
-        } else {
-            connection = url.openConnection();
-        }
-
-        connection.setDoOutput(true);
-
-        // Write the data
-        final OutputStreamWriter writer = new OutputStreamWriter(connection.getOutputStream());
-        writer.write(data.toString());
-        writer.flush();
-
-        // Now read the response
-        final BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
-        final String response = reader.readLine();
-
-        // close resources
-        writer.close();
-        reader.close();
-
-        if (response == null || response.startsWith("ERR")) {
-            throw new IOException(response); //Throw the exception
-        } else {
-            // Is this the first update this hour?
-            if (response.contains("OK This is your first update this hour")) {
-                synchronized (graphs) {
-                    final Iterator<Graph> iter = graphs.iterator();
-
-                    while (iter.hasNext()) {
-                        final Graph graph = iter.next();
-
-                        for (Plotter plotter : graph.getPlotters()) {
-                            plotter.reset();
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    /**
-     * Check if mineshafter is present. If it is, we need to bypass it to send POST requests
-     *
-     * @return true if mineshafter is installed on the server
-     */
-    private boolean isMineshafterPresent() {
-        try {
-            Class.forName("mineshafter.MineServer");
-            return true;
-        } catch (Exception e) {
-            return false;
-        }
-    }
-
-    /**
-     * <p>Encode a key/value data pair to be used in a HTTP post request. This INCLUDES a & so the first key/value pair
-     * MUST be included manually, e.g:</p>
-     * <code>
-     * StringBuffer data = new StringBuffer();
-     * data.append(encode("guid")).append('=').append(encode(guid));
-     * encodeDataPair(data, "version", description.getVersion());
-     * </code>
-     *
-     * @param buffer the stringbuilder to append the data pair onto
-     * @param key the key value
-     * @param value the value
-     */
-    private static void encodeDataPair(final StringBuilder buffer, final String key, final String value) throws UnsupportedEncodingException {
-        buffer.append('&').append(encode(key)).append('=').append(encode(value));
-    }
-
-    /**
-     * Encode text as UTF-8
-     *
-     * @param text the text to encode
-     * @return the encoded text, as UTF-8
-     */
-    private static String encode(final String text) throws UnsupportedEncodingException {
-        return URLEncoder.encode(text, "UTF-8");
-    }
-
-    /**
-     * Represents a custom graph on the website
-     */
-    public static class Graph {
-
-        /**
-         * The graph's name, alphanumeric and spaces only :) If it does not comply to the above when submitted, it is
-         * rejected
-         */
-        private final String name;
-        /**
-         * The set of plotters that are contained within this graph
-         */
-        private final Set<Plotter> plotters = new LinkedHashSet<Plotter>();
-
-        private Graph(final String name) {
-            this.name = name;
-        }
-
-        /**
-         * Gets the graph's name
-         *
-         * @return the Graph's name
-         */
-        public String getName() {
-            return name;
-        }
-
-        /**
-         * Add a plotter to the graph, which will be used to plot entries
-         *
-         * @param plotter the plotter to add to the graph
-         */
-        public void addPlotter(final Plotter plotter) {
-            plotters.add(plotter);
-        }
-
-        /**
-         * Remove a plotter from the graph
-         *
-         * @param plotter the plotter to remove from the graph
-         */
-        public void removePlotter(final Plotter plotter) {
-            plotters.remove(plotter);
-        }
-
-        /**
-         * Gets an <b>unmodifiable</b> set of the plotter objects in the graph
-         *
-         * @return an unmodifiable {@link java.util.Set} of the plotter objects
-         */
-        public Set<Plotter> getPlotters() {
-            return Collections.unmodifiableSet(plotters);
-        }
-
-        @Override
-        public int hashCode() {
-            return name.hashCode();
-        }
-
-        @Override
-        public boolean equals(final Object object) {
-            if (!(object instanceof Graph)) {
-                return false;
-            }
-
-            final Graph graph = (Graph) object;
-            return graph.name.equals(name);
-        }
-
-        /**
-         * Called when the server owner decides to opt-out of BukkitMetrics while the server is running.
-         */
-        protected void onOptOut() {
-        }
-    }
-
-    /**
-     * Interface used to collect custom data for a plugin
-     */
-    public abstract static class Plotter {
-
-        /**
-         * The plot's name
-         */
-        private final String name;
-
-        /**
-         * Construct a plotter with the default plot name
-         */
-        public Plotter() {
-            this("Default");
-        }
-
-        /**
-         * Construct a plotter with a specific plot name
-         *
-         * @param name the name of the plotter to use, which will show up on the website
-         */
-        public Plotter(final String name) {
-            this.name = name;
-        }
-
-        /**
-         * Get the current value for the plotted point. Since this function defers to an external function it may or may
-         * not return immediately thus cannot be guaranteed to be thread friendly or safe. This function can be called
-         * from any thread so care should be taken when accessing resources that need to be synchronized.
-         *
-         * @return the current value for the point to be plotted.
-         */
-        public abstract int getValue();
-
-        /**
-         * Get the column name for the plotted point
-         *
-         * @return the plotted point's column name
-         */
-        public String getColumnName() {
-            return name;
-        }
-
-        /**
-         * Called after the website graphs have been updated
-         */
-        public void reset() {
-        }
-
-        @Override
-        public int hashCode() {
-            return getColumnName().hashCode();
-        }
-
-        @Override
-        public boolean equals(final Object object) {
-            if (!(object instanceof Plotter)) {
-                return false;
-            }
-
-            final Plotter plotter = (Plotter) object;
-            return plotter.name.equals(name) && plotter.getValue() == getValue();
-        }
-    }
-}
diff --git a/src/main/java/org/spigotmc/SpigotConfig.java b/src/main/java/org/spigotmc/SpigotConfig.java
index 564285c1c96f3faf99022eec639dbefed54f2a7d..98e39650db7f8f1ee7cd20e05242fd79c94560fc 100644
--- a/src/main/java/org/spigotmc/SpigotConfig.java
+++ b/src/main/java/org/spigotmc/SpigotConfig.java
@@ -48,7 +48,6 @@ public class SpigotConfig
     static int version;
     static Map<String, Command> commands;
     /*========================================================================*/
-    private static Metrics metrics;
 
     public static void init(File configFile)
     {
