From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: xVorttex <sigamatute@gmail.com>
Date: Sat, 28 Sep 2024 23:58:02 +0300
Subject: [PATCH] Paper plugin management


diff --git a/pom.xml b/pom.xml
index 60827eacbb9bcd6d05ae2966777ca1b9dc2bffe0..d787d21fa2d20edc9229d3bc26ca4910d62587fe 100644
--- a/pom.xml
+++ b/pom.xml
@@ -103,6 +103,12 @@
             <scope>compile</scope>
         </dependency>
 
+        <dependency>
+            <groupId>org.spongepowered</groupId>
+            <artifactId>configurate-yaml</artifactId>
+            <version>4.2.0-SNAPSHOT</version>
+        </dependency>
+
         <!-- Paper - Async loggers -->
         <dependency>
             <groupId>com.lmax</groupId>
@@ -180,15 +186,15 @@
 
         <!-- testing -->
         <dependency>
-            <groupId>junit</groupId>
-            <artifactId>junit</artifactId>
-            <version>4.13.1</version>
+            <groupId>org.junit.jupiter</groupId>
+            <artifactId>junit-jupiter</artifactId>
+            <version>5.10.2</version>
             <scope>test</scope>
         </dependency>
         <dependency>
             <groupId>org.hamcrest</groupId>
             <artifactId>hamcrest-library</artifactId>
-            <version>1.3</version>
+            <version>2.2</version>
             <scope>test</scope>
         </dependency>
         <!-- for vanilla goal scanning -->
diff --git a/src/main/java/io/papermc/paper/configuration/Configuration.java b/src/main/java/io/papermc/paper/configuration/Configuration.java
new file mode 100644
index 0000000000000000000000000000000000000000..817fd26cc3591f9cae0f61f4036dde43c4ed60e8
--- /dev/null
+++ b/src/main/java/io/papermc/paper/configuration/Configuration.java
@@ -0,0 +1,13 @@
+package io.papermc.paper.configuration;
+
+public final class Configuration {
+    public static final String VERSION_FIELD = "_version";
+    @Deprecated
+    public static final String LEGACY_CONFIG_VERSION_FIELD = "config-version";
+
+    @Deprecated
+    public static final int FINAL_LEGACY_VERSION = 27;
+
+    private Configuration() {
+    }
+}
diff --git a/src/main/java/io/papermc/paper/configuration/ConfigurationLoaders.java b/src/main/java/io/papermc/paper/configuration/ConfigurationLoaders.java
new file mode 100644
index 0000000000000000000000000000000000000000..05758f22adac93a73099402899b180ea4c9ca44a
--- /dev/null
+++ b/src/main/java/io/papermc/paper/configuration/ConfigurationLoaders.java
@@ -0,0 +1,28 @@
+package io.papermc.paper.configuration;
+
+import org.spongepowered.configurate.loader.HeaderMode;
+import org.spongepowered.configurate.util.MapFactories;
+import org.spongepowered.configurate.yaml.NodeStyle;
+import org.spongepowered.configurate.yaml.YamlConfigurationLoader;
+
+import java.nio.file.Path;
+
+public final class ConfigurationLoaders {
+    private ConfigurationLoaders() {
+    }
+
+    public static YamlConfigurationLoader.Builder naturallySorted() {
+        return YamlConfigurationLoader.builder()
+            .indent(2)
+            .nodeStyle(NodeStyle.BLOCK)
+            .headerMode(HeaderMode.PRESET)
+            .defaultOptions(options -> options.mapFactory(MapFactories.sortedNatural()));
+    }
+
+    public static YamlConfigurationLoader naturallySortedWithoutHeader(final Path path) {
+        return naturallySorted()
+            .headerMode(HeaderMode.NONE)
+            .path(path)
+            .build();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/configuration/ConfigurationPart.java b/src/main/java/io/papermc/paper/configuration/ConfigurationPart.java
new file mode 100644
index 0000000000000000000000000000000000000000..042478cf7ce150f1f1bc5cddd7fa40f86ec773dd
--- /dev/null
+++ b/src/main/java/io/papermc/paper/configuration/ConfigurationPart.java
@@ -0,0 +1,7 @@
+package io.papermc.paper.configuration;
+
+/**
+ * Marker interface for unique sections of a configuration.
+ */
+public abstract class ConfigurationPart {
+}
diff --git a/src/main/java/io/papermc/paper/configuration/NestedSetting.java b/src/main/java/io/papermc/paper/configuration/NestedSetting.java
new file mode 100644
index 0000000000000000000000000000000000000000..091c9649f1c335e830282b8675a1867e2d816c5d
--- /dev/null
+++ b/src/main/java/io/papermc/paper/configuration/NestedSetting.java
@@ -0,0 +1,28 @@
+package io.papermc.paper.configuration;
+
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.spongepowered.configurate.objectmapping.meta.NodeResolver;
+
+import java.lang.annotation.*;
+import java.lang.reflect.AnnotatedElement;
+
+@Documented
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface NestedSetting {
+
+    String[] value();
+
+    class Factory implements NodeResolver.Factory {
+        @Override
+        public @Nullable NodeResolver make(String name, AnnotatedElement element) {
+            if (element.isAnnotationPresent(NestedSetting.class)) {
+                Object[] path = element.getAnnotation(NestedSetting.class).value();
+                if (path.length > 0) {
+                    return node -> node.node(path);
+                }
+            }
+            return null;
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/configuration/constraint/Constraint.java b/src/main/java/io/papermc/paper/configuration/constraint/Constraint.java
new file mode 100644
index 0000000000000000000000000000000000000000..ef5baaf3d5d7ef4da76f9d9f0ca763da215603b1
--- /dev/null
+++ b/src/main/java/io/papermc/paper/configuration/constraint/Constraint.java
@@ -0,0 +1,26 @@
+package io.papermc.paper.configuration.constraint;
+
+import java.lang.annotation.*;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Type;
+
+@Documented
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ElementType.FIELD, ElementType.TYPE, ElementType.PARAMETER})
+public @interface Constraint {
+    Class<? extends org.spongepowered.configurate.objectmapping.meta.Constraint<?>> value();
+
+    class Factory implements org.spongepowered.configurate.objectmapping.meta.Constraint.Factory<Constraint, Object> {
+        @SuppressWarnings("unchecked")
+        @Override
+        public org.spongepowered.configurate.objectmapping.meta.Constraint<Object> make(final Constraint data, final Type type) {
+            try {
+                final Constructor<? extends org.spongepowered.configurate.objectmapping.meta.Constraint<?>> constructor = data.value().getDeclaredConstructor();
+                constructor.trySetAccessible();
+                return (org.spongepowered.configurate.objectmapping.meta.Constraint<Object>) constructor.newInstance();
+            } catch (final ReflectiveOperationException e) {
+                throw new RuntimeException("Could not create constraint", e);
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/configuration/constraint/Constraints.java b/src/main/java/io/papermc/paper/configuration/constraint/Constraints.java
new file mode 100644
index 0000000000000000000000000000000000000000..993632b6bbfe5e151c3d7323e1bce002752f17d0
--- /dev/null
+++ b/src/main/java/io/papermc/paper/configuration/constraint/Constraints.java
@@ -0,0 +1,41 @@
+package io.papermc.paper.configuration.constraint;
+
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.spongepowered.configurate.objectmapping.meta.Constraint;
+import org.spongepowered.configurate.serialize.SerializationException;
+import org.spongepowered.configurate.serialize.SerializationException;
+
+import java.lang.annotation.*;
+import java.lang.reflect.Type;
+
+public final class Constraints {
+    private Constraints() {
+    }
+
+    public static final class Positive implements Constraint<Number> {
+        @Override
+        public void validate(@Nullable Number value) throws SerializationException {
+            if (value != null && value.doubleValue() <= 0) {
+                throw new SerializationException(value + " should be positive");
+            }
+        }
+    }
+
+    @Documented
+    @Retention(RetentionPolicy.RUNTIME)
+    @Target(ElementType.FIELD)
+    public @interface Min {
+        int value();
+
+        final class Factory implements Constraint.Factory<Min, Number> {
+            @Override
+            public Constraint<Number> make(Min data, Type type) {
+                return value -> {
+                    if (value != null && value.intValue() < data.value()) {
+                        throw new SerializationException(value + " is less than the min " + data.value());
+                    }
+                };
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/configuration/mapping/InnerClassFieldDiscoverer.java b/src/main/java/io/papermc/paper/configuration/mapping/InnerClassFieldDiscoverer.java
new file mode 100644
index 0000000000000000000000000000000000000000..04bb73b9bb9d30eed4a316dddc7f40342d1b0caa
--- /dev/null
+++ b/src/main/java/io/papermc/paper/configuration/mapping/InnerClassFieldDiscoverer.java
@@ -0,0 +1,45 @@
+package io.papermc.paper.configuration.mapping;
+
+import io.papermc.paper.configuration.ConfigurationPart;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.spongepowered.configurate.objectmapping.FieldDiscoverer;
+import org.spongepowered.configurate.serialize.SerializationException;
+
+import java.lang.reflect.AnnotatedType;
+import java.lang.reflect.Field;
+import java.util.Collections;
+import java.util.Map;
+
+import static io.leangen.geantyref.GenericTypeReflector.erase;
+
+public final class InnerClassFieldDiscoverer implements FieldDiscoverer<Map<Field, Object>> {
+
+    private final InnerClassInstanceSupplier instanceSupplier;
+    private final FieldDiscoverer<Map<Field, Object>> delegate;
+
+    @SuppressWarnings("unchecked")
+    public InnerClassFieldDiscoverer(final Map<Class<?>, Object> initialOverrides) {
+        this.instanceSupplier = new InnerClassInstanceSupplier(initialOverrides);
+        this.delegate = (FieldDiscoverer<Map<Field, Object>>) FieldDiscoverer.object(this.instanceSupplier);
+    }
+
+    @Override
+    public @Nullable <V> InstanceFactory<Map<Field, Object>> discover(final AnnotatedType target, final FieldCollector<Map<Field, Object>, V> collector) throws SerializationException {
+        final Class<?> clazz = erase(target.getType());
+        if (ConfigurationPart.class.isAssignableFrom(clazz)) {
+            final FieldDiscoverer.@Nullable InstanceFactory<Map<Field, Object>> instanceFactoryDelegate = this.delegate.<V>discover(target, (name, type, annotations, deserializer, serializer) -> {
+                if (!erase(type.getType()).equals(clazz.getEnclosingClass())) { // don't collect synth fields for inner classes
+                    collector.accept(name, type, annotations, deserializer, serializer);
+                }
+            });
+            if (instanceFactoryDelegate instanceof MutableInstanceFactory<Map<Field, Object>> mutableInstanceFactoryDelegate) {
+                return new InnerClassInstanceFactory(this.instanceSupplier, mutableInstanceFactoryDelegate, target);
+            }
+        }
+        return null;
+    }
+
+    public static FieldDiscoverer<?> globalConfig() {
+        return new InnerClassFieldDiscoverer(Collections.emptyMap());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/configuration/mapping/InnerClassInstanceFactory.java b/src/main/java/io/papermc/paper/configuration/mapping/InnerClassInstanceFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..8beac5cb0b71140b42015cf68f1b52afe8d43d62
--- /dev/null
+++ b/src/main/java/io/papermc/paper/configuration/mapping/InnerClassInstanceFactory.java
@@ -0,0 +1,66 @@
+package io.papermc.paper.configuration.mapping;
+
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.spongepowered.configurate.objectmapping.FieldDiscoverer;
+import org.spongepowered.configurate.serialize.SerializationException;
+
+import java.lang.reflect.AnnotatedType;
+import java.lang.reflect.Field;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Objects;
+
+import static io.leangen.geantyref.GenericTypeReflector.erase;
+
+final class InnerClassInstanceFactory implements FieldDiscoverer.MutableInstanceFactory<Map<Field, Object>> {
+
+    private final InnerClassInstanceSupplier instanceSupplier;
+    private final FieldDiscoverer.MutableInstanceFactory<Map<Field, Object>> fallback;
+    private final AnnotatedType targetType;
+
+    InnerClassInstanceFactory(final InnerClassInstanceSupplier instanceSupplier, final FieldDiscoverer.MutableInstanceFactory<Map<Field, Object>> fallback, final AnnotatedType targetType) {
+        this.instanceSupplier = instanceSupplier;
+        this.fallback = fallback;
+        this.targetType = targetType;
+    }
+
+    @Override
+    public Map<Field, Object> begin() {
+        return this.fallback.begin();
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public void complete(final Object instance, final Map<Field, Object> intermediate) throws SerializationException {
+        final Iterator<Map.Entry<Field, Object>> iter = intermediate.entrySet().iterator();
+        try {
+            while (iter.hasNext()) { // manually merge any mergeable maps
+                Map.Entry<Field, Object> entry = iter.next();
+                if (entry.getKey().isAnnotationPresent(MergeMap.class) && Map.class.isAssignableFrom(entry.getKey().getType()) && intermediate.get(entry.getKey()) instanceof Map<?, ?> map) {
+                    iter.remove();
+                    @Nullable Map<Object, Object> existingMap = (Map<Object, Object>) entry.getKey().get(instance);
+                    if (existingMap != null) {
+                        existingMap.putAll(map);
+                    } else {
+                        entry.getKey().set(instance, entry.getValue());
+                    }
+                }
+            }
+        } catch (final IllegalAccessException e) {
+            throw new SerializationException(this.targetType.getType(), e);
+        }
+        this.fallback.complete(instance, intermediate);
+    }
+
+    @Override
+    public Object complete(final Map<Field, Object> intermediate) throws SerializationException {
+        final Object targetInstance = Objects.requireNonNull(this.instanceSupplier.instanceMap().get(erase(this.targetType.getType())), () -> this.targetType.getType() + " must already have an instance created");
+        this.complete(targetInstance, intermediate);
+        return targetInstance;
+    }
+
+    @Override
+    public boolean canCreateInstances() {
+        return this.fallback.canCreateInstances();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/configuration/mapping/InnerClassInstanceSupplier.java b/src/main/java/io/papermc/paper/configuration/mapping/InnerClassInstanceSupplier.java
new file mode 100644
index 0000000000000000000000000000000000000000..ab11d14ed9904c3ef32ea10c91ca27663b7bf7c5
--- /dev/null
+++ b/src/main/java/io/papermc/paper/configuration/mapping/InnerClassInstanceSupplier.java
@@ -0,0 +1,73 @@
+package io.papermc.paper.configuration.mapping;
+
+import io.papermc.paper.configuration.ConfigurationPart;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.spongepowered.configurate.serialize.SerializationException;
+import org.spongepowered.configurate.util.CheckedFunction;
+import org.spongepowered.configurate.util.CheckedSupplier;
+
+import java.lang.reflect.AnnotatedType;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Modifier;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.Supplier;
+
+import static io.leangen.geantyref.GenericTypeReflector.erase;
+
+/**
+ * This instance factory handles creating non-static inner classes by tracking all instances of objects that extend
+ * {@link ConfigurationPart}. Only 1 instance of each {@link ConfigurationPart} should be present for each instance
+ * of the field discoverer this is used in.
+ */
+final class InnerClassInstanceSupplier implements CheckedFunction<AnnotatedType, @Nullable Supplier<Object>, SerializationException> {
+
+    private final Map<Class<?>, Object> instanceMap = new HashMap<>();
+    private final Map<Class<?>, Object> initialOverrides;
+
+    /**
+     * @param initialOverrides map of types to objects to preload the config objects with.
+     */
+    InnerClassInstanceSupplier(final Map<Class<?>, Object> initialOverrides) {
+        this.initialOverrides = initialOverrides;
+    }
+
+    @Override
+    public Supplier<Object> apply(final AnnotatedType target) throws SerializationException {
+        final Class<?> type = erase(target.getType());
+        if (this.initialOverrides.containsKey(type)) {
+            this.instanceMap.put(type, this.initialOverrides.get(type));
+            return () -> this.initialOverrides.get(type);
+        }
+        if (ConfigurationPart.class.isAssignableFrom(type) && !this.instanceMap.containsKey(type)) {
+            try {
+                final Constructor<?> constructor;
+                final CheckedSupplier<Object, ReflectiveOperationException> instanceSupplier;
+                if (type.getEnclosingClass() != null && !Modifier.isStatic(type.getModifiers())) {
+                    final @Nullable Object instance = this.instanceMap.get(type.getEnclosingClass());
+                    if (instance == null) {
+                        throw new SerializationException("Cannot create a new instance of an inner class " + type.getName() + " without an instance of its enclosing class " + type.getEnclosingClass().getName());
+                    }
+                    constructor = type.getDeclaredConstructor(type.getEnclosingClass());
+                    instanceSupplier = () -> constructor.newInstance(instance);
+                } else {
+                    constructor = type.getDeclaredConstructor();
+                    instanceSupplier = constructor::newInstance;
+                }
+                constructor.setAccessible(true);
+                final Object instance = instanceSupplier.get();
+                this.instanceMap.put(type, instance);
+                return () -> instance;
+            } catch (ReflectiveOperationException e) {
+                throw new SerializationException(ConfigurationPart.class, target + " must be a valid ConfigurationPart", e);
+            }
+        } else {
+            throw new SerializationException(target + " must be a valid ConfigurationPart");
+        }
+    }
+
+    Map<Class<?>, Object> instanceMap() {
+        return this.instanceMap;
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/configuration/mapping/MergeMap.java b/src/main/java/io/papermc/paper/configuration/mapping/MergeMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..0321a2c60f6069135194456fd928d3307b20f6a4
--- /dev/null
+++ b/src/main/java/io/papermc/paper/configuration/mapping/MergeMap.java
@@ -0,0 +1,17 @@
+package io.papermc.paper.configuration.mapping;
+
+import io.papermc.paper.configuration.ConfigurationPart;
+
+import java.lang.annotation.*;
+
+/**
+ * For use in maps inside {@link ConfigurationPart}s that have default keys that shouldn't be removed by users
+ * <p>
+ * Note that when the config is reloaded, the maps will be merged again, so make sure this map can't accumulate
+ * keys overtime.
+ */
+@Documented
+@Target(ElementType.FIELD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface MergeMap {
+}
diff --git a/src/main/java/io/papermc/paper/configuration/package-info.java b/src/main/java/io/papermc/paper/configuration/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..4e3bcd7c478096384fcc643d48771ab94318deb3
--- /dev/null
+++ b/src/main/java/io/papermc/paper/configuration/package-info.java
@@ -0,0 +1,5 @@
+@DefaultQualifier(NonNull.class)
+package io.papermc.paper.configuration;
+
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
\ No newline at end of file
diff --git a/src/main/java/io/papermc/paper/configuration/serializer/EnumValueSerializer.java b/src/main/java/io/papermc/paper/configuration/serializer/EnumValueSerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..f4df926f5633be0c7d712ae42fe43a5e8e8c205c
--- /dev/null
+++ b/src/main/java/io/papermc/paper/configuration/serializer/EnumValueSerializer.java
@@ -0,0 +1,47 @@
+package io.papermc.paper.configuration.serializer;
+
+import io.leangen.geantyref.TypeToken;
+import net.minecraft.server.MinecraftServer;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.spongepowered.configurate.serialize.ScalarSerializer;
+import org.spongepowered.configurate.serialize.SerializationException;
+import org.spongepowered.configurate.util.EnumLookup;
+
+import java.lang.reflect.Type;
+import java.util.Arrays;
+import java.util.List;
+import java.util.function.Predicate;
+
+import static io.leangen.geantyref.GenericTypeReflector.erase;
+
+/**
+ * Enum serializer that lists options if fails and accepts `-` as `_`.
+ */
+public class EnumValueSerializer extends ScalarSerializer<Enum<?>> {
+
+    public EnumValueSerializer() {
+        super(new TypeToken<Enum<?>>() {});
+    }
+
+    @SuppressWarnings({"rawtypes", "unchecked"})
+    @Override
+    public @Nullable Enum<?> deserialize(final Type type, final Object obj) throws SerializationException {
+        final String enumConstant = obj.toString();
+        final Class<? extends Enum> typeClass = erase(type).asSubclass(Enum.class);
+        @Nullable Enum<?> ret = EnumLookup.lookupEnum(typeClass, enumConstant);
+        if (ret == null) {
+            ret = EnumLookup.lookupEnum(typeClass, enumConstant.replace("-", "_"));
+        }
+        if (ret == null) {
+            boolean longer = typeClass.getEnumConstants().length > 10;
+            List<String> options = Arrays.stream(typeClass.getEnumConstants()).limit(10L).map(Enum::name).toList();
+            MinecraftServer.LOGGER.error("Invalid enum constant provided, expected one of [" + String.join(", " ,options) + (longer ? ", ..." : "") + "], but got " + enumConstant);
+        }
+        return ret;
+    }
+
+    @Override
+    public Object serialize(final Enum<?> item, final Predicate<Class<?>> typeSupported) {
+        return item.name();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/configuration/serializer/collections/FastutilMapSerializer.java b/src/main/java/io/papermc/paper/configuration/serializer/collections/FastutilMapSerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..4af710e144b70933d750c22edfe484c18e4a3540
--- /dev/null
+++ b/src/main/java/io/papermc/paper/configuration/serializer/collections/FastutilMapSerializer.java
@@ -0,0 +1,69 @@
+package io.papermc.paper.configuration.serializer.collections;
+
+import io.leangen.geantyref.GenericTypeReflector;
+import io.leangen.geantyref.TypeFactory;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.spongepowered.configurate.ConfigurationNode;
+import org.spongepowered.configurate.serialize.SerializationException;
+import org.spongepowered.configurate.serialize.TypeSerializer;
+
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.Collections;
+import java.util.Map;
+import java.util.function.Function;
+
+@SuppressWarnings("rawtypes")
+public abstract class FastutilMapSerializer<M extends Map<?, ?>> implements TypeSerializer<M> {
+    private final Function<Map, ? extends M> factory;
+
+    protected FastutilMapSerializer(final Function<Map, ? extends M> factory) {
+        this.factory = factory;
+    }
+
+    @Override
+    public M deserialize(final Type type, final ConfigurationNode node) throws SerializationException {
+        @Nullable final Map map = (Map) node.get(this.createBaseMapType((ParameterizedType) type));
+        return this.factory.apply(map == null ? Collections.emptyMap() : map);
+    }
+
+    @Override
+    public void serialize(final Type type, @Nullable final M obj, final ConfigurationNode node) throws SerializationException {
+        if (obj == null || obj.isEmpty()) {
+            node.raw(null);
+        } else {
+            final Type baseMapType = this.createBaseMapType((ParameterizedType) type);
+            node.set(baseMapType, obj);
+        }
+    }
+
+    protected abstract Type createBaseMapType(final ParameterizedType type);
+
+    public static final class SomethingToPrimitive<M extends Map<?, ?>> extends FastutilMapSerializer<M> {
+        private final Type primitiveType;
+
+        public SomethingToPrimitive(final Function<Map, ? extends M> factory, final Type primitiveType) {
+            super(factory);
+            this.primitiveType = primitiveType;
+        }
+
+        @Override
+        protected Type createBaseMapType(final ParameterizedType type) {
+            return TypeFactory.parameterizedClass(Map.class, type.getActualTypeArguments()[0], GenericTypeReflector.box(this.primitiveType));
+        }
+    }
+
+    public static final class PrimitiveToSomething<M extends Map<?, ?>> extends FastutilMapSerializer<M> {
+        private final Type primitiveType;
+
+        public PrimitiveToSomething(final Function<Map, ? extends M> factory, final Type primitiveType) {
+            super(factory);
+            this.primitiveType = primitiveType;
+        }
+
+        @Override
+        protected Type createBaseMapType(final ParameterizedType type) {
+            return TypeFactory.parameterizedClass(Map.class, GenericTypeReflector.box(this.primitiveType), type.getActualTypeArguments()[0]);
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/configuration/serializer/collections/MapSerializer.java b/src/main/java/io/papermc/paper/configuration/serializer/collections/MapSerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..d11bab6fc16330427ad462638023074d325bf238
--- /dev/null
+++ b/src/main/java/io/papermc/paper/configuration/serializer/collections/MapSerializer.java
@@ -0,0 +1,154 @@
+package io.papermc.paper.configuration.serializer.collections;
+
+import io.leangen.geantyref.TypeToken;
+import net.minecraft.server.MinecraftServer;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.slf4j.Logger;
+import org.spongepowered.configurate.BasicConfigurationNode;
+import org.spongepowered.configurate.ConfigurationNode;
+import org.spongepowered.configurate.ConfigurationOptions;
+import org.spongepowered.configurate.NodePath;
+import org.spongepowered.configurate.serialize.SerializationException;
+import org.spongepowered.configurate.serialize.TypeSerializer;
+
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.*;
+
+/**
+ * Map serializer that does not throw errors on individual entry serialization failures.
+ */
+public class MapSerializer implements TypeSerializer<Map<?, ?>> {
+
+    public static final TypeToken<Map<?, ?>> TYPE = new TypeToken<Map<?, ?>>() {};
+
+    private final boolean clearInvalids;
+
+    public MapSerializer(boolean clearInvalids) {
+        this.clearInvalids = clearInvalids;
+    }
+
+    @Override
+    public Map<?, ?> deserialize(Type type, ConfigurationNode node) throws SerializationException {
+        final Map<Object, Object> map = new LinkedHashMap<>();
+        if (node.isMap()) {
+            if (!(type instanceof ParameterizedType parameterizedType)) {
+                throw new SerializationException(type, "Raw types are not supported for collections");
+            }
+            if (parameterizedType.getActualTypeArguments().length != 2) {
+                throw new SerializationException(type, "Map expected two type arguments!");
+            }
+            final Type key = parameterizedType.getActualTypeArguments()[0];
+            final Type value = parameterizedType.getActualTypeArguments()[1];
+            final @Nullable TypeSerializer<?> keySerializer = node.options().serializers().get(key);
+            final @Nullable TypeSerializer<?> valueSerializer = node.options().serializers().get(value);
+            if (keySerializer == null) {
+                throw new SerializationException(type, "No type serializer available for key type " + key);
+            }
+            if (valueSerializer == null) {
+                throw new SerializationException(type, "No type serializer available for value type " + value);
+            }
+
+            final BasicConfigurationNode keyNode = BasicConfigurationNode.root(node.options());
+            final Set<Object> keysToClear = new HashSet<>();
+            for (Map.Entry<Object, ? extends ConfigurationNode> ent : node.childrenMap().entrySet()) {
+                final @Nullable Object deserializedKey = deserialize(key, keySerializer, "key", keyNode.set(ent.getKey()), node.path());
+                final @Nullable Object deserializedValue = deserialize(value, valueSerializer, "value", ent.getValue(), ent.getValue().path());
+                if (deserializedKey == null || deserializedValue == null) {
+                    continue;
+                }
+                if (keySerializer instanceof WriteBack) {
+                    if (serialize(key, keySerializer, deserializedKey, "key", keyNode, node.path()) && !ent.getKey().equals(Objects.requireNonNull(keyNode.raw(), "Key must not be null!"))) {
+                        keysToClear.add(ent.getKey());
+                    }
+                }
+                map.put(deserializedKey, deserializedValue);
+            }
+            if (keySerializer instanceof WriteBack) { // supports cleaning keys which deserialize to the same value
+                for (Object keyToClear : keysToClear) {
+                    node.node(keyToClear).raw(null);
+                }
+            }
+        }
+        return map;
+    }
+
+    private @Nullable Object deserialize(Type type, TypeSerializer<?> serializer, String mapPart, ConfigurationNode node, NodePath path) {
+        try {
+            return serializer.deserialize(type, node);
+        } catch (SerializationException ex) {
+            ex.initPath(node::path);
+            MinecraftServer.LOGGER.error("Could not deserialize {} {} into {} at {}", mapPart, node.raw(), type, path);
+        }
+        return null;
+    }
+
+    @Override
+    public void serialize(Type type, @Nullable Map<?, ?> obj, ConfigurationNode node) throws SerializationException {
+        if (!(type instanceof ParameterizedType parameterizedType)) {
+            throw new SerializationException(type, "Raw types are not supported for collections");
+        }
+        if (parameterizedType.getActualTypeArguments().length != 2) {
+            throw new SerializationException(type, "Map expected two type arguments!");
+        }
+        final Type key = parameterizedType.getActualTypeArguments()[0];
+        final Type value = parameterizedType.getActualTypeArguments()[1];
+        final @Nullable TypeSerializer<?> keySerializer = node.options().serializers().get(key);
+        final @Nullable TypeSerializer<?> valueSerializer = node.options().serializers().get(value);
+
+        if (keySerializer == null) {
+            throw new SerializationException(type, "No type serializer available for key type " + key);
+        }
+
+        if (valueSerializer == null) {
+            throw new SerializationException(type, "No type serializer available for value type " + value);
+        }
+
+        if (obj == null || obj.isEmpty()) {
+            node.set(Collections.emptyMap());
+        } else {
+            final Set<Object> unvisitedKeys;
+            if (node.empty()) {
+                node.raw(Collections.emptyMap());
+                unvisitedKeys = Collections.emptySet();
+            } else {
+                unvisitedKeys = new HashSet<>(node.childrenMap().keySet());
+            }
+            final BasicConfigurationNode keyNode = BasicConfigurationNode.root(node.options());
+            for (Map.Entry<?, ?> ent : obj.entrySet()) {
+                if (!serialize(key, keySerializer, ent.getKey(), "key", keyNode, node.path())) {
+                    continue;
+                }
+                final Object keyObj = Objects.requireNonNull(keyNode.raw(), "Key must not be null!");
+                final ConfigurationNode child = node.node(keyObj);
+                serialize(value, valueSerializer, ent.getValue(), "value", child, child.path());
+                unvisitedKeys.remove(keyObj);
+            }
+            if (this.clearInvalids) {
+                for (Object unusedChild : unvisitedKeys) {
+                    node.removeChild(unusedChild);
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings({"rawtypes", "unchecked"})
+    private boolean serialize(Type type, TypeSerializer serializer, Object object, String mapPart, ConfigurationNode node, NodePath path) {
+        try {
+            serializer.serialize(type, object, node);
+            return true;
+        } catch (SerializationException ex) {
+            ex.initPath(node::path);
+            MinecraftServer.LOGGER.error("Could not serialize {} {} from {} at {}", mapPart, object, type, path);
+        }
+        return false;
+    }
+
+    @Override
+    public @Nullable Map<?, ?> emptyValue(Type specificType, ConfigurationOptions options) {
+        return new LinkedHashMap<>();
+    }
+
+    public interface WriteBack { // marker interface
+    }
+}
diff --git a/src/main/java/io/papermc/paper/configuration/serializer/collections/TableSerializer.java b/src/main/java/io/papermc/paper/configuration/serializer/collections/TableSerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..36ca88b677e1b55b41c52750948d5b6de7ecd007
--- /dev/null
+++ b/src/main/java/io/papermc/paper/configuration/serializer/collections/TableSerializer.java
@@ -0,0 +1,89 @@
+package io.papermc.paper.configuration.serializer.collections;
+
+import com.google.common.collect.HashBasedTable;
+import com.google.common.collect.ImmutableTable;
+import com.google.common.collect.Table;
+import io.leangen.geantyref.TypeFactory;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.spongepowered.configurate.BasicConfigurationNode;
+import org.spongepowered.configurate.ConfigurationNode;
+import org.spongepowered.configurate.ConfigurationOptions;
+import org.spongepowered.configurate.serialize.SerializationException;
+import org.spongepowered.configurate.serialize.TypeSerializer;
+
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.Map;
+import java.util.Objects;
+
+public class TableSerializer implements TypeSerializer<Table<?, ?, ?>> {
+    private static final int ROW_TYPE_ARGUMENT_INDEX = 0;
+    private static final int COLUMN_TYPE_ARGUMENT_INDEX = 1;
+    private static final int VALUE_TYPE_ARGUMENT_INDEX = 2;
+
+    @Override
+    public Table<?, ?, ?> deserialize(final Type type, final ConfigurationNode node) throws SerializationException {
+        final Table<?, ?, ?> table = HashBasedTable.create();
+        if (!node.empty() && node.isMap()) {
+            this.deserialize0(table, (ParameterizedType) type, node);
+        }
+        return table;
+    }
+
+    @SuppressWarnings("unchecked")
+    private <R, C, V> void deserialize0(final Table<R, C, V> table, final ParameterizedType type, final ConfigurationNode node) throws SerializationException {
+        final Type rowType = type.getActualTypeArguments()[ROW_TYPE_ARGUMENT_INDEX];
+        final Type columnType = type.getActualTypeArguments()[COLUMN_TYPE_ARGUMENT_INDEX];
+        final Type valueType = type.getActualTypeArguments()[VALUE_TYPE_ARGUMENT_INDEX];
+
+        final @Nullable TypeSerializer<R> rowKeySerializer = (TypeSerializer<R>) node.options().serializers().get(rowType);
+        if (rowKeySerializer == null) {
+            throw new SerializationException("Could not find serializer for table row type " + rowType);
+        }
+
+        final Type mapType = TypeFactory.parameterizedClass(Map.class, columnType, valueType);
+        final @Nullable TypeSerializer<Map<C, V>> columnValueSerializer = (TypeSerializer<Map<C, V>>) node.options().serializers().get(mapType);
+        if (columnValueSerializer == null) {
+            throw new SerializationException("Could not find serializer for table column-value map " + type);
+        }
+
+        final BasicConfigurationNode rowKeyNode = BasicConfigurationNode.root(node.options());
+
+        for (final Object key : node.childrenMap().keySet()) {
+            final R rowKey = rowKeySerializer.deserialize(rowType, rowKeyNode.set(key));
+            final Map<C, V> map = columnValueSerializer.deserialize(mapType, node.node(rowKeyNode.raw()));
+            map.forEach((column, value) -> table.put(rowKey, column, value));
+        }
+    }
+
+    @Override
+    public void serialize(final Type type, @Nullable final Table<?, ?, ?> table, final ConfigurationNode node) throws SerializationException {
+        if (table != null) {
+            this.serialize0(table, (ParameterizedType) type, node);
+        }
+    }
+
+    @SuppressWarnings({"rawtypes", "unchecked"})
+    private <R, C, V> void serialize0(final Table<R, C, V> table, final ParameterizedType type, final ConfigurationNode node) throws SerializationException {
+        final Type rowType = type.getActualTypeArguments()[ROW_TYPE_ARGUMENT_INDEX];
+        final Type columnType = type.getActualTypeArguments()[COLUMN_TYPE_ARGUMENT_INDEX];
+        final Type valueType = type.getActualTypeArguments()[VALUE_TYPE_ARGUMENT_INDEX];
+
+        final @Nullable TypeSerializer rowKeySerializer = node.options().serializers().get(rowType);
+        if (rowKeySerializer == null) {
+            throw new SerializationException("Could not find a serializer for table row type " + rowType);
+        }
+
+        final BasicConfigurationNode rowKeyNode = BasicConfigurationNode.root(node.options());
+        for (final R key : table.rowKeySet()) {
+            rowKeySerializer.serialize(rowType, key, rowKeyNode.set(key));
+            final Object keyObj = Objects.requireNonNull(rowKeyNode.raw());
+            node.node(keyObj).set(TypeFactory.parameterizedClass(Map.class, columnType, valueType), table.row(key));
+        }
+    }
+
+    @Override
+    public @Nullable Table<?, ?, ?> emptyValue(Type specificType, ConfigurationOptions options) {
+        return ImmutableTable.of();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/configuration/type/BooleanOrDefault.java b/src/main/java/io/papermc/paper/configuration/type/BooleanOrDefault.java
new file mode 100644
index 0000000000000000000000000000000000000000..a3eaa47cfcfc4fd2a607f9b375230fada35620d3
--- /dev/null
+++ b/src/main/java/io/papermc/paper/configuration/type/BooleanOrDefault.java
@@ -0,0 +1,53 @@
+package io.papermc.paper.configuration.type;
+
+import org.apache.commons.lang3.BooleanUtils;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.spongepowered.configurate.serialize.ScalarSerializer;
+import org.spongepowered.configurate.serialize.SerializationException;
+
+import java.lang.reflect.Type;
+import java.util.Locale;
+import java.util.function.Predicate;
+
+public record BooleanOrDefault(@Nullable Boolean value) {
+    private static final String DEFAULT_VALUE = "default";
+    public static final BooleanOrDefault USE_DEFAULT = new BooleanOrDefault(null);
+    public static final ScalarSerializer<BooleanOrDefault> SERIALIZER = new Serializer();
+
+    public boolean or(boolean fallback) {
+        return this.value == null ? fallback : this.value;
+    }
+
+    private static final class Serializer extends ScalarSerializer<BooleanOrDefault> {
+        Serializer() {
+            super(BooleanOrDefault.class);
+        }
+
+        @Override
+        public BooleanOrDefault deserialize(Type type, Object obj) throws SerializationException {
+            if (obj instanceof String string) {
+                if (DEFAULT_VALUE.equalsIgnoreCase(string)) {
+                    return USE_DEFAULT;
+                }
+                try {
+                    return new BooleanOrDefault(BooleanUtils.toBoolean(string.toLowerCase(Locale.ROOT), "true", "false"));
+                } catch (IllegalArgumentException ex) {
+                    throw new SerializationException(BooleanOrDefault.class, obj + "(" + type + ") is not a boolean or '" + DEFAULT_VALUE + "'", ex);
+                }
+            } else if (obj instanceof Boolean bool) {
+                return new BooleanOrDefault(bool);
+            }
+            throw new SerializationException(BooleanOrDefault.class, obj + "(" + type + ") is not a boolean or '" + DEFAULT_VALUE + "'");
+        }
+
+        @Override
+        protected Object serialize(BooleanOrDefault item, Predicate<Class<?>> typeSupported) {
+            final @Nullable Boolean value = item.value;
+            if (value != null) {
+                return value.toString();
+            } else {
+                return DEFAULT_VALUE;
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/configuration/type/Duration.java b/src/main/java/io/papermc/paper/configuration/type/Duration.java
new file mode 100644
index 0000000000000000000000000000000000000000..422ccb0b332b3e94be228b9b94f379467d6461a5
--- /dev/null
+++ b/src/main/java/io/papermc/paper/configuration/type/Duration.java
@@ -0,0 +1,97 @@
+package io.papermc.paper.configuration.type;
+
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.spongepowered.configurate.serialize.ScalarSerializer;
+import org.spongepowered.configurate.serialize.SerializationException;
+
+import java.lang.reflect.Type;
+import java.util.Objects;
+import java.util.function.Predicate;
+import java.util.regex.Pattern;
+
+public final class Duration {
+
+    private static final Pattern SPACE = Pattern.compile(" ");
+    private static final Pattern NOT_NUMERIC = Pattern.compile("[^-\\d.]");
+    public static final Serializer SERIALIZER = new Serializer();
+
+    private final long seconds;
+    private final String value;
+
+    private Duration(String value) {
+        this.value = value;
+        this.seconds = getSeconds(value);
+    }
+
+    public long seconds() {
+        return this.seconds;
+    }
+
+    public long ticks() {
+        return this.seconds * 20;
+    }
+
+    public String value() {
+        return this.value;
+    }
+
+    @Override
+    public boolean equals(@Nullable Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        Duration duration = (Duration) o;
+        return seconds == duration.seconds && this.value.equals(duration.value);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(this.seconds, this.value);
+    }
+
+    @Override
+    public String toString() {
+        return "Duration{" +
+                "seconds=" + this.seconds +
+                ", value='" + this.value + '\'' +
+                '}';
+    }
+
+    public static Duration of(String time) {
+        return new Duration(time);
+    }
+
+    private static int getSeconds(String str) {
+        str = SPACE.matcher(str).replaceAll("");
+        final char unit = str.charAt(str.length() - 1);
+        str = NOT_NUMERIC.matcher(str).replaceAll("");
+        double num;
+        try {
+            num = Double.parseDouble(str);
+        } catch (Exception e) {
+            num = 0D;
+        }
+        switch (unit) {
+            case 'd': num *= (double) 60*60*24; break;
+            case 'h': num *= (double) 60*60; break;
+            case 'm': num *= (double) 60; break;
+            default: case 's': break;
+        }
+        return (int) num;
+    }
+
+    static final class Serializer extends ScalarSerializer<Duration> {
+        private Serializer() {
+            super(Duration.class);
+        }
+
+        @Override
+        public Duration deserialize(Type type, Object obj) throws SerializationException {
+            return new Duration(obj.toString());
+        }
+
+        @Override
+        protected Object serialize(Duration item, Predicate<Class<?>> typeSupported) {
+            return item.value();
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/configuration/type/DurationOrDisabled.java b/src/main/java/io/papermc/paper/configuration/type/DurationOrDisabled.java
new file mode 100644
index 0000000000000000000000000000000000000000..64b5bdbd102ad97721976a45b907b300f999db06
--- /dev/null
+++ b/src/main/java/io/papermc/paper/configuration/type/DurationOrDisabled.java
@@ -0,0 +1,55 @@
+package io.papermc.paper.configuration.type;
+
+import org.spongepowered.configurate.serialize.ScalarSerializer;
+import org.spongepowered.configurate.serialize.SerializationException;
+
+import java.lang.reflect.Type;
+import java.util.Optional;
+import java.util.function.Predicate;
+
+@SuppressWarnings("OptionalUsedAsFieldOrParameterType")
+public final class DurationOrDisabled {
+    private static final String DISABLE_VALUE = "disabled";
+    public static final DurationOrDisabled USE_DISABLED = new DurationOrDisabled(Optional.empty());
+    public static final ScalarSerializer<DurationOrDisabled> SERIALIZER = new Serializer();
+
+    private Optional<Duration> value;
+
+    public DurationOrDisabled(final Optional<Duration> value) {
+        this.value = value;
+    }
+
+    public Optional<Duration> value() {
+        return this.value;
+    }
+
+    public void value(final Optional<Duration> value) {
+        this.value = value;
+    }
+
+    public Duration or(final Duration fallback) {
+        return this.value.orElse(fallback);
+    }
+
+    private static final class Serializer extends ScalarSerializer<DurationOrDisabled> {
+        Serializer() {
+            super(DurationOrDisabled.class);
+        }
+
+        @Override
+        public DurationOrDisabled deserialize(final Type type, final Object obj) throws SerializationException {
+            if (obj instanceof final String string) {
+                if (DISABLE_VALUE.equalsIgnoreCase(string)) {
+                    return USE_DISABLED;
+                }
+                return new DurationOrDisabled(Optional.of(Duration.SERIALIZER.deserialize(string)));
+            }
+            throw new SerializationException(obj + "(" + type + ") is not a duration or '" + DISABLE_VALUE + "'");
+        }
+
+        @Override
+        protected Object serialize(final DurationOrDisabled item, final Predicate<Class<?>> typeSupported) {
+            return item.value.map(Duration::value).orElse(DISABLE_VALUE);
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/configuration/type/number/BelowZeroToEmpty.java b/src/main/java/io/papermc/paper/configuration/type/number/BelowZeroToEmpty.java
new file mode 100644
index 0000000000000000000000000000000000000000..31068170086aeac51a2adb952b19672e875ba528
--- /dev/null
+++ b/src/main/java/io/papermc/paper/configuration/type/number/BelowZeroToEmpty.java
@@ -0,0 +1,11 @@
+package io.papermc.paper.configuration.type.number;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface BelowZeroToEmpty {
+}
diff --git a/src/main/java/io/papermc/paper/configuration/type/number/DoubleOr.java b/src/main/java/io/papermc/paper/configuration/type/number/DoubleOr.java
new file mode 100644
index 0000000000000000000000000000000000000000..2c781aca70c3f248857ad38c80f10528d2e731df
--- /dev/null
+++ b/src/main/java/io/papermc/paper/configuration/type/number/DoubleOr.java
@@ -0,0 +1,60 @@
+package io.papermc.paper.configuration.type.number;
+
+import com.google.common.base.Preconditions;
+import org.spongepowered.configurate.serialize.ScalarSerializer;
+
+import java.util.OptionalDouble;
+import java.util.function.Function;
+import java.util.function.Predicate;
+
+public interface DoubleOr {
+
+    default double or(final double fallback) {
+        return this.value().orElse(fallback);
+    }
+
+    OptionalDouble value();
+
+    default double doubleValue() {
+        return this.value().orElseThrow();
+    }
+
+    record Default(OptionalDouble value) implements DoubleOr {
+        private static final String DEFAULT_VALUE = "default";
+        public static final Default USE_DEFAULT = new Default(OptionalDouble.empty());
+        public static final ScalarSerializer<Default> SERIALIZER = new Serializer<>(Default.class, Default::new, DEFAULT_VALUE, USE_DEFAULT);
+    }
+
+    final class Serializer<T extends DoubleOr> extends OptionalNumSerializer<T, OptionalDouble> {
+        Serializer(final Class<T> classOfT, final Function<OptionalDouble, T> factory, String emptySerializedValue, T emptyValue) {
+            super(classOfT, emptySerializedValue, emptyValue, OptionalDouble::empty, OptionalDouble::isEmpty, factory, double.class);
+        }
+
+        @Override
+        protected Object serialize(final T item, final Predicate<Class<?>> typeSupported) {
+            final OptionalDouble value = item.value();
+            if (value.isPresent()) {
+                return value.getAsDouble();
+            } else {
+                return this.emptySerializedValue;
+            }
+        }
+
+        @Override
+        protected OptionalDouble full(final String value) {
+            return OptionalDouble.of(Double.parseDouble(value));
+        }
+
+        @Override
+        protected OptionalDouble full(final Number num) {
+            return OptionalDouble.of(num.doubleValue());
+        }
+
+        @Override
+        protected boolean belowZero(final OptionalDouble value) {
+            Preconditions.checkArgument(value.isPresent());
+            return value.getAsDouble() < 0;
+        }
+    }
+}
+
diff --git a/src/main/java/io/papermc/paper/configuration/type/number/IntOr.java b/src/main/java/io/papermc/paper/configuration/type/number/IntOr.java
new file mode 100644
index 0000000000000000000000000000000000000000..0fcd03bea1518d9bb2cd08cc757204cf2f80bca3
--- /dev/null
+++ b/src/main/java/io/papermc/paper/configuration/type/number/IntOr.java
@@ -0,0 +1,80 @@
+package io.papermc.paper.configuration.type.number;
+
+import com.google.common.base.Preconditions;
+import net.minecraft.server.MinecraftServer;
+import org.slf4j.Logger;
+import org.spongepowered.configurate.serialize.ScalarSerializer;
+
+import java.util.OptionalInt;
+import java.util.function.Function;
+import java.util.function.IntPredicate;
+import java.util.function.Predicate;
+
+public interface IntOr {
+
+    default int or(final int fallback) {
+        return this.value().orElse(fallback);
+    }
+
+    OptionalInt value();
+
+    default int intValue() {
+        return this.value().orElseThrow();
+    }
+
+    record Default(OptionalInt value) implements IntOr {
+        private static final String DEFAULT_VALUE = "default";
+        public static final Default USE_DEFAULT = new Default(OptionalInt.empty());
+        public static final ScalarSerializer<Default> SERIALIZER = new Serializer<>(Default.class, Default::new, DEFAULT_VALUE, USE_DEFAULT);
+    }
+
+    record Disabled(OptionalInt value) implements IntOr {
+        private static final String DISABLED_VALUE = "disabled";
+        public static final Disabled DISABLED = new Disabled(OptionalInt.empty());
+        public static final ScalarSerializer<Disabled> SERIALIZER = new Serializer<>(Disabled.class, Disabled::new, DISABLED_VALUE, DISABLED);
+
+        public boolean test(IntPredicate predicate) {
+            return this.value.isPresent() && predicate.test(this.value.getAsInt());
+        }
+
+        public boolean enabled() {
+            return this.value.isPresent();
+        }
+    }
+
+    final class Serializer<T extends IntOr> extends OptionalNumSerializer<T, OptionalInt> {
+
+        private Serializer(Class<T> classOfT, Function<OptionalInt, T> factory, String emptySerializedValue, T emptyValue) {
+            super(classOfT, emptySerializedValue, emptyValue, OptionalInt::empty, OptionalInt::isEmpty, factory, int.class);
+        }
+
+        @Override
+        protected OptionalInt full(final String value) {
+            return OptionalInt.of(Integer.parseInt(value));
+        }
+
+        @Override
+        protected OptionalInt full(final Number num) {
+            if (num.intValue() != num.doubleValue() || num.intValue() != num.longValue()) {
+                MinecraftServer.LOGGER.error("{} cannot be converted to an integer without losing information", num);
+            }
+            return OptionalInt.of(num.intValue());
+        }
+
+        @Override
+        protected boolean belowZero(final OptionalInt value) {
+            Preconditions.checkArgument(value.isPresent());
+            return value.getAsInt() < 0;
+        }
+
+        @Override
+        protected Object serialize(final T item, final Predicate<Class<?>> typeSupported) {
+            final OptionalInt value = item.value();
+            if (value.isPresent()) {
+                return value.getAsInt();
+            } else {
+                return this.emptySerializedValue;
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/configuration/type/number/OptionalNumSerializer.java b/src/main/java/io/papermc/paper/configuration/type/number/OptionalNumSerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..8a90d6b8529d492574ede50bac50491b83642f84
--- /dev/null
+++ b/src/main/java/io/papermc/paper/configuration/type/number/OptionalNumSerializer.java
@@ -0,0 +1,59 @@
+package io.papermc.paper.configuration.type.number;
+
+import org.apache.commons.lang3.math.NumberUtils;
+import org.spongepowered.configurate.serialize.ScalarSerializer;
+import org.spongepowered.configurate.serialize.SerializationException;
+
+import java.lang.reflect.AnnotatedType;
+import java.util.function.Function;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
+
+public abstract class OptionalNumSerializer<T, O> extends ScalarSerializer.Annotated<T> {
+
+    protected final String emptySerializedValue;
+    protected final T emptyValue;
+    private final Supplier<O> empty;
+    private final Predicate<O> isEmpty;
+    private final Function<O, T> factory;
+    private final Class<?> number;
+
+    protected OptionalNumSerializer(final Class<T> classOfT, final String emptySerializedValue, final T emptyValue, final Supplier<O> empty, final Predicate<O> isEmpty, final Function<O, T> factory, final Class<?> number) {
+        super(classOfT);
+        this.emptySerializedValue = emptySerializedValue;
+        this.emptyValue = emptyValue;
+        this.empty = empty;
+        this.isEmpty = isEmpty;
+        this.factory = factory;
+        this.number = number;
+    }
+
+    @Override
+    public final T deserialize(final AnnotatedType type, final Object obj) throws SerializationException {
+        final O value;
+        if (obj instanceof String string) {
+            if (this.emptySerializedValue.equalsIgnoreCase(string)) {
+                value = this.empty.get();
+            } else if (NumberUtils.isParsable(string)) {
+                value = this.full(string);
+            } else {
+                throw new SerializationException("%s (%s) is not a(n) %s or '%s'".formatted(obj, type, this.number.getSimpleName(), this.emptySerializedValue));
+            }
+        } else if (obj instanceof Number num) {
+            value = this.full(num);
+        } else {
+            throw new SerializationException("%s (%s) is not a(n) %s or '%s'".formatted(obj, type, this.number.getSimpleName(), this.emptySerializedValue));
+        }
+        if (this.isEmpty.test(value) || (type.isAnnotationPresent(BelowZeroToEmpty.class) && this.belowZero(value))) {
+            return this.emptyValue;
+        } else {
+            return this.factory.apply(value);
+        }
+    }
+
+    protected abstract O full(final String value);
+
+    protected abstract O full(final Number num);
+
+    protected abstract boolean belowZero(O value);
+}
diff --git a/src/main/java/io/papermc/paper/plugin/PluginInitializerManager.java b/src/main/java/io/papermc/paper/plugin/PluginInitializerManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..36c833879279b08de9a9f57b073e9ac68fc33cf4
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/PluginInitializerManager.java
@@ -0,0 +1,140 @@
+package io.papermc.paper.plugin;
+
+import com.google.common.base.Charsets;
+import io.papermc.paper.plugin.entrypoint.Entrypoint;
+import io.papermc.paper.plugin.entrypoint.LaunchEntryPointHandler;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.type.paper.PaperPluginParent;
+import joptsimple.OptionSet;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.dedicated.DedicatedServer;
+import org.bukkit.Bukkit;
+import org.bukkit.Server;
+import org.bukkit.configuration.ConfigurationSection;
+import org.bukkit.configuration.file.YamlConfiguration;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+public class PluginInitializerManager {
+
+    private static PluginInitializerManager impl;
+    private final Path pluginDirectory;
+    private final Path updateDirectory;
+
+    PluginInitializerManager(final Path pluginDirectory, final Path updateDirectory) {
+        this.pluginDirectory = pluginDirectory;
+        this.updateDirectory = updateDirectory;
+    }
+
+    private static PluginInitializerManager parse(@NotNull final OptionSet minecraftOptionSet) throws Exception {
+        // We have to load the bukkit configuration inorder to get the update folder location.
+        final File configFileLocationBukkit = (File) minecraftOptionSet.valueOf("bukkit-settings");
+
+        YamlConfiguration configuration = YamlConfiguration.loadConfiguration(configFileLocationBukkit);
+        configuration.options().copyDefaults(true);
+        configuration.setDefaults(YamlConfiguration.loadConfiguration(new InputStreamReader(Server.class.getClassLoader().getResourceAsStream("configurations/bukkit.yml"), Charsets.UTF_8)));
+        if (!configuration.isString("aliases"))
+            configuration.set("aliases", "now-in-commands.yml");
+
+        final Path pluginDirectory = ((File) minecraftOptionSet.valueOf("plugins")).toPath();
+
+        final String updateDirectoryName = configuration.getString("settings.update-folder", "update");
+        if (updateDirectoryName.isBlank()) {
+            return new PluginInitializerManager(pluginDirectory, null);
+        }
+
+        final Path resolvedUpdateDirectory = pluginDirectory.resolve(updateDirectoryName);
+        if (!Files.isDirectory(resolvedUpdateDirectory)) {
+            if (Files.exists(resolvedUpdateDirectory)) {
+                MinecraftServer.LOGGER.error("Misconfigured update directory!");
+                MinecraftServer.LOGGER.error("Your configured update directory ({}) in bukkit.yml is pointing to a non-directory path. " +
+                    "Auto updating functionality will not work.", resolvedUpdateDirectory);
+            }
+            return new PluginInitializerManager(pluginDirectory, null);
+        }
+
+        boolean isSameFile;
+        try {
+            isSameFile = Files.isSameFile(resolvedUpdateDirectory, pluginDirectory);
+        } catch (final IOException e) {
+            MinecraftServer.LOGGER.error("Misconfigured update directory!");
+            MinecraftServer.LOGGER.error("Failed to compare update/plugin directory", e);
+            return new PluginInitializerManager(pluginDirectory, null);
+        }
+
+        if (isSameFile) {
+            MinecraftServer.LOGGER.error("Misconfigured update directory!");
+            MinecraftServer.LOGGER.error(("Your configured update directory (%s) in bukkit.yml is pointing to the same location as the plugin directory (%s). " +
+                "Disabling auto updating functionality.").formatted(resolvedUpdateDirectory, pluginDirectory));
+
+            return new PluginInitializerManager(pluginDirectory, null);
+        }
+
+        return new PluginInitializerManager(pluginDirectory, resolvedUpdateDirectory);
+    }
+
+    public static PluginInitializerManager init(final OptionSet optionSet) throws Exception {
+        impl = parse(optionSet);
+        return impl;
+    }
+
+    public static PluginInitializerManager instance() {
+        return impl;
+    }
+
+    @NotNull
+    public Path pluginDirectoryPath() {
+        return pluginDirectory;
+    }
+
+    @Nullable
+    public Path pluginUpdatePath() {
+        return updateDirectory;
+    }
+
+    public static void load(OptionSet optionSet) throws Exception {
+        // We have to load the bukkit configuration inorder to get the update folder location.
+        PluginInitializerManager pluginSystem = PluginInitializerManager.init(optionSet);
+
+        // Register the default plugin directory
+        io.papermc.paper.plugin.util.EntrypointUtil.registerProvidersFromSource(io.papermc.paper.plugin.provider.source.DirectoryProviderSource.INSTANCE, pluginSystem.pluginDirectoryPath());
+
+        // Register plugins from the flag
+        @SuppressWarnings("unchecked")
+        java.util.List<Path> files = ((java.util.List<File>) optionSet.valuesOf("add-plugin")).stream().map(File::toPath).toList();
+        io.papermc.paper.plugin.util.EntrypointUtil.registerProvidersFromSource(io.papermc.paper.plugin.provider.source.PluginFlagProviderSource.INSTANCE, files);
+        io.papermc.paper.plugin.util.EntrypointUtil.registerProvidersFromSource(io.papermc.paper.plugin.provider.source.SparkProviderSource.INSTANCE, new File("cache", "spark.jar").toPath()); // Purpur
+    }
+
+    // This will be the end of me...
+    public static void reload(DedicatedServer dedicatedServer) {
+        // Wipe the provider storage
+        LaunchEntryPointHandler.INSTANCE.populateProviderStorage();
+        try {
+            load(dedicatedServer.options);
+        } catch (Exception e) {
+            throw new RuntimeException("Failed to reload!", e);
+        }
+
+        boolean hasPaperPlugin = false;
+        for (PluginProvider<?> provider : LaunchEntryPointHandler.INSTANCE.getStorage().get(Entrypoint.PLUGIN).getRegisteredProviders()) {
+            if (provider instanceof PaperPluginParent.PaperServerPluginProvider) {
+                hasPaperPlugin = true;
+                break;
+            }
+        }
+
+        if (hasPaperPlugin) {
+            MinecraftServer.LOGGER.warn("======== WARNING ========");
+            MinecraftServer.LOGGER.warn("You are reloading while having Paper plugins installed on your server.");
+            MinecraftServer.LOGGER.warn("Paper plugins do NOT support being reloaded. This will cause some unexpected issues.");
+            MinecraftServer.LOGGER.warn("=========================");
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrapContextImpl.java b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrapContextImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..c467f3ce53364c5ef4df37b97ab63b071b8408a5
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrapContextImpl.java
@@ -0,0 +1,63 @@
+package io.papermc.paper.plugin.bootstrap;
+
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventManager;
+import io.papermc.paper.plugin.lifecycle.event.PaperLifecycleEventManager;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import org.jetbrains.annotations.NotNull;
+
+import java.nio.file.Path;
+
+public final class PluginBootstrapContextImpl implements BootstrapContext {
+
+    private final PluginMeta config;
+    private final Path dataFolder;
+    private final Path pluginSource;
+    // Paper start - lifecycle events
+    private boolean allowsLifecycleRegistration = true;
+    private final PaperLifecycleEventManager<BootstrapContext> lifecycleEventManager = new PaperLifecycleEventManager<>(this, () -> this.allowsLifecycleRegistration); // Paper - lifecycle events
+    // Paper end - lifecycle events
+
+    public PluginBootstrapContextImpl(PluginMeta config, Path dataFolder, Path pluginSource) {
+        this.config = config;
+        this.dataFolder = dataFolder;
+        this.pluginSource = pluginSource;
+    }
+
+    public static PluginBootstrapContextImpl create(PluginProvider<?> provider, Path pluginFolder) {
+        Path dataFolder = pluginFolder.resolve(provider.getMeta().getName());
+
+        return new PluginBootstrapContextImpl(provider.getMeta(), dataFolder, provider.getSource());
+    }
+
+    @Override
+    public @NotNull PluginMeta getConfiguration() {
+        return this.config;
+    }
+
+    @Override
+    public @NotNull Path getDataDirectory() {
+        return this.dataFolder;
+    }
+
+    @Override
+    public @NotNull Path getPluginSource() {
+        return this.pluginSource;
+    }
+
+    // Paper start - lifecycle event system
+    @Override
+    public @NotNull PluginMeta getPluginMeta() {
+        return this.config;
+    }
+
+    @Override
+    public LifecycleEventManager<BootstrapContext> getLifecycleManager() {
+        return this.lifecycleEventManager;
+    }
+
+    public void lockLifecycleEventRegistration() {
+        this.allowsLifecycleRegistration = false;
+    }
+    // Paper end
+}
diff --git a/src/main/java/io/papermc/paper/plugin/bootstrap/PluginProviderContextImpl.java b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginProviderContextImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..145b0cb5f2431d366cb74862b25a28d10f7a7505
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginProviderContextImpl.java
@@ -0,0 +1,41 @@
+package io.papermc.paper.plugin.bootstrap;
+
+import io.papermc.paper.plugin.PluginInitializerManager;
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import org.jetbrains.annotations.NotNull;
+
+import java.nio.file.Path;
+
+public final class PluginProviderContextImpl implements PluginProviderContext {
+
+    private final PluginMeta config;
+    private final Path dataFolder;
+    private final Path pluginSource;
+
+    public PluginProviderContextImpl(PluginMeta config, Path dataFolder, Path pluginSource) {
+        this.config = config;
+        this.dataFolder = dataFolder;
+        this.pluginSource = pluginSource;
+    }
+
+    public static PluginProviderContextImpl create(PluginMeta config, Path pluginSource) {
+        Path dataFolder = PluginInitializerManager.instance().pluginDirectoryPath().resolve(config.getName());
+
+        return new PluginProviderContextImpl(config, dataFolder, pluginSource);
+    }
+
+    @Override
+    public @NotNull PluginMeta getConfiguration() {
+        return this.config;
+    }
+
+    @Override
+    public @NotNull Path getDataDirectory() {
+        return this.dataFolder;
+    }
+
+    @Override
+    public @NotNull Path getPluginSource() {
+        return this.pluginSource;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/Entrypoint.java b/src/main/java/io/papermc/paper/plugin/entrypoint/Entrypoint.java
new file mode 100644
index 0000000000000000000000000000000000000000..125008ac7db8b9f3fb57c49f8e4facc4ad4bb136
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/Entrypoint.java
@@ -0,0 +1,25 @@
+package io.papermc.paper.plugin.entrypoint;
+
+import io.papermc.paper.plugin.bootstrap.PluginBootstrap;
+import org.bukkit.plugin.java.JavaPlugin;
+
+/**
+ * Used to mark a certain place that {@link EntrypointHandler} will register {@link io.papermc.paper.plugin.provider.PluginProvider} under.
+ * Used for loading only certain providers at a certain time.
+ * @param <T> provider type
+ */
+public final class Entrypoint<T> {
+
+    public static final Entrypoint<PluginBootstrap> BOOTSTRAPPER = new Entrypoint<>("bootstrapper");
+    public static final Entrypoint<JavaPlugin> PLUGIN = new Entrypoint<>("plugin");
+
+    private final String debugName;
+
+    private Entrypoint(String debugName) {
+        this.debugName = debugName;
+    }
+
+    public String getDebugName() {
+        return debugName;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/EntrypointHandler.java b/src/main/java/io/papermc/paper/plugin/entrypoint/EntrypointHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..b38e1e0f3d3055086f51bb191fd4b60ecf32d016
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/EntrypointHandler.java
@@ -0,0 +1,14 @@
+package io.papermc.paper.plugin.entrypoint;
+
+import io.papermc.paper.plugin.provider.PluginProvider;
+
+/**
+ * Represents a register that will register providers at a certain {@link Entrypoint},
+ * where then when the given {@link Entrypoint} is registered those will be loaded.
+ */
+public interface EntrypointHandler {
+
+    <T> void register(Entrypoint<T> entrypoint, PluginProvider<T> provider);
+
+    void enter(Entrypoint<?> entrypoint);
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/LaunchEntryPointHandler.java b/src/main/java/io/papermc/paper/plugin/entrypoint/LaunchEntryPointHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..6c0f2c315387734f8dd4a7eca633aa0a9856dd17
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/LaunchEntryPointHandler.java
@@ -0,0 +1,65 @@
+package io.papermc.paper.plugin.entrypoint;
+
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.storage.BootstrapProviderStorage;
+import io.papermc.paper.plugin.storage.ProviderStorage;
+import io.papermc.paper.plugin.storage.ServerPluginProviderStorage;
+import org.jetbrains.annotations.ApiStatus;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Used by the server to register/load plugin bootstrappers and plugins.
+ */
+public class LaunchEntryPointHandler implements EntrypointHandler {
+
+    public static final LaunchEntryPointHandler INSTANCE = new LaunchEntryPointHandler();
+    private final Map<Entrypoint<?>, ProviderStorage<?>> storage = new HashMap<>();
+
+    LaunchEntryPointHandler() {
+        this.populateProviderStorage();
+    }
+
+    // Utility
+    public static void enterBootstrappers() {
+        LaunchEntryPointHandler.INSTANCE.enter(Entrypoint.BOOTSTRAPPER);
+    }
+
+    @Override
+    public void enter(Entrypoint<?> entrypoint) {
+        ProviderStorage<?> storage = this.storage.get(entrypoint);
+        if (storage == null) {
+            throw new IllegalArgumentException("No storage registered for entrypoint %s.".formatted(entrypoint));
+        }
+
+        storage.enter();
+    }
+
+    @Override
+    public <T> void register(Entrypoint<T> entrypoint, PluginProvider<T> provider) {
+        ProviderStorage<T> storage = this.get(entrypoint);
+        if (storage == null) {
+            throw new IllegalArgumentException("No storage registered for entrypoint %s.".formatted(entrypoint));
+        }
+
+        storage.register(provider);
+    }
+
+    @SuppressWarnings("unchecked")
+    public <T> ProviderStorage<T> get(Entrypoint<T> entrypoint) {
+        return (ProviderStorage<T>) this.storage.get(entrypoint);
+    }
+
+    // Debug only
+    @ApiStatus.Internal
+    public Map<Entrypoint<?>, ProviderStorage<?>> getStorage() {
+        return storage;
+    }
+
+    // Reload only
+    public void populateProviderStorage() {
+        this.storage.put(Entrypoint.BOOTSTRAPPER, new BootstrapProviderStorage());
+        this.storage.put(Entrypoint.PLUGIN, new ServerPluginProviderStorage());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/ClassloaderBytecodeModifier.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/ClassloaderBytecodeModifier.java
new file mode 100644
index 0000000000000000000000000000000000000000..93b5196a960f3efbe0d28f5527ea2752426213ce
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/ClassloaderBytecodeModifier.java
@@ -0,0 +1,22 @@
+package io.papermc.paper.plugin.entrypoint.classloader;
+
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import net.kyori.adventure.util.Services;
+import org.jetbrains.annotations.ApiStatus;
+
+@ApiStatus.Internal
+public interface ClassloaderBytecodeModifier {
+
+    static ClassloaderBytecodeModifier bytecodeModifier() {
+        return Provider.INSTANCE;
+    }
+
+    byte[] modify(PluginMeta config, byte[] bytecode);
+
+    class Provider {
+
+        private static final ClassloaderBytecodeModifier INSTANCE = Services.service(ClassloaderBytecodeModifier.class).orElseThrow();
+
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/PaperPluginClassLoader.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/PaperPluginClassLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..6fd2e07ec9ae3596f972e010adbbc2ea7805dea2
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/PaperPluginClassLoader.java
@@ -0,0 +1,204 @@
+package io.papermc.paper.plugin.entrypoint.classloader;
+
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.entrypoint.classloader.group.PaperPluginClassLoaderStorage;
+import io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader;
+import io.papermc.paper.plugin.provider.classloader.PaperClassLoaderStorage;
+import io.papermc.paper.plugin.provider.classloader.PluginClassLoaderGroup;
+import io.papermc.paper.plugin.provider.configuration.PaperPluginMeta;
+import io.papermc.paper.plugin.provider.entrypoint.DependencyContext;
+import org.bukkit.Bukkit;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.nio.file.Path;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.jar.JarFile;
+import java.util.logging.Logger;
+
+/**
+ * This is similar to a {@link org.bukkit.plugin.java.PluginClassLoader} but is completely kept hidden from the api.
+ * This is only used with Paper plugins.
+ *
+ * @see PaperPluginClassLoaderStorage
+ */
+public class PaperPluginClassLoader extends PaperSimplePluginClassLoader implements ConfiguredPluginClassLoader {
+
+    static {
+        registerAsParallelCapable();
+    }
+
+    private final URLClassLoader libraryLoader;
+    private final Set<String> seenIllegalAccess = Collections.newSetFromMap(new ConcurrentHashMap<>());
+    private final Logger logger;
+    @Nullable
+    private JavaPlugin loadedJavaPlugin;
+    @Nullable
+    private PluginClassLoaderGroup group;
+
+    public PaperPluginClassLoader(Logger logger, Path source, JarFile file, PaperPluginMeta configuration, ClassLoader parentLoader, URLClassLoader libraryLoader) throws IOException {
+        super(source, file, configuration, parentLoader);
+        this.libraryLoader = libraryLoader;
+
+        this.logger = logger;
+        if (this.configuration().hasOpenClassloader()) {
+            this.group = PaperClassLoaderStorage.instance().registerOpenGroup(this);
+        }
+    }
+
+    private PaperPluginMeta configuration() {
+        return (PaperPluginMeta) this.configuration;
+    }
+
+    public void refreshClassloaderDependencyTree(DependencyContext dependencyContext) {
+         if (this.configuration().hasOpenClassloader()) {
+             return;
+         }
+         if (this.group != null) {
+             // We need to unregister the classloader inorder to allow for dependencies
+             // to be recalculated
+             PaperClassLoaderStorage.instance().unregisterClassloader(this);
+         }
+
+        this.group = PaperClassLoaderStorage.instance().registerAccessBackedGroup(this, (classLoader) -> {
+            return dependencyContext.isTransitiveDependency(PaperPluginClassLoader.this.configuration, classLoader.getConfiguration());
+        });
+    }
+
+    @Override
+    public URL getResource(String name) {
+        URL resource = findResource(name);
+        if (resource == null && this.libraryLoader != null) {
+            return this.libraryLoader.getResource(name);
+        }
+        return resource;
+    }
+
+    @Override
+    public Enumeration<URL> getResources(String name) throws IOException {
+        List<URL> resources = new ArrayList<>();
+        this.addEnumeration(resources, this.findResources(name));
+        if (this.libraryLoader != null) {
+            addEnumeration(resources, this.libraryLoader.getResources(name));
+        }
+        return Collections.enumeration(resources);
+    }
+
+    private <T> void addEnumeration(List<T> list, Enumeration<T> enumeration) {
+        while (enumeration.hasMoreElements()) {
+            list.add(enumeration.nextElement());
+        }
+    }
+
+    @Override
+    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
+        return this.loadClass(name, resolve, true, true);
+    }
+
+    @Override
+    public PluginMeta getConfiguration() {
+        return this.configuration;
+    }
+
+    @Override
+    public Class<?> loadClass(@NotNull String name, boolean resolve, boolean checkGroup, boolean checkLibraries) throws ClassNotFoundException {
+        try {
+            Class<?> result = super.loadClass(name, resolve);
+
+            // SPIGOT-6749: Library classes will appear in the above, but we don't want to return them to other plugins
+            if (checkGroup || result.getClassLoader() == this) {
+                return result;
+            }
+        } catch (ClassNotFoundException ignored) {
+        }
+
+        if (checkLibraries) {
+            try {
+                return this.libraryLoader.loadClass(name);
+            } catch (ClassNotFoundException ignored) {
+            }
+        }
+
+        if (checkGroup) {
+            // This ignores the libraries of other plugins, unless they are transitive dependencies.
+            if (this.group == null) {
+                throw new IllegalStateException("Tried to resolve class while group was not yet initialized");
+            }
+
+            Class<?> clazz = this.group.getClassByName(name, resolve, this);
+            if (clazz != null) {
+                return clazz;
+            }
+        }
+
+        throw new ClassNotFoundException(name);
+    }
+
+    @Override
+    public void init(JavaPlugin plugin) {
+        PluginMeta config = this.configuration;
+        PluginDescriptionFile pluginDescriptionFile = new PluginDescriptionFile(
+            config.getName(),
+            config.getName(),
+            config.getProvidedPlugins(),
+            config.getMainClass(),
+            "", // Classloader load order api
+            config.getPluginDependencies(), // Dependencies
+            config.getPluginSoftDependencies(), // Soft Depends
+            config.getLoadBeforePlugins(), // Load Before
+            config.getVersion(),
+            Map.of(), // Commands, we use a separate system
+            config.getDescription(),
+            config.getAuthors(),
+            config.getContributors(),
+            config.getWebsite(),
+            config.getLoggerPrefix(),
+            config.getLoadOrder(),
+            config.getPermissions(),
+            config.getPermissionDefault(),
+            Set.of(), // Aware api
+            config.getAPIVersion(),
+            List.of() // Libraries
+        );
+
+        File dataFolder = new File(Bukkit.getPluginsFolder(), pluginDescriptionFile.getName());
+
+        plugin.init(Bukkit.getServer(), pluginDescriptionFile, dataFolder, this.source.toFile(), this, config, this.logger);
+
+        this.loadedJavaPlugin = plugin;
+    }
+
+    @Nullable
+    @Override
+    public JavaPlugin getPlugin() {
+        return this.loadedJavaPlugin;
+    }
+
+    @Override
+    public String toString() {
+        return "PaperPluginClassLoader{" +
+            "libraryLoader=" + this.libraryLoader +
+            ", seenIllegalAccess=" + this.seenIllegalAccess +
+            ", loadedJavaPlugin=" + this.loadedJavaPlugin +
+            '}';
+    }
+
+    @Override
+    public void close() throws IOException {
+        try (this.jar; this.libraryLoader) {
+            super.close();
+        }
+    }
+
+    @Override
+    public @Nullable PluginClassLoaderGroup getGroup() {
+        return this.group;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/PaperSimplePluginClassLoader.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/PaperSimplePluginClassLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..967465e542483e93a736129b5f5c6622cefd33fa
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/PaperSimplePluginClassLoader.java
@@ -0,0 +1,116 @@
+package io.papermc.paper.plugin.entrypoint.classloader;
+
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.util.NamespaceChecker;
+import org.jetbrains.annotations.ApiStatus;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.nio.file.Path;
+import java.security.CodeSigner;
+import java.security.CodeSource;
+import java.util.Enumeration;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+import java.util.jar.Manifest;
+
+/**
+ * Represents a simple classloader used for paper plugin bootstrappers.
+ */
+@ApiStatus.Internal
+public class PaperSimplePluginClassLoader extends URLClassLoader {
+
+    static {
+        ClassLoader.registerAsParallelCapable();
+    }
+
+    protected final PluginMeta configuration;
+    protected final Path source;
+    protected final Manifest jarManifest;
+    protected final URL jarUrl;
+    protected final JarFile jar;
+
+    public PaperSimplePluginClassLoader(Path source, JarFile file, PluginMeta configuration, ClassLoader parentLoader) throws IOException {
+        super(source.getFileName().toString(), new URL[]{source.toUri().toURL()}, parentLoader);
+
+        this.source = source;
+        this.jarManifest = file.getManifest();
+        this.jarUrl = source.toUri().toURL();
+        this.configuration = configuration;
+        this.jar = file;
+    }
+
+    @Override
+    public URL getResource(String name) {
+        return this.findResource(name);
+    }
+
+    @Override
+    public Enumeration<URL> getResources(String name) throws IOException {
+        return this.findResources(name);
+    }
+
+    // Bytecode modification supported loader
+    @Override
+    protected Class<?> findClass(String name) throws ClassNotFoundException {
+        NamespaceChecker.validateNameSpaceForClassloading(name);
+
+        // See UrlClassLoader#findClass(String)
+        String path = name.replace('.', '/').concat(".class");
+        JarEntry entry = this.jar.getJarEntry(path);
+        if (entry == null) {
+            throw new ClassNotFoundException(name);
+        }
+
+        // See URLClassLoader#defineClass(String, Resource)
+        byte[] classBytes;
+
+        try (InputStream is = this.jar.getInputStream(entry)) {
+            classBytes = is.readAllBytes();
+        } catch (IOException ex) {
+            throw new ClassNotFoundException(name, ex);
+        }
+
+        classBytes = ClassloaderBytecodeModifier.bytecodeModifier().modify(this.configuration, classBytes);
+
+        int dot = name.lastIndexOf('.');
+        if (dot != -1) {
+            String pkgName = name.substring(0, dot);
+            // Get defined package does not correctly handle sealed packages.
+            if (this.getDefinedPackage(pkgName) == null) {
+                try {
+                    if (this.jarManifest != null) {
+                        this.definePackage(pkgName, this.jarManifest, this.jarUrl);
+                    } else {
+                        this.definePackage(pkgName, null, null, null, null, null, null, null);
+                    }
+                } catch (IllegalArgumentException ex) {
+                    // parallel-capable class loaders: re-verify in case of a
+                    // race condition
+                    if (this.getDefinedPackage(pkgName) == null) {
+                        // Should never happen
+                        throw new IllegalStateException("Cannot find package " + pkgName);
+                    }
+                }
+            }
+        }
+
+        CodeSigner[] signers = entry.getCodeSigners();
+        CodeSource source = new CodeSource(this.jarUrl, signers);
+
+        return this.defineClass(name, classBytes, 0, classBytes.length, source);
+    }
+
+    @Override
+    public String toString() {
+        return "PaperSimplePluginClassLoader{" +
+            "configuration=" + this.configuration +
+            ", source=" + this.source +
+            ", jarManifest=" + this.jarManifest +
+            ", jarUrl=" + this.jarUrl +
+            ", jar=" + this.jar +
+            '}';
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/DependencyBasedPluginClassLoaderGroup.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/DependencyBasedPluginClassLoaderGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..eaf5c794cbe8d6138c9d60eaae20f5fc7711f541
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/DependencyBasedPluginClassLoaderGroup.java
@@ -0,0 +1,47 @@
+package io.papermc.paper.plugin.entrypoint.classloader.group;
+
+import io.papermc.paper.plugin.provider.classloader.ClassLoaderAccess;
+import io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader;
+import org.jetbrains.annotations.ApiStatus;
+
+import java.util.ArrayList;
+
+@ApiStatus.Internal
+public class DependencyBasedPluginClassLoaderGroup extends SimpleListPluginClassLoaderGroup {
+
+    private final GlobalPluginClassLoaderGroup globalPluginClassLoaderGroup;
+    private final ClassLoaderAccess access;
+
+    public DependencyBasedPluginClassLoaderGroup(GlobalPluginClassLoaderGroup globalPluginClassLoaderGroup, ClassLoaderAccess access) {
+        super(new ArrayList<>());
+        this.access = access;
+        this.globalPluginClassLoaderGroup = globalPluginClassLoaderGroup;
+    }
+
+    /**
+     * This will refresh the dependencies of the current classloader.
+     */
+    public void populateDependencies() {
+        this.classloaders.clear();
+        for (ConfiguredPluginClassLoader configuredPluginClassLoader : this.globalPluginClassLoaderGroup.getClassLoaders()) {
+            if (this.access.canAccess(configuredPluginClassLoader)) {
+                this.classloaders.add(configuredPluginClassLoader);
+            }
+        }
+
+    }
+
+    @Override
+    public ClassLoaderAccess getAccess() {
+        return this.access;
+    }
+
+    @Override
+    public String toString() {
+        return "DependencyBasedPluginClassLoaderGroup{" +
+            "globalPluginClassLoaderGroup=" + this.globalPluginClassLoaderGroup +
+            ", access=" + this.access +
+            ", classloaders=" + this.classloaders +
+            '}';
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/GlobalPluginClassLoaderGroup.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/GlobalPluginClassLoaderGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..2a4933088928a51c8135a3a60b7447d9d10c66c4
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/GlobalPluginClassLoaderGroup.java
@@ -0,0 +1,18 @@
+package io.papermc.paper.plugin.entrypoint.classloader.group;
+
+import io.papermc.paper.plugin.provider.classloader.ClassLoaderAccess;
+import org.jetbrains.annotations.ApiStatus;
+
+@ApiStatus.Internal
+public class GlobalPluginClassLoaderGroup extends SimpleListPluginClassLoaderGroup {
+
+    @Override
+    public ClassLoaderAccess getAccess() {
+        return (v) -> true;
+    }
+
+    @Override
+    public String toString() {
+        return "GLOBAL:" + super.toString();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/LockingClassLoaderGroup.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/LockingClassLoaderGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..95ed6aa1495b21bd3f4692ee6b0f8412ebbfff5b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/LockingClassLoaderGroup.java
@@ -0,0 +1,76 @@
+package io.papermc.paper.plugin.entrypoint.classloader.group;
+
+import io.papermc.paper.plugin.provider.classloader.ClassLoaderAccess;
+import io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader;
+import io.papermc.paper.plugin.provider.classloader.PluginClassLoaderGroup;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+@ApiStatus.Internal
+public class LockingClassLoaderGroup implements PluginClassLoaderGroup {
+
+    private final PluginClassLoaderGroup parent;
+    private final Map<String, ClassLockEntry> classLoadLock = new HashMap<>();
+
+    public LockingClassLoaderGroup(PluginClassLoaderGroup parent) {
+        this.parent = parent;
+    }
+
+    @Override
+    public @Nullable Class<?> getClassByName(String name, boolean resolve, ConfiguredPluginClassLoader requester) {
+        // make MT safe
+        ClassLockEntry lock;
+        synchronized (this.classLoadLock) {
+            lock = this.classLoadLock.computeIfAbsent(name, (x) -> new ClassLockEntry(new AtomicInteger(0), new ReentrantReadWriteLock()));
+            lock.count.incrementAndGet();
+        }
+        lock.reentrantReadWriteLock.writeLock().lock();
+        try {
+            return parent.getClassByName(name, resolve, requester);
+        } finally {
+            synchronized (this.classLoadLock) {
+                lock.reentrantReadWriteLock.writeLock().unlock();
+                if (lock.count.get() == 1) {
+                    this.classLoadLock.remove(name);
+                } else {
+                    lock.count.decrementAndGet();
+                }
+            }
+        }
+    }
+
+    @Override
+    public void remove(ConfiguredPluginClassLoader configuredPluginClassLoader) {
+        this.parent.remove(configuredPluginClassLoader);
+    }
+
+    @Override
+    public void add(ConfiguredPluginClassLoader configuredPluginClassLoader) {
+        this.parent.add(configuredPluginClassLoader);
+    }
+
+    @Override
+    public ClassLoaderAccess getAccess() {
+        return this.parent.getAccess();
+    }
+
+    public PluginClassLoaderGroup getParent() {
+        return parent;
+    }
+
+    record ClassLockEntry(AtomicInteger count, ReentrantReadWriteLock reentrantReadWriteLock) {
+    }
+
+    @Override
+    public String toString() {
+        return "LockingClassLoaderGroup{" +
+            "parent=" + this.parent +
+            ", classLoadLock=" + this.classLoadLock +
+            '}';
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/PaperPluginClassLoaderStorage.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/PaperPluginClassLoaderStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..e6fcdeb96356ff4713627b1458ac8bbfad1866b1
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/PaperPluginClassLoaderStorage.java
@@ -0,0 +1,93 @@
+package io.papermc.paper.plugin.entrypoint.classloader.group;
+
+import io.papermc.paper.plugin.provider.classloader.ClassLoaderAccess;
+import io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader;
+import io.papermc.paper.plugin.provider.classloader.PaperClassLoaderStorage;
+import io.papermc.paper.plugin.provider.classloader.PluginClassLoaderGroup;
+import org.bukkit.plugin.java.PluginClassLoader;
+import org.jetbrains.annotations.ApiStatus;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+/**
+ * This is used for connecting multiple classloaders.
+ */
+public final class PaperPluginClassLoaderStorage implements PaperClassLoaderStorage {
+
+    private final GlobalPluginClassLoaderGroup globalGroup = new GlobalPluginClassLoaderGroup();
+    private final List<PluginClassLoaderGroup> groups = new CopyOnWriteArrayList<>();
+
+    public PaperPluginClassLoaderStorage() {
+        this.groups.add(this.globalGroup);
+    }
+
+    @Override
+    public PluginClassLoaderGroup registerSpigotGroup(PluginClassLoader pluginClassLoader) {
+        return this.registerGroup(pluginClassLoader, new SpigotPluginClassLoaderGroup(this.globalGroup, (library) -> {
+            return pluginClassLoader.dependencyContext.isTransitiveDependency(pluginClassLoader.getConfiguration(), library.getConfiguration());
+        }, pluginClassLoader));
+    }
+
+    @Override
+    public PluginClassLoaderGroup registerOpenGroup(ConfiguredPluginClassLoader classLoader) {
+        return this.registerGroup(classLoader, this.globalGroup);
+    }
+
+    @Override
+    public PluginClassLoaderGroup registerAccessBackedGroup(ConfiguredPluginClassLoader classLoader, ClassLoaderAccess access) {
+        List<ConfiguredPluginClassLoader> allowedLoaders = new ArrayList<>();
+        for (ConfiguredPluginClassLoader configuredPluginClassLoader : this.globalGroup.getClassLoaders()) {
+            if (access.canAccess(configuredPluginClassLoader)) {
+                allowedLoaders.add(configuredPluginClassLoader);
+            }
+        }
+
+        return this.registerGroup(classLoader, new StaticPluginClassLoaderGroup(allowedLoaders, access, classLoader));
+    }
+
+    private PluginClassLoaderGroup registerGroup(ConfiguredPluginClassLoader classLoader, PluginClassLoaderGroup group) {
+        // Now add this classloader to any groups that allows it (includes global)
+        for (PluginClassLoaderGroup loaderGroup : this.groups) {
+            if (loaderGroup.getAccess().canAccess(classLoader)) {
+                loaderGroup.add(classLoader);
+            }
+        }
+
+        group = new LockingClassLoaderGroup(group);
+        this.groups.add(group);
+        return group;
+    }
+
+    @Override
+    public void unregisterClassloader(ConfiguredPluginClassLoader configuredPluginClassLoader) {
+        this.globalGroup.remove(configuredPluginClassLoader);
+        this.groups.remove(configuredPluginClassLoader.getGroup());
+        for (PluginClassLoaderGroup group : this.groups) {
+            group.remove(configuredPluginClassLoader);
+        }
+    }
+
+    @Override
+    public boolean registerUnsafePlugin(ConfiguredPluginClassLoader pluginLoader) {
+        if (this.globalGroup.getClassLoaders().contains(pluginLoader)) {
+            return false;
+        } else {
+            this.globalGroup.add(pluginLoader);
+            return true;
+        }
+    }
+
+    // Debug only
+    @ApiStatus.Internal
+    public GlobalPluginClassLoaderGroup getGlobalGroup() {
+        return this.globalGroup;
+    }
+
+    // Debug only
+    @ApiStatus.Internal
+    public List<PluginClassLoaderGroup> getGroups() {
+        return this.groups;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/SimpleListPluginClassLoaderGroup.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/SimpleListPluginClassLoaderGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..23b6cb297f46c9c2b2944a3ab4031c31414620ad
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/SimpleListPluginClassLoaderGroup.java
@@ -0,0 +1,69 @@
+package io.papermc.paper.plugin.entrypoint.classloader.group;
+
+import io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader;
+import io.papermc.paper.plugin.provider.classloader.PluginClassLoaderGroup;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+@ApiStatus.Internal
+public abstract class SimpleListPluginClassLoaderGroup implements PluginClassLoaderGroup {
+
+    private static final boolean DISABLE_CLASS_PRIORITIZATION = Boolean.getBoolean("Paper.DisableClassPrioritization");
+
+    protected final List<ConfiguredPluginClassLoader> classloaders;
+
+    protected SimpleListPluginClassLoaderGroup() {
+        this(new CopyOnWriteArrayList<>());
+    }
+
+    protected SimpleListPluginClassLoaderGroup(List<ConfiguredPluginClassLoader> classloaders) {
+        this.classloaders = classloaders;
+    }
+
+    @Override
+    public @Nullable Class<?> getClassByName(String name, boolean resolve, ConfiguredPluginClassLoader requester) {
+        if (!DISABLE_CLASS_PRIORITIZATION) {
+            try {
+                return this.lookupClass(name, false, requester); // First check the requester
+            } catch (ClassNotFoundException ignored) {
+            }
+        }
+
+        for (ConfiguredPluginClassLoader loader : this.classloaders) {
+            try {
+                return this.lookupClass(name, resolve, loader);
+            } catch (ClassNotFoundException ignored) {
+            }
+        }
+
+        return null;
+    }
+
+    protected Class<?> lookupClass(String name, boolean resolve, ConfiguredPluginClassLoader current) throws ClassNotFoundException {
+        return current.loadClass(name, resolve, false, true);
+    }
+
+    @Override
+    public void remove(ConfiguredPluginClassLoader configuredPluginClassLoader) {
+        this.classloaders.remove(configuredPluginClassLoader);
+    }
+
+    @Override
+    public void add(ConfiguredPluginClassLoader configuredPluginClassLoader) {
+        this.classloaders.add(configuredPluginClassLoader);
+    }
+
+    public List<ConfiguredPluginClassLoader> getClassLoaders() {
+        return classloaders;
+    }
+
+    @Override
+    public String toString() {
+        return "SimpleListPluginClassLoaderGroup{" +
+            "classloaders=" + this.classloaders +
+            '}';
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/SingletonPluginClassLoaderGroup.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/SingletonPluginClassLoaderGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..3b670bd6b35ae7f56488a9b50df54709a0b28901
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/SingletonPluginClassLoaderGroup.java
@@ -0,0 +1,60 @@
+package io.papermc.paper.plugin.entrypoint.classloader.group;
+
+import io.papermc.paper.plugin.provider.classloader.ClassLoaderAccess;
+import io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader;
+import io.papermc.paper.plugin.provider.classloader.PluginClassLoaderGroup;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Nullable;
+
+@ApiStatus.Internal
+public class SingletonPluginClassLoaderGroup implements PluginClassLoaderGroup {
+
+    private final ConfiguredPluginClassLoader configuredPluginClassLoader;
+    private final Access access;
+
+    public SingletonPluginClassLoaderGroup(ConfiguredPluginClassLoader configuredPluginClassLoader) {
+        this.configuredPluginClassLoader = configuredPluginClassLoader;
+        this.access = new Access();
+    }
+
+    @Override
+    public @Nullable Class<?> getClassByName(String name, boolean resolve, ConfiguredPluginClassLoader requester) {
+        try {
+            return this.configuredPluginClassLoader.loadClass(name, resolve, false, true);
+        } catch (ClassNotFoundException ignored) {
+        }
+
+        return null;
+    }
+
+    @Override
+    public void remove(ConfiguredPluginClassLoader configuredPluginClassLoader) {
+    }
+
+    @Override
+    public void add(ConfiguredPluginClassLoader configuredPluginClassLoader) {
+    }
+
+    @Override
+    public ClassLoaderAccess getAccess() {
+        return this.access;
+    }
+
+    @ApiStatus.Internal
+    private class Access implements ClassLoaderAccess {
+
+        @Override
+        public boolean canAccess(ConfiguredPluginClassLoader classLoader) {
+            return SingletonPluginClassLoaderGroup.this.configuredPluginClassLoader == classLoader;
+        }
+
+    }
+
+    @Override
+    public String toString() {
+        return "SingletonPluginClassLoaderGroup{" +
+            "configuredPluginClassLoader=" + this.configuredPluginClassLoader +
+            ", access=" + this.access +
+            '}';
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/SpigotPluginClassLoaderGroup.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/SpigotPluginClassLoaderGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..5a9f5b18e24a89dd642149a7a3d49390328b864b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/SpigotPluginClassLoaderGroup.java
@@ -0,0 +1,58 @@
+package io.papermc.paper.plugin.entrypoint.classloader.group;
+
+import io.papermc.paper.plugin.provider.classloader.ClassLoaderAccess;
+import io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader;
+import org.bukkit.plugin.java.PluginClassLoader;
+import org.jetbrains.annotations.ApiStatus;
+
+import java.util.function.Predicate;
+
+/**
+ * Spigot classloaders have the ability to see everything.
+ * However, libraries are ONLY shared depending on their dependencies.
+ */
+@ApiStatus.Internal
+public class SpigotPluginClassLoaderGroup extends SimpleListPluginClassLoaderGroup {
+
+    private final Predicate<ConfiguredPluginClassLoader> libraryClassloaderPredicate;
+    private final PluginClassLoader pluginClassLoader;
+
+    public SpigotPluginClassLoaderGroup(GlobalPluginClassLoaderGroup globalPluginClassLoaderGroup, Predicate<ConfiguredPluginClassLoader> libraryClassloaderPredicate, PluginClassLoader pluginClassLoader) {
+        super(globalPluginClassLoaderGroup.getClassLoaders());
+        this.libraryClassloaderPredicate = libraryClassloaderPredicate;
+        this.pluginClassLoader = pluginClassLoader;
+    }
+
+    // Mirrors global list
+    @Override
+    public void add(ConfiguredPluginClassLoader configuredPluginClassLoader) {
+    }
+
+    @Override
+    public void remove(ConfiguredPluginClassLoader configuredPluginClassLoader) {
+    }
+
+    // Don't allow other plugins to access spigot dependencies, they should instead reference the global list
+    @Override
+    public ClassLoaderAccess getAccess() {
+        return v -> false;
+    }
+
+    @Override
+    protected Class<?> lookupClass(String name, boolean resolve, ConfiguredPluginClassLoader current) throws ClassNotFoundException {
+        return current.loadClass(name, resolve, false, this.libraryClassloaderPredicate.test(current));
+    }
+
+    // DEBUG
+    public PluginClassLoader getPluginClassLoader() {
+        return pluginClassLoader;
+    }
+
+    @Override
+    public String toString() {
+        return "SpigotPluginClassLoaderGroup{" +
+            "libraryClassloaderPredicate=" + this.libraryClassloaderPredicate +
+            ", classloaders=" + this.classloaders +
+            '}';
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/StaticPluginClassLoaderGroup.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/StaticPluginClassLoaderGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..2412155ddfd559023f42ff534b8f06a52588e1e0
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/StaticPluginClassLoaderGroup.java
@@ -0,0 +1,40 @@
+package io.papermc.paper.plugin.entrypoint.classloader.group;
+
+import io.papermc.paper.plugin.provider.classloader.ClassLoaderAccess;
+import io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader;
+import org.jetbrains.annotations.ApiStatus;
+
+import java.util.List;
+
+@ApiStatus.Internal
+public class StaticPluginClassLoaderGroup extends SimpleListPluginClassLoaderGroup {
+
+    private final ClassLoaderAccess access;
+    // Debug only
+    private final ConfiguredPluginClassLoader mainClassloaderHolder;
+
+    public StaticPluginClassLoaderGroup(List<ConfiguredPluginClassLoader> classloaders, ClassLoaderAccess access, ConfiguredPluginClassLoader mainClassloaderHolder) {
+        super(classloaders);
+        this.access = access;
+        this.mainClassloaderHolder = mainClassloaderHolder;
+    }
+
+    @Override
+    public ClassLoaderAccess getAccess() {
+        return this.access;
+    }
+
+    // DEBUG
+    @ApiStatus.Internal
+    public ConfiguredPluginClassLoader getPluginClassloader() {
+        return this.mainClassloaderHolder;
+    }
+
+    @Override
+    public String toString() {
+        return "StaticPluginClassLoaderGroup{" +
+            "access=" + this.access +
+            ", classloaders=" + this.classloaders +
+            '}';
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/dependency/BootstrapMetaDependencyTree.java b/src/main/java/io/papermc/paper/plugin/entrypoint/dependency/BootstrapMetaDependencyTree.java
new file mode 100644
index 0000000000000000000000000000000000000000..74bf07be300d4893402614c9e9d9ac97dc574ac7
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/dependency/BootstrapMetaDependencyTree.java
@@ -0,0 +1,44 @@
+package io.papermc.paper.plugin.entrypoint.dependency;
+
+import com.google.common.graph.GraphBuilder;
+import com.google.common.graph.MutableGraph;
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.provider.configuration.PaperPluginMeta;
+
+public class BootstrapMetaDependencyTree extends MetaDependencyTree {
+    public BootstrapMetaDependencyTree() {
+        this(GraphBuilder.directed().build());
+    }
+
+    public BootstrapMetaDependencyTree(MutableGraph<String> graph) {
+        super(graph);
+    }
+
+    @Override
+    protected void registerDependencies(final String identifier, final PluginMeta meta) {
+        if (!(meta instanceof PaperPluginMeta paperPluginMeta)) {
+            throw new IllegalStateException("Only paper plugins can have a bootstrapper!");
+        }
+        // Build a validated provider's dependencies into the graph
+        for (String dependency : paperPluginMeta.getBoostrapDependencies().keySet()) {
+            this.graph.putEdge(identifier, dependency);
+        }
+    }
+
+    @Override
+    protected void unregisterDependencies(final String identifier, final PluginMeta meta) {
+        if (!(meta instanceof PaperPluginMeta paperPluginMeta)) {
+            throw new IllegalStateException("PluginMeta must be a PaperPluginMeta");
+        }
+
+        // Build a validated provider's dependencies into the graph
+        for (String dependency : paperPluginMeta.getBoostrapDependencies().keySet()) {
+            this.graph.removeEdge(identifier, dependency);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "BootstrapDependencyTree{" + "graph=" + this.graph + '}';
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/dependency/DependencyContextHolder.java b/src/main/java/io/papermc/paper/plugin/entrypoint/dependency/DependencyContextHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..f43295fdeaa587cf30c35a1d545167071d58ce4b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/dependency/DependencyContextHolder.java
@@ -0,0 +1,9 @@
+package io.papermc.paper.plugin.entrypoint.dependency;
+
+import io.papermc.paper.plugin.provider.entrypoint.DependencyContext;
+
+public interface DependencyContextHolder {
+
+    void setContext(DependencyContext context);
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/dependency/GraphDependencyContext.java b/src/main/java/io/papermc/paper/plugin/entrypoint/dependency/GraphDependencyContext.java
new file mode 100644
index 0000000000000000000000000000000000000000..45d89d060b5230461e0b6ed098ee25799cf60e98
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/dependency/GraphDependencyContext.java
@@ -0,0 +1,53 @@
+package io.papermc.paper.plugin.entrypoint.dependency;
+
+import com.google.common.graph.Graphs;
+import com.google.common.graph.MutableGraph;
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.provider.entrypoint.DependencyContext;
+
+import java.util.Set;
+
+@SuppressWarnings("UnstableApiUsage")
+public class GraphDependencyContext implements DependencyContext {
+
+    private final MutableGraph<String> dependencyGraph;
+
+    public GraphDependencyContext(MutableGraph<String> dependencyGraph) {
+        this.dependencyGraph = dependencyGraph;
+    }
+
+    @Override
+    public boolean isTransitiveDependency(PluginMeta plugin, PluginMeta depend) {
+        String pluginIdentifier = plugin.getName();
+
+        if (this.dependencyGraph.nodes().contains(pluginIdentifier)) {
+            Set<String> reachableNodes = Graphs.reachableNodes(this.dependencyGraph, pluginIdentifier);
+            if (reachableNodes.contains(depend.getName())) {
+                return true;
+            }
+            for (String provided : depend.getProvidedPlugins()) {
+                if (reachableNodes.contains(provided)) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public boolean hasDependency(String pluginIdentifier) {
+        return this.dependencyGraph.nodes().contains(pluginIdentifier);
+    }
+
+    public MutableGraph<String> getDependencyGraph() {
+        return dependencyGraph;
+    }
+
+    @Override
+    public String toString() {
+        return "GraphDependencyContext{" +
+            "dependencyGraph=" + this.dependencyGraph +
+            '}';
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/dependency/MetaDependencyTree.java b/src/main/java/io/papermc/paper/plugin/entrypoint/dependency/MetaDependencyTree.java
new file mode 100644
index 0000000000000000000000000000000000000000..40d2ea25b82e14e46aab6543d1328b6ceae1ded6
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/dependency/MetaDependencyTree.java
@@ -0,0 +1,111 @@
+package io.papermc.paper.plugin.entrypoint.dependency;
+
+import com.google.common.graph.GraphBuilder;
+import com.google.common.graph.Graphs;
+import com.google.common.graph.MutableGraph;
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.entrypoint.DependencyContext;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.HashSet;
+import java.util.Set;
+
+public abstract class MetaDependencyTree implements DependencyContext {
+
+    protected final MutableGraph<String> graph;
+
+    // We need to upkeep a separate collection since when populating
+    // a graph it adds nodes even if they are not present
+    protected final Set<String> dependencies = new HashSet<>();
+
+    public MetaDependencyTree() {
+        this(GraphBuilder.directed().build());
+    }
+
+    public MetaDependencyTree(MutableGraph<String> graph) {
+        this.graph = graph;
+    }
+
+    public void add(PluginMeta configuration) {
+        String identifier = configuration.getName();
+        // Build a validated provider's dependencies into the graph
+        this.registerDependencies(identifier, configuration);
+
+        this.graph.addNode(identifier); // Make sure dependencies at least have a node
+
+        // Add the provided plugins to the graph as well
+        for (String provides : configuration.getProvidedPlugins()) {
+            this.graph.putEdge(identifier, provides);
+            this.dependencies.add(provides);
+        }
+        this.dependencies.add(identifier);
+    }
+
+    protected abstract void registerDependencies(String identifier, PluginMeta meta);
+
+    public void remove(PluginMeta configuration) {
+        String identifier = configuration.getName();
+        // Remove a validated provider's dependencies into the graph
+        this.unregisterDependencies(identifier, configuration);
+
+        this.graph.removeNode(identifier); // Remove root node
+
+        // Remove the provided plugins to the graph as well
+        for (String provides : configuration.getProvidedPlugins()) {
+            this.graph.removeEdge(identifier, provides);
+            this.dependencies.remove(provides);
+        }
+        this.dependencies.remove(identifier);
+    }
+
+    protected abstract void unregisterDependencies(String identifier, PluginMeta meta);
+
+    @Override
+    public boolean isTransitiveDependency(@NotNull PluginMeta plugin, @NotNull PluginMeta depend) {
+        String pluginIdentifier = plugin.getName();
+
+        if (this.graph.nodes().contains(pluginIdentifier)) {
+            Set<String> reachableNodes = Graphs.reachableNodes(this.graph, pluginIdentifier);
+            if (reachableNodes.contains(depend.getName())) {
+                return true;
+            }
+            for (String provided : depend.getProvidedPlugins()) {
+                if (reachableNodes.contains(provided)) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public boolean hasDependency(@NotNull String pluginIdentifier) {
+        return this.dependencies.contains(pluginIdentifier);
+    }
+
+    public void addDirectDependency(String dependency) {
+        this.dependencies.add(dependency);
+    }
+
+    @Override
+    public String toString() {
+        return "SimpleDependencyTree{" +
+            "graph=" + this.graph +
+            '}';
+    }
+
+    public MutableGraph<String> getGraph() {
+        return graph;
+    }
+
+    public void add(PluginProvider<?> provider) {
+        this.add(provider.getMeta());
+    }
+
+    public void remove(PluginProvider<?> provider) {
+        this.remove(provider.getMeta());
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/dependency/SimpleMetaDependencyTree.java b/src/main/java/io/papermc/paper/plugin/entrypoint/dependency/SimpleMetaDependencyTree.java
new file mode 100644
index 0000000000000000000000000000000000000000..6a0972ddfeb619ebb542d27c8caf4df44132923f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/dependency/SimpleMetaDependencyTree.java
@@ -0,0 +1,34 @@
+package io.papermc.paper.plugin.entrypoint.dependency;
+
+import com.google.common.graph.MutableGraph;
+import io.papermc.paper.plugin.configuration.PluginMeta;
+
+public class SimpleMetaDependencyTree extends MetaDependencyTree {
+
+    public SimpleMetaDependencyTree() {
+    }
+
+    public SimpleMetaDependencyTree(final MutableGraph<String> graph) {
+        super(graph);
+    }
+
+    @Override
+    protected void registerDependencies(final String identifier, final PluginMeta meta) {
+        for (String dependency : meta.getPluginDependencies()) {
+            this.graph.putEdge(identifier, dependency);
+        }
+        for (String dependency : meta.getPluginSoftDependencies()) {
+            this.graph.putEdge(identifier, dependency);
+        }
+    }
+
+    @Override
+    protected void unregisterDependencies(final String identifier, final PluginMeta meta) {
+        for (String dependency : meta.getPluginDependencies()) {
+            this.graph.removeEdge(identifier, dependency);
+        }
+        for (String dependency : meta.getPluginSoftDependencies()) {
+            this.graph.removeEdge(identifier, dependency);
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/JohnsonSimpleCycles.java b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/JohnsonSimpleCycles.java
new file mode 100644
index 0000000000000000000000000000000000000000..08ad2bfa096fbfaccf8d43e770a5e54492c811df
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/JohnsonSimpleCycles.java
@@ -0,0 +1,357 @@
+/*
+ * (C) Copyright 2013-2021, by Nikolay Ognyanov and Contributors.
+ *
+ * JGraphT : a free Java graph-theory library
+ *
+ * See the CONTRIBUTORS.md file distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the
+ * GNU Lesser General Public License v2.1 or later
+ * which is available at
+ * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later
+ */
+
+// MODIFICATIONS:
+// - Modified to use a guava graph directly
+
+package io.papermc.paper.plugin.entrypoint.strategy;
+
+import com.google.common.base.Preconditions;
+import com.google.common.graph.EndpointPair;
+import com.google.common.graph.Graph;
+import com.google.common.graph.GraphBuilder;
+import com.google.common.graph.MutableGraph;
+import com.mojang.datafixers.util.Pair;
+
+import java.util.*;
+import java.util.function.BiConsumer;
+import java.util.function.Consumer;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * Find all simple cycles of a directed graph using the Johnson's algorithm.
+ *
+ * <p>
+ * See:<br>
+ * D.B.Johnson, Finding all the elementary circuits of a directed graph, SIAM J. Comput., 4 (1975),
+ * pp. 77-84.
+ *
+ * @param <V> the vertex type.
+ *
+ * @author Nikolay Ognyanov
+ */
+public class JohnsonSimpleCycles<V>
+{
+    // The graph.
+    private Graph<V> graph;
+
+    // The main state of the algorithm.
+    private Consumer<List<V>> cycleConsumer = null;
+    private BiConsumer<V, V> cycleVertexSuccessorConsumer = null; // Paper
+    private V[] iToV = null;
+    private Map<V, Integer> vToI = null;
+    private Set<V> blocked = null;
+    private Map<V, Set<V>> bSets = null;
+    private ArrayDeque<V> stack = null;
+
+    // The state of the embedded Tarjan SCC algorithm.
+    private List<Set<V>> foundSCCs = null;
+    private int index = 0;
+    private Map<V, Integer> vIndex = null;
+    private Map<V, Integer> vLowlink = null;
+    private ArrayDeque<V> path = null;
+    private Set<V> pathSet = null;
+
+    /**
+     * Create a simple cycle finder for the specified graph.
+     *
+     * @param graph - the DirectedGraph in which to find cycles.
+     *
+     * @throws IllegalArgumentException if the graph argument is <code>
+     * null</code>.
+     */
+    public JohnsonSimpleCycles(Graph<V> graph)
+    {
+        Preconditions.checkState(graph.isDirected(), "Graph must be directed");
+        this.graph = graph;
+    }
+
+    public boolean hasEdgeConnecting(V nodeU, V nodeV) {
+        checkNotNull(nodeU);
+        checkNotNull(nodeV);
+        return graph.nodes().contains(nodeU) && graph.successors(nodeU).contains(nodeV);
+    }
+
+    /**
+     * Find the simple cycles of the graph.
+     *
+     * @return The list of all simple cycles. Possibly empty but never <code>null</code>.
+     */
+    public List<List<V>> findAndRemoveSimpleCycles()
+    {
+        List<List<V>> result = new ArrayList<>();
+        findSimpleCycles(result::add, (v, s) -> ((MutableGraph<V>) graph).removeEdge(v, s)); // Paper
+        return result;
+    }
+
+    /**
+     * Find the simple cycles of the graph.
+     *
+     * @param consumer Consumer that will be called with each cycle found.
+     */
+    public void findSimpleCycles(Consumer<List<V>> consumer, BiConsumer<V, V> vertexSuccessorConsumer) // Paper
+    {
+        if (graph == null) {
+            throw new IllegalArgumentException("Null graph.");
+        }
+        cycleVertexSuccessorConsumer = vertexSuccessorConsumer; // Paper
+        initState(consumer);
+
+        int startIndex = 0;
+        int size = graph.nodes().size();
+        while (startIndex < size) {
+            Pair<Graph<V>, Integer> minSCCGResult = findMinSCSG(startIndex);
+            if (minSCCGResult != null) {
+                startIndex = minSCCGResult.getSecond();
+                Graph<V> scg = minSCCGResult.getFirst();
+                V startV = toV(startIndex);
+                for (V v : scg.successors(startV)) {
+                    blocked.remove(v);
+                    getBSet(v).clear();
+                }
+                findCyclesInSCG(startIndex, startIndex, scg);
+                startIndex++;
+            } else {
+                break;
+            }
+        }
+
+        clearState();
+    }
+
+    private Pair<Graph<V>, Integer> findMinSCSG(int startIndex)
+    {
+        /*
+         * Per Johnson : "adjacency structure of strong component $K$ with least vertex in subgraph
+         * of $G$ induced by $(s, s + 1, n)$". Or in contemporary terms: the strongly connected
+         * component of the subgraph induced by $(v_1, \dotso ,v_n)$ which contains the minimum
+         * (among those SCCs) vertex index. We return that index together with the graph.
+         */
+        initMinSCGState();
+
+        List<Set<V>> foundSCCs = findSCCS(startIndex);
+
+        // find the SCC with the minimum index
+        int minIndexFound = Integer.MAX_VALUE;
+        Set<V> minSCC = null;
+        for (Set<V> scc : foundSCCs) {
+            for (V v : scc) {
+                int t = toI(v);
+                if (t < minIndexFound) {
+                    minIndexFound = t;
+                    minSCC = scc;
+                }
+            }
+        }
+        if (minSCC == null) {
+            return null;
+        }
+
+        // build a graph for the SCC found
+        MutableGraph<V> dependencyGraph = GraphBuilder.directed().allowsSelfLoops(true).build();
+
+        for (V v : minSCC) {
+            for (V w : minSCC) {
+                if (hasEdgeConnecting(v, w)) {
+                    dependencyGraph.putEdge(v, w);
+                }
+            }
+        }
+
+        Pair<Graph<V>, Integer> result = Pair.of(dependencyGraph, minIndexFound);
+        clearMinSCCState();
+        return result;
+    }
+
+    private List<Set<V>> findSCCS(int startIndex)
+    {
+        // Find SCCs in the subgraph induced
+        // by vertices startIndex and beyond.
+        // A call to StrongConnectivityAlgorithm
+        // would be too expensive because of the
+        // need to materialize the subgraph.
+        // So - do a local search by the Tarjan's
+        // algorithm and pretend that vertices
+        // with an index smaller than startIndex
+        // do not exist.
+        for (V v : graph.nodes()) {
+            int vI = toI(v);
+            if (vI < startIndex) {
+                continue;
+            }
+            if (!vIndex.containsKey(v)) {
+                getSCCs(startIndex, vI);
+            }
+        }
+        List<Set<V>> result = foundSCCs;
+        foundSCCs = null;
+        return result;
+    }
+
+    private void getSCCs(int startIndex, int vertexIndex)
+    {
+        V vertex = toV(vertexIndex);
+        vIndex.put(vertex, index);
+        vLowlink.put(vertex, index);
+        index++;
+        path.push(vertex);
+        pathSet.add(vertex);
+
+        Set<V> edges = graph.successors(vertex);
+        for (V successor : edges) {
+            int successorIndex = toI(successor);
+            if (successorIndex < startIndex) {
+                continue;
+            }
+            if (!vIndex.containsKey(successor)) {
+                getSCCs(startIndex, successorIndex);
+                vLowlink.put(vertex, Math.min(vLowlink.get(vertex), vLowlink.get(successor)));
+            } else if (pathSet.contains(successor)) {
+                vLowlink.put(vertex, Math.min(vLowlink.get(vertex), vIndex.get(successor)));
+            }
+        }
+        if (vLowlink.get(vertex).equals(vIndex.get(vertex))) {
+            Set<V> result = new HashSet<>();
+            V temp;
+            do {
+                temp = path.pop();
+                pathSet.remove(temp);
+                result.add(temp);
+            } while (!vertex.equals(temp));
+            if (result.size() == 1) {
+                V v = result.iterator().next();
+                if (graph.edges().contains(vertex)) {
+                    foundSCCs.add(result);
+                }
+            } else {
+                foundSCCs.add(result);
+            }
+        }
+    }
+
+    private boolean findCyclesInSCG(int startIndex, int vertexIndex, Graph<V> scg)
+    {
+        /*
+         * Find cycles in a strongly connected graph per Johnson.
+         */
+        boolean foundCycle = false;
+        V vertex = toV(vertexIndex);
+        stack.push(vertex);
+        blocked.add(vertex);
+
+        for (V successor : scg.successors(vertex)) {
+            int successorIndex = toI(successor);
+            if (successorIndex == startIndex) {
+                List<V> cycle = new ArrayList<>(stack.size());
+                stack.descendingIterator().forEachRemaining(cycle::add);
+                cycleConsumer.accept(cycle);
+                cycleVertexSuccessorConsumer.accept(vertex, successor); // Paper
+                //foundCycle = true; // Paper
+            } else if (!blocked.contains(successor)) {
+                boolean gotCycle = findCyclesInSCG(startIndex, successorIndex, scg);
+                foundCycle = foundCycle || gotCycle;
+            }
+        }
+        if (foundCycle) {
+            unblock(vertex);
+        } else {
+            for (V w : scg.successors(vertex)) {
+                Set<V> bSet = getBSet(w);
+                bSet.add(vertex);
+            }
+        }
+        stack.pop();
+        return foundCycle;
+    }
+
+    private void unblock(V vertex)
+    {
+        blocked.remove(vertex);
+        Set<V> bSet = getBSet(vertex);
+        while (bSet.size() > 0) {
+            V w = bSet.iterator().next();
+            bSet.remove(w);
+            if (blocked.contains(w)) {
+                unblock(w);
+            }
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    private void initState(Consumer<List<V>> consumer)
+    {
+        cycleConsumer = consumer;
+        iToV = (V[]) graph.nodes().toArray();
+        vToI = new HashMap<>();
+        blocked = new HashSet<>();
+        bSets = new HashMap<>();
+        stack = new ArrayDeque<>();
+
+        for (int i = 0; i < iToV.length; i++) {
+            vToI.put(iToV[i], i);
+        }
+    }
+
+    private void clearState()
+    {
+        cycleConsumer = null;
+        iToV = null;
+        vToI = null;
+        blocked = null;
+        bSets = null;
+        stack = null;
+    }
+
+    private void initMinSCGState()
+    {
+        index = 0;
+        foundSCCs = new ArrayList<>();
+        vIndex = new HashMap<>();
+        vLowlink = new HashMap<>();
+        path = new ArrayDeque<>();
+        pathSet = new HashSet<>();
+    }
+
+    private void clearMinSCCState()
+    {
+        index = 0;
+        foundSCCs = null;
+        vIndex = null;
+        vLowlink = null;
+        path = null;
+        pathSet = null;
+    }
+
+    private Integer toI(V vertex)
+    {
+        return vToI.get(vertex);
+    }
+
+    private V toV(Integer i)
+    {
+        return iToV[i];
+    }
+
+    private Set<V> getBSet(V v)
+    {
+        // B sets typically not all needed,
+        // so instantiate lazily.
+        return bSets.computeIfAbsent(v, k -> new HashSet<>());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/LegacyPluginLoadingStrategy.java b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/LegacyPluginLoadingStrategy.java
new file mode 100644
index 0000000000000000000000000000000000000000..7c507dc176a5522c2faa177579719f069b702860
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/LegacyPluginLoadingStrategy.java
@@ -0,0 +1,262 @@
+package io.papermc.paper.plugin.entrypoint.strategy;
+
+import com.google.common.graph.MutableGraph;
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.entrypoint.dependency.MetaDependencyTree;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.type.paper.PaperPluginParent;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.plugin.UnknownDependencyException;
+
+import java.util.*;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+@SuppressWarnings("UnstableApiUsage")
+public class LegacyPluginLoadingStrategy<T> implements ProviderLoadingStrategy<T> {
+
+    private static final Logger LOGGER = Logger.getLogger("LegacyPluginLoadingStrategy");
+    private final ProviderConfiguration<T> configuration;
+
+    public LegacyPluginLoadingStrategy(ProviderConfiguration<T> onLoad) {
+        this.configuration = onLoad;
+    }
+
+    @Override
+    public List<ProviderPair<T>> loadProviders(List<PluginProvider<T>> providers, MetaDependencyTree dependencyTree) {
+        List<ProviderPair<T>> javapluginsLoaded = new ArrayList<>();
+        MutableGraph<String> dependencyGraph = dependencyTree.getGraph();
+
+        Map<String, PluginProvider<T>> providersToLoad = new HashMap<>();
+        Set<String> loadedPlugins = new HashSet<>();
+        Map<String, String> pluginsProvided = new HashMap<>();
+        Map<String, Collection<String>> dependencies = new HashMap<>();
+        Map<String, Collection<String>> softDependencies = new HashMap<>();
+
+        for (PluginProvider<T> provider : providers) {
+            PluginMeta configuration = provider.getMeta();
+
+            PluginProvider<T> replacedProvider = providersToLoad.put(configuration.getName(), provider);
+            dependencyTree.addDirectDependency(configuration.getName()); // add to dependency tree
+            if (replacedProvider != null) {
+                LOGGER.severe(String.format(
+                    "Ambiguous plugin name `%s' for files `%s' and `%s' in `%s'",
+                    configuration.getName(),
+                    provider.getSource(),
+                    replacedProvider.getSource(),
+                    replacedProvider.getParentSource()
+                ));
+            }
+
+            String removedProvided = pluginsProvided.remove(configuration.getName());
+            if (removedProvided != null) {
+                LOGGER.warning(String.format(
+                    "Ambiguous plugin name `%s'. It is also provided by `%s'",
+                    configuration.getName(),
+                    removedProvided
+                ));
+            }
+
+            for (String provided : configuration.getProvidedPlugins()) {
+                PluginProvider<T> pluginProvider = providersToLoad.get(provided);
+
+                if (pluginProvider != null) {
+                    LOGGER.warning(String.format(
+                        "`%s provides `%s' while this is also the name of `%s' in `%s'",
+                        provider.getSource(),
+                        provided,
+                        pluginProvider.getSource(),
+                        provider.getParentSource()
+                    ));
+                } else {
+                    String replacedPlugin = pluginsProvided.put(provided, configuration.getName());
+                    dependencyTree.addDirectDependency(provided); // add to dependency tree
+                    if (replacedPlugin != null) {
+                        LOGGER.warning(String.format(
+                            "`%s' is provided by both `%s' and `%s'",
+                            provided,
+                            configuration.getName(),
+                            replacedPlugin
+                        ));
+                    }
+                }
+            }
+
+            Collection<String> softDependencySet = provider.getMeta().getPluginSoftDependencies();
+            if (softDependencySet != null && !softDependencySet.isEmpty()) {
+                if (softDependencies.containsKey(configuration.getName())) {
+                    // Duplicates do not matter, they will be removed together if applicable
+                    softDependencies.get(configuration.getName()).addAll(softDependencySet);
+                } else {
+                    softDependencies.put(configuration.getName(), new LinkedList<String>(softDependencySet));
+                }
+
+                for (String depend : softDependencySet) {
+                    dependencyGraph.putEdge(configuration.getName(), depend);
+                }
+            }
+
+            Collection<String> dependencySet = provider.getMeta().getPluginDependencies();
+            if (dependencySet != null && !dependencySet.isEmpty()) {
+                dependencies.put(configuration.getName(), new LinkedList<String>(dependencySet));
+
+                for (String depend : dependencySet) {
+                    dependencyGraph.putEdge(configuration.getName(), depend);
+                }
+            }
+
+            Collection<String> loadBeforeSet = provider.getMeta().getLoadBeforePlugins();
+            if (loadBeforeSet != null && !loadBeforeSet.isEmpty()) {
+                for (String loadBeforeTarget : loadBeforeSet) {
+                    if (softDependencies.containsKey(loadBeforeTarget)) {
+                        softDependencies.get(loadBeforeTarget).add(configuration.getName());
+                    } else {
+                        // softDependencies is never iterated, so 'ghost' plugins aren't an issue
+                        Collection<String> shortSoftDependency = new LinkedList<String>();
+                        shortSoftDependency.add(configuration.getName());
+                        softDependencies.put(loadBeforeTarget, shortSoftDependency);
+                    }
+
+                    dependencyGraph.putEdge(loadBeforeTarget, configuration.getName());
+                }
+            }
+        }
+
+        while (!providersToLoad.isEmpty()) {
+            boolean missingDependency = true;
+            Iterator<Map.Entry<String, PluginProvider<T>>> providerIterator = providersToLoad.entrySet().iterator();
+
+            while (providerIterator.hasNext()) {
+                Map.Entry<String, PluginProvider<T>> entry = providerIterator.next();
+                String providerIdentifier = entry.getKey();
+
+                if (dependencies.containsKey(providerIdentifier)) {
+                    Iterator<String> dependencyIterator = dependencies.get(providerIdentifier).iterator();
+                    final Set<String> missingHardDependencies = new HashSet<>(dependencies.get(providerIdentifier).size()); // Paper - list all missing hard depends
+
+                    while (dependencyIterator.hasNext()) {
+                        String dependency = dependencyIterator.next();
+
+                        // Dependency loaded
+                        if (loadedPlugins.contains(dependency)) {
+                            dependencyIterator.remove();
+
+                            // We have a dependency not found
+                        } else if (!providersToLoad.containsKey(dependency) && !pluginsProvided.containsKey(dependency)) {
+                            // Paper start
+                            missingHardDependencies.add(dependency);
+                        }
+                    }
+                    if (!missingHardDependencies.isEmpty()) {
+                        // Paper end
+                        missingDependency = false;
+                        providerIterator.remove();
+                        pluginsProvided.values().removeIf(s -> s.equals(providerIdentifier)); // Paper - remove provided plugins
+                        softDependencies.remove(providerIdentifier);
+                        dependencies.remove(providerIdentifier);
+
+                        LOGGER.log(
+                            Level.SEVERE,
+                            "Could not load '" + entry.getValue().getSource() + "' in folder '" + entry.getValue().getParentSource() + "'", // Paper
+                            new UnknownDependencyException(missingHardDependencies, providerIdentifier)); // Paper
+                    }
+
+                    if (dependencies.containsKey(providerIdentifier) && dependencies.get(providerIdentifier).isEmpty()) {
+                        dependencies.remove(providerIdentifier);
+                    }
+                }
+                if (softDependencies.containsKey(providerIdentifier)) {
+                    Iterator<String> softDependencyIterator = softDependencies.get(providerIdentifier).iterator();
+
+                    while (softDependencyIterator.hasNext()) {
+                        String softDependency = softDependencyIterator.next();
+
+                        // Soft depend is no longer around
+                        if (!providersToLoad.containsKey(softDependency) && !pluginsProvided.containsKey(softDependency)) {
+                            softDependencyIterator.remove();
+                        }
+                    }
+
+                    if (softDependencies.get(providerIdentifier).isEmpty()) {
+                        softDependencies.remove(providerIdentifier);
+                    }
+                }
+                if (!(dependencies.containsKey(providerIdentifier) || softDependencies.containsKey(providerIdentifier)) && providersToLoad.containsKey(providerIdentifier)) {
+                    // We're clear to load, no more soft or hard dependencies left
+                    PluginProvider<T> file = providersToLoad.get(providerIdentifier);
+                    providerIterator.remove();
+                    pluginsProvided.values().removeIf(s -> s.equals(providerIdentifier)); // Paper - remove provided plugins
+                    missingDependency = false;
+
+                    try {
+                        this.configuration.applyContext(file, dependencyTree);
+                        T loadedPlugin = file.createInstance();
+                        this.warnIfPaperPlugin(file);
+
+                        if (this.configuration.load(file, loadedPlugin)) {
+                            loadedPlugins.add(file.getMeta().getName());
+                            loadedPlugins.addAll(file.getMeta().getProvidedPlugins());
+                            javapluginsLoaded.add(new ProviderPair<>(file, loadedPlugin));
+                        }
+
+                    } catch (Throwable ex) {
+                        LOGGER.log(Level.SEVERE, "Could not load '" + file.getSource() + "' in folder '" + file.getParentSource() + "'", ex); // Paper
+                    }
+                }
+            }
+
+            if (missingDependency) {
+                // We now iterate over plugins until something loads
+                // This loop will ignore soft dependencies
+                providerIterator = providersToLoad.entrySet().iterator();
+
+                while (providerIterator.hasNext()) {
+                    Map.Entry<String, PluginProvider<T>> entry = providerIterator.next();
+                    String plugin = entry.getKey();
+
+                    if (!dependencies.containsKey(plugin)) {
+                        softDependencies.remove(plugin);
+                        missingDependency = false;
+                        PluginProvider<T> file = entry.getValue();
+                        providerIterator.remove();
+
+                        try {
+                            this.configuration.applyContext(file, dependencyTree);
+                            T loadedPlugin = file.createInstance();
+                            this.warnIfPaperPlugin(file);
+
+                            if (this.configuration.load(file, loadedPlugin)) {
+                                loadedPlugins.add(file.getMeta().getName());
+                                loadedPlugins.addAll(file.getMeta().getProvidedPlugins());
+                                javapluginsLoaded.add(new ProviderPair<>(file, loadedPlugin));
+                            }
+                            break;
+                        } catch (Throwable ex) {
+                            LOGGER.log(Level.SEVERE, "Could not load '" + file.getSource() + "' in folder '" + file.getParentSource() + "'", ex); // Paper
+                        }
+                    }
+                }
+                // We have no plugins left without a depend
+                if (missingDependency) {
+                    softDependencies.clear();
+                    dependencies.clear();
+                    Iterator<PluginProvider<T>> failedPluginIterator = providersToLoad.values().iterator();
+
+                    while (failedPluginIterator.hasNext()) {
+                        PluginProvider<T> file = failedPluginIterator.next();
+                        failedPluginIterator.remove();
+                        LOGGER.log(Level.SEVERE, "Could not load '" + file.getSource() + "' in folder '" + file.getParentSource() + "': circular dependency detected"); // Paper
+                    }
+                }
+            }
+        }
+
+        return javapluginsLoaded;
+    }
+
+    private void warnIfPaperPlugin(PluginProvider<T> provider) {
+        if (provider instanceof PaperPluginParent.PaperServerPluginProvider) {
+            MinecraftServer.LOGGER.warn("Loading Paper plugin in the legacy plugin loading logic. This is not recommended and may introduce some differences into load order. It's highly recommended you move away from this if you are wanting to use Paper plugins.");
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/PluginGraphCycleException.java b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/PluginGraphCycleException.java
new file mode 100644
index 0000000000000000000000000000000000000000..2ea978ac957849260e7ca69c9ff56588d0ccc41b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/PluginGraphCycleException.java
@@ -0,0 +1,19 @@
+package io.papermc.paper.plugin.entrypoint.strategy;
+
+import java.util.List;
+
+/**
+ * Indicates a dependency cycle within a provider loading sequence.
+ */
+public class PluginGraphCycleException extends RuntimeException {
+
+    private final List<List<String>> cycles;
+
+    public PluginGraphCycleException(List<List<String>> cycles) {
+        this.cycles = cycles;
+    }
+
+    public List<List<String>> getCycles() {
+        return this.cycles;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/ProviderConfiguration.java b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/ProviderConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..67c4ef672ee509deba2b4bcaac42d9db24d4c89a
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/ProviderConfiguration.java
@@ -0,0 +1,25 @@
+package io.papermc.paper.plugin.entrypoint.strategy;
+
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.entrypoint.DependencyContext;
+
+/**
+ * Used to share code with the modern and legacy plugin load strategy.
+ *
+ * @param <T>
+ */
+public interface ProviderConfiguration<T> {
+
+    void applyContext(PluginProvider<T> provider, DependencyContext dependencyContext);
+
+    boolean load(PluginProvider<T> provider, T provided);
+
+    default boolean preloadProvider(PluginProvider<T> provider) {
+        return true;
+    }
+
+    default void onGenericError(PluginProvider<T> provider) {
+
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/ProviderLoadingStrategy.java b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/ProviderLoadingStrategy.java
new file mode 100644
index 0000000000000000000000000000000000000000..a79eb9e2c8c42ecf823aecbd859576415e9981dc
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/ProviderLoadingStrategy.java
@@ -0,0 +1,22 @@
+package io.papermc.paper.plugin.entrypoint.strategy;
+
+import io.papermc.paper.plugin.entrypoint.dependency.MetaDependencyTree;
+import io.papermc.paper.plugin.provider.PluginProvider;
+
+import java.util.List;
+
+/**
+ * Used by a {@link io.papermc.paper.plugin.storage.SimpleProviderStorage} to load plugin providers in a certain order.
+ * <p>
+ * Returns providers loaded.
+ *
+ * @param <P> provider type
+ */
+public interface ProviderLoadingStrategy<P> {
+
+    List<ProviderPair<P>> loadProviders(List<PluginProvider<P>> providers, MetaDependencyTree dependencyTree);
+
+    record ProviderPair<P>(PluginProvider<P> provider, P provided) {
+
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/TopographicGraphSorter.java b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/TopographicGraphSorter.java
new file mode 100644
index 0000000000000000000000000000000000000000..5a2bcae2f093923c0d6478a9679069630bac82dd
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/TopographicGraphSorter.java
@@ -0,0 +1,59 @@
+package io.papermc.paper.plugin.entrypoint.strategy;
+
+import com.google.common.graph.Graph;
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.List;
+
+public final class TopographicGraphSorter {
+
+    // Topographically sort dependencies
+    public static <N> List<N> sortGraph(Graph<N> graph) throws PluginGraphCycleException {
+        List<N> sorted = new ArrayList<>();
+        Deque<N> roots = new ArrayDeque<>();
+        Object2IntMap<N> nonRoots = new Object2IntOpenHashMap<>();
+
+        for (N node : graph.nodes()) {
+            // Is a node being referred to by any other nodes?
+            int degree = graph.inDegree(node);
+            if (degree == 0) {
+                // Is a root
+                roots.add(node);
+            } else {
+                // Isn't a root, the number represents how many nodes connect to it.
+                nonRoots.put(node, degree);
+            }
+        }
+
+        // Pick from nodes that aren't referred to anywhere else
+        N next;
+        while ((next = roots.poll()) != null) {
+            for (N successor : graph.successors(next)) {
+                // Traverse through, moving down a degree
+                int newInDegree = nonRoots.removeInt(successor) - 1;
+
+                if (newInDegree == 0) {
+                    roots.add(successor);
+                } else {
+                    nonRoots.put(successor, newInDegree);
+                }
+
+            }
+            sorted.add(next);
+        }
+
+        if (!nonRoots.isEmpty()) {
+            throw new GraphCycleException();
+        }
+
+        return sorted;
+    }
+
+    public static final class GraphCycleException extends RuntimeException {
+
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/modern/LoadOrderTree.java b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/modern/LoadOrderTree.java
new file mode 100644
index 0000000000000000000000000000000000000000..465e3fb70a09354cf5c122be1d2e894fc2ba1df8
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/modern/LoadOrderTree.java
@@ -0,0 +1,114 @@
+package io.papermc.paper.plugin.entrypoint.strategy.modern;
+
+import com.google.common.collect.Lists;
+import com.google.common.graph.MutableGraph;
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.entrypoint.strategy.JohnsonSimpleCycles;
+import io.papermc.paper.plugin.entrypoint.strategy.PluginGraphCycleException;
+import io.papermc.paper.plugin.entrypoint.strategy.TopographicGraphSorter;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.configuration.LoadOrderConfiguration;
+import io.papermc.paper.plugin.provider.configuration.PaperPluginMeta;
+import io.papermc.paper.plugin.provider.type.spigot.SpigotPluginProvider;
+import net.minecraft.server.MinecraftServer;
+
+import java.util.*;
+
+class LoadOrderTree {
+
+    private final Map<String, PluginProvider<?>> providerMap;
+    private final MutableGraph<String> graph;
+
+    public LoadOrderTree(Map<String, PluginProvider<?>> providerMapMirror, MutableGraph<String> graph) {
+        this.providerMap = providerMapMirror;
+        this.graph = graph;
+    }
+
+    public void add(PluginProvider<?> provider) {
+        LoadOrderConfiguration configuration = provider.createConfiguration(this.providerMap);
+
+        // Build a validated provider's load order changes
+        String identifier = configuration.getMeta().getName();
+        for (String dependency : configuration.getLoadAfter()) {
+            if (this.providerMap.containsKey(dependency)) {
+                this.graph.putEdge(identifier, dependency);
+            }
+        }
+
+        for (String loadBeforeTarget : configuration.getLoadBefore()) {
+            if (this.providerMap.containsKey(loadBeforeTarget)) {
+                this.graph.putEdge(loadBeforeTarget, identifier);
+            }
+        }
+
+        this.graph.addNode(identifier); // Make sure load order has at least one node
+    }
+
+    public List<String> getLoadOrder() throws PluginGraphCycleException {
+        List<String> reversedTopographicSort;
+        try {
+            reversedTopographicSort = Lists.reverse(TopographicGraphSorter.sortGraph(this.graph));
+        } catch (TopographicGraphSorter.GraphCycleException exception) {
+            List<List<String>> cycles = new JohnsonSimpleCycles<>(this.graph).findAndRemoveSimpleCycles();
+
+            // Only log an error if at least non-Spigot plugin is present in the cycle
+            // Due to Spigot plugin metadata making no distinction between load order and dependencies (= class loader access), cycles are an unfortunate reality we have to deal with
+            Set<String> cyclingPlugins = new HashSet<>();
+            cycles.forEach(cyclingPlugins::addAll);
+            if (cyclingPlugins.stream().anyMatch(plugin -> {
+                PluginProvider<?> pluginProvider = this.providerMap.get(plugin);
+                return pluginProvider != null && !(pluginProvider instanceof SpigotPluginProvider);
+            })) {
+                logCycleError(cycles, this.providerMap);
+            }
+
+            // Try again after hopefully having removed all cycles
+            try {
+                reversedTopographicSort = Lists.reverse(TopographicGraphSorter.sortGraph(this.graph));
+            } catch (TopographicGraphSorter.GraphCycleException e) {
+                throw new PluginGraphCycleException(cycles);
+            }
+        }
+
+        return reversedTopographicSort;
+    }
+
+    private void logCycleError(List<List<String>> cycles, Map<String, PluginProvider<?>> providerMapMirror) {
+        MinecraftServer.LOGGER.error("=================================");
+        MinecraftServer.LOGGER.error("Circular plugin loading detected:");
+        for (int i = 0; i < cycles.size(); i++) {
+            List<String> cycle = cycles.get(i);
+            MinecraftServer.LOGGER.error("{}) {} -> {}", i + 1, String.join(" -> ", cycle), cycle.get(0));
+            for (String pluginName : cycle) {
+                PluginProvider<?> pluginProvider = providerMapMirror.get(pluginName);
+                if (pluginProvider == null) {
+                    return;
+                }
+
+                logPluginInfo(pluginProvider.getMeta());
+            }
+        }
+
+        MinecraftServer.LOGGER.error("Please report this to the plugin authors of the first plugin of each loop or join the PaperMC Discord server for further help.");
+        MinecraftServer.LOGGER.error("=================================");
+    }
+
+    private void logPluginInfo(PluginMeta meta) {
+        if (!meta.getLoadBeforePlugins().isEmpty()) {
+            MinecraftServer.LOGGER.error("   {} loadbefore: {}", meta.getName(), meta.getLoadBeforePlugins());
+        }
+
+        if (meta instanceof PaperPluginMeta paperPluginMeta) {
+            if (!paperPluginMeta.getLoadAfterPlugins().isEmpty()) {
+                MinecraftServer.LOGGER.error("   {} loadafter: {}", meta.getName(), paperPluginMeta.getLoadAfterPlugins());
+            }
+        } else {
+            List<String> dependencies = new ArrayList<>();
+            dependencies.addAll(meta.getPluginDependencies());
+            dependencies.addAll(meta.getPluginSoftDependencies());
+            if (!dependencies.isEmpty()) {
+                MinecraftServer.LOGGER.error("   {} depend/softdepend: {}", meta.getName(), dependencies);
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/modern/ModernPluginLoadingStrategy.java b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/modern/ModernPluginLoadingStrategy.java
new file mode 100644
index 0000000000000000000000000000000000000000..4a8aa9aa64d6a7cfed703091462913e092ac703c
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/modern/ModernPluginLoadingStrategy.java
@@ -0,0 +1,134 @@
+package io.papermc.paper.plugin.entrypoint.strategy.modern;
+
+import com.google.common.collect.Maps;
+import com.google.common.graph.GraphBuilder;
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.entrypoint.dependency.MetaDependencyTree;
+import io.papermc.paper.plugin.entrypoint.strategy.ProviderConfiguration;
+import io.papermc.paper.plugin.entrypoint.strategy.ProviderLoadingStrategy;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.plugin.UnknownDependencyException;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+@SuppressWarnings("UnstableApiUsage")
+public class ModernPluginLoadingStrategy<T> implements ProviderLoadingStrategy<T> {
+
+    private final ProviderConfiguration<T> configuration;
+
+    public ModernPluginLoadingStrategy(ProviderConfiguration<T> onLoad) {
+        this.configuration = onLoad;
+    }
+
+    @Override
+    public List<ProviderPair<T>> loadProviders(List<PluginProvider<T>> pluginProviders, MetaDependencyTree dependencyTree) {
+        Map<String, PluginProviderEntry<T>> providerMap = new HashMap<>();
+        Map<String, PluginProvider<?>> providerMapMirror = Maps.transformValues(providerMap, (entry) -> entry.provider);
+        List<PluginProvider<T>> validatedProviders = new ArrayList<>();
+
+        // Populate provider map
+        for (PluginProvider<T> provider : pluginProviders) {
+            PluginMeta providerConfig = provider.getMeta();
+            PluginProviderEntry<T> entry = new PluginProviderEntry<>(provider);
+
+            PluginProviderEntry<T> replacedProvider = providerMap.put(providerConfig.getName(), entry);
+            if (replacedProvider != null) {
+                MinecraftServer.LOGGER.error(String.format(
+                    "Ambiguous plugin name '%s' for files '%s' and '%s' in '%s'",
+                    providerConfig.getName(),
+                    provider.getSource(),
+                    replacedProvider.provider.getSource(),
+                    replacedProvider.provider.getParentSource()
+                ));
+                this.configuration.onGenericError(replacedProvider.provider);
+            }
+
+            for (String extra : providerConfig.getProvidedPlugins()) {
+                PluginProviderEntry<T> replacedExtraProvider = providerMap.putIfAbsent(extra, entry);
+                if (replacedExtraProvider != null) {
+                    MinecraftServer.LOGGER.warn(String.format(
+                        "`%s' is provided by both `%s' and `%s'",
+                        extra,
+                        providerConfig.getName(),
+                        replacedExtraProvider.provider.getMeta().getName()
+                    ));
+                }
+            }
+        }
+
+        // Populate dependency tree
+        for (PluginProvider<?> validated : pluginProviders) {
+            dependencyTree.add(validated);
+        }
+
+        // Validate providers, ensuring all of them have valid dependencies. Removing those who are invalid
+        for (PluginProvider<T> provider : pluginProviders) {
+            PluginMeta configuration = provider.getMeta();
+
+            // Populate missing dependencies to capture if there are multiple missing ones.
+            List<String> missingDependencies = provider.validateDependencies(dependencyTree);
+
+            if (missingDependencies.isEmpty()) {
+                validatedProviders.add(provider);
+            } else {
+                MinecraftServer.LOGGER.error("Could not load '%s' in '%s'".formatted(provider.getSource(), provider.getParentSource()), new UnknownDependencyException(missingDependencies, configuration.getName())); // Paper
+                // Because the validator is invalid, remove it from the provider map
+                providerMap.remove(configuration.getName());
+                // Cleanup plugins that failed to load
+                dependencyTree.remove(provider);
+                this.configuration.onGenericError(provider);
+            }
+        }
+
+        LoadOrderTree loadOrderTree = new LoadOrderTree(providerMapMirror, GraphBuilder.directed().build());
+        // Populate load order tree
+        for (PluginProvider<?> validated : validatedProviders) {
+            loadOrderTree.add(validated);
+        }
+
+        // Reverse the topographic search to let us see which providers we can load first.
+        List<String> reversedTopographicSort = loadOrderTree.getLoadOrder();
+        List<ProviderPair<T>> loadedPlugins = new ArrayList<>();
+        for (String providerIdentifier : reversedTopographicSort) {
+            // It's possible that this will be null because the above dependencies for soft/load before aren't validated if they exist.
+            // The graph could be MutableGraph<PluginProvider<T>>, but we would have to check if each dependency exists there... just
+            // nicer to do it here TBH.
+            PluginProviderEntry<T> retrievedProviderEntry = providerMap.get(providerIdentifier);
+            if (retrievedProviderEntry == null || retrievedProviderEntry.provided) {
+                // OR if this was already provided (most likely from a plugin that already "provides" that dependency)
+                // This won't matter since the provided plugin is loaded as a dependency, meaning it should have been loaded correctly anyways
+                continue; // Skip provider that doesn't exist....
+            }
+            retrievedProviderEntry.provided = true;
+            PluginProvider<T> retrievedProvider = retrievedProviderEntry.provider;
+            try {
+                this.configuration.applyContext(retrievedProvider, dependencyTree);
+
+                if (this.configuration.preloadProvider(retrievedProvider)) {
+                    T instance = retrievedProvider.createInstance();
+                    if (this.configuration.load(retrievedProvider, instance)) {
+                        loadedPlugins.add(new ProviderPair<>(retrievedProvider, instance));
+                    }
+                }
+            } catch (Throwable ex) {
+                MinecraftServer.LOGGER.error("Could not load plugin '%s' in folder '%s'".formatted(retrievedProvider.getFileName(), retrievedProvider.getParentSource()), ex); // Paper
+            }
+        }
+
+        return loadedPlugins;
+    }
+
+    private static class PluginProviderEntry<T> {
+
+        private final PluginProvider<T> provider;
+        private boolean provided;
+
+        private PluginProviderEntry(PluginProvider<T> provider) {
+            this.provider = provider;
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventRunner.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventRunner.java
new file mode 100644
index 0000000000000000000000000000000000000000..8cebeadcba517525166c094e9f5aab8238f9bb78
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventRunner.java
@@ -0,0 +1,90 @@
+package io.papermc.paper.plugin.lifecycle.event;
+
+import io.papermc.paper.plugin.bootstrap.BootstrapContext;
+import io.papermc.paper.plugin.lifecycle.event.types.AbstractLifecycleEventType;
+import io.papermc.paper.plugin.lifecycle.event.types.LifecycleEventType;
+import io.papermc.paper.plugin.lifecycle.event.types.OwnerAwareLifecycleEvent;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.plugin.Plugin;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Predicate;
+
+@DefaultQualifier(NonNull.class)
+public class LifecycleEventRunner {
+
+    public static final LifecycleEventRunner INSTANCE = new LifecycleEventRunner();
+
+    private final List<LifecycleEventType<?, ?, ?>> lifecycleEventTypes = new ArrayList<>();
+    private boolean blockPluginReloading = false;
+
+    public void checkRegisteredHandler(final LifecycleEventOwner owner, final LifecycleEventType<?, ?, ?> eventType) {
+        /*
+        Lifecycle event handlers for reloadable events that are registered from the BootstrapContext prevent
+        the server from reloading plugins. This is because reloading plugins requires disabling all the plugins,
+        running the reload logic (which would include places where these events should fire) and then re-enabling plugins.
+         */
+        if (owner instanceof BootstrapContext) {
+            this.blockPluginReloading = true;
+        }
+    }
+
+    public boolean blocksPluginReloading() {
+        return this.blockPluginReloading;
+    }
+
+    public <O extends LifecycleEventOwner, E extends LifecycleEvent, ET extends LifecycleEventType<O, E, ?>> ET addEventType(final ET eventType) {
+        this.lifecycleEventTypes.add(eventType);
+        return eventType;
+    }
+
+    public <O extends LifecycleEventOwner, E extends PaperLifecycleEvent> void callEvent(final LifecycleEventType<O, ? super E, ?> eventType, final E event) {
+        this.callEvent(eventType, event, $ -> true);
+    }
+
+    public <O extends LifecycleEventOwner, E extends PaperLifecycleEvent> void callEvent(final LifecycleEventType<O, ? super E, ?> eventType, final E event, final Predicate<? super O> ownerPredicate) {
+        final AbstractLifecycleEventType<O, ? super E, ?, ?> lifecycleEventType = (AbstractLifecycleEventType<O, ? super E, ?, ?>) eventType;
+        lifecycleEventType.forEachHandler(registeredHandler -> {
+            try {
+                if (event instanceof final OwnerAwareLifecycleEvent<?> ownerAwareEvent) {
+                    ownerAwareGenericHelper(ownerAwareEvent, registeredHandler.owner());
+                }
+                registeredHandler.lifecycleEventHandler().run(event);
+            } catch (final Throwable ex) {
+                MinecraftServer.LOGGER.error("Could not run '{}' lifecycle event handler from {}", lifecycleEventType.name(), registeredHandler.owner().getPluginMeta().getDisplayName(), ex);
+            } finally {
+                if (event instanceof final OwnerAwareLifecycleEvent<?> ownerAwareEvent) {
+                    ownerAwareEvent.setOwner(null);
+                }
+            }
+        }, handler -> ownerPredicate.test(handler.owner()));
+        event.invalidate();
+    }
+
+    private static <O extends LifecycleEventOwner> void ownerAwareGenericHelper(final OwnerAwareLifecycleEvent<O> event, final LifecycleEventOwner possibleOwner) {
+        final @Nullable O owner = event.castOwner(possibleOwner);
+        if (owner != null) {
+            event.setOwner(owner);
+        } else {
+            throw new IllegalStateException("Found invalid owner " + possibleOwner + " for event " + event);
+        }
+    }
+
+    public void unregisterAllEventHandlersFor(final Plugin plugin) {
+        for (final LifecycleEventType<?, ?, ?> lifecycleEventType : this.lifecycleEventTypes) {
+            this.removeEventHandlersOwnedBy(lifecycleEventType, plugin);
+        }
+    }
+
+    private <O extends LifecycleEventOwner> void removeEventHandlersOwnedBy(final LifecycleEventType<O, ?, ?> eventType, final Plugin possibleOwner) {
+        final AbstractLifecycleEventType<O, ?, ?, ?> lifecycleEventType = (AbstractLifecycleEventType<O, ?, ?, ?>) eventType;
+        lifecycleEventType.removeMatching(registeredHandler -> registeredHandler.owner().getPluginMeta().getName().equals(possibleOwner.getPluginMeta().getName()));
+    }
+
+    private LifecycleEventRunner() {
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/PaperLifecycleEvent.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/PaperLifecycleEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..e941405269a773e8a77e26ffd1afd84f53fadff5
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/PaperLifecycleEvent.java
@@ -0,0 +1,10 @@
+package io.papermc.paper.plugin.lifecycle.event;
+
+public interface PaperLifecycleEvent extends LifecycleEvent {
+
+    // called after all handlers have been run. Can be
+    // used to invalid various contexts to plugins can't
+    // try to re-use them by storing them from the event
+    default void invalidate() {
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/PaperLifecycleEventManager.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/PaperLifecycleEventManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..a46300c7a9278d06834262f5c6d2fe57a83da725
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/PaperLifecycleEventManager.java
@@ -0,0 +1,27 @@
+package io.papermc.paper.plugin.lifecycle.event;
+
+import com.google.common.base.Preconditions;
+import io.papermc.paper.plugin.lifecycle.event.handler.configuration.AbstractLifecycleEventHandlerConfiguration;
+import io.papermc.paper.plugin.lifecycle.event.handler.configuration.LifecycleEventHandlerConfiguration;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+import java.util.function.BooleanSupplier;
+
+@DefaultQualifier(NonNull.class)
+public final class PaperLifecycleEventManager<O extends LifecycleEventOwner> implements LifecycleEventManager<O> {
+
+    private final O owner;
+    public final BooleanSupplier registrationCheck;
+
+    public PaperLifecycleEventManager(final O owner, final BooleanSupplier registrationCheck) {
+        this.owner = owner;
+        this.registrationCheck = registrationCheck;
+    }
+
+    @Override
+    public void registerEventHandler(final LifecycleEventHandlerConfiguration<? super O> handlerConfiguration) {
+        Preconditions.checkState(this.registrationCheck.getAsBoolean(), "Cannot register lifecycle event handlers");
+        ((AbstractLifecycleEventHandlerConfiguration<? super O, ?, ?>) handlerConfiguration).registerFrom(this.owner);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/AbstractLifecycleEventHandlerConfiguration.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/AbstractLifecycleEventHandlerConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..6a85a4f581612efff04c1a955493aa2e32476277
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/AbstractLifecycleEventHandlerConfiguration.java
@@ -0,0 +1,26 @@
+package io.papermc.paper.plugin.lifecycle.event.handler.configuration;
+
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import io.papermc.paper.plugin.lifecycle.event.handler.LifecycleEventHandler;
+import io.papermc.paper.plugin.lifecycle.event.types.AbstractLifecycleEventType;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public abstract class AbstractLifecycleEventHandlerConfiguration<O extends LifecycleEventOwner, E extends LifecycleEvent, CI extends AbstractLifecycleEventHandlerConfiguration<O, E, CI>> implements LifecycleEventHandlerConfiguration<O> {
+
+    private final LifecycleEventHandler<? super E> handler;
+    private final AbstractLifecycleEventType<O, E, ?, CI> type;
+
+    protected AbstractLifecycleEventHandlerConfiguration(final LifecycleEventHandler<? super E> handler, final AbstractLifecycleEventType<O, E, ?, CI> type) {
+        this.handler = handler;
+        this.type = type;
+    }
+
+    public abstract CI config();
+
+    public final void registerFrom(final O owner) {
+        this.type.tryRegister(owner, this.handler, this.config());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/MonitorLifecycleEventHandlerConfigurationImpl.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/MonitorLifecycleEventHandlerConfigurationImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..e0699fcd0a098abc5e1206e7c0fa80b96eca7884
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/MonitorLifecycleEventHandlerConfigurationImpl.java
@@ -0,0 +1,33 @@
+package io.papermc.paper.plugin.lifecycle.event.handler.configuration;
+
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import io.papermc.paper.plugin.lifecycle.event.handler.LifecycleEventHandler;
+import io.papermc.paper.plugin.lifecycle.event.types.AbstractLifecycleEventType;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public class MonitorLifecycleEventHandlerConfigurationImpl<O extends LifecycleEventOwner, E extends LifecycleEvent> extends AbstractLifecycleEventHandlerConfiguration<O, E, MonitorLifecycleEventHandlerConfigurationImpl<O, E>> implements MonitorLifecycleEventHandlerConfiguration<O> {
+
+    private boolean monitor = false;
+
+    public MonitorLifecycleEventHandlerConfigurationImpl(final LifecycleEventHandler<? super E> handler, final AbstractLifecycleEventType<O, E, ?, MonitorLifecycleEventHandlerConfigurationImpl<O, E>> eventType) {
+        super(handler, eventType);
+    }
+
+    @Override
+    public MonitorLifecycleEventHandlerConfigurationImpl<O, E> config() {
+        return this;
+    }
+
+    public boolean isMonitor() {
+        return this.monitor;
+    }
+
+    @Override
+    public MonitorLifecycleEventHandlerConfiguration<O> monitor() {
+        this.monitor = true;
+        return this;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/PrioritizedLifecycleEventHandlerConfigurationImpl.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/PrioritizedLifecycleEventHandlerConfigurationImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..a434bbcf861c6cdbd8d43c4108125d014196fc8b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/handler/configuration/PrioritizedLifecycleEventHandlerConfigurationImpl.java
@@ -0,0 +1,44 @@
+package io.papermc.paper.plugin.lifecycle.event.handler.configuration;
+
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import io.papermc.paper.plugin.lifecycle.event.handler.LifecycleEventHandler;
+import io.papermc.paper.plugin.lifecycle.event.types.AbstractLifecycleEventType;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+import java.util.OptionalInt;
+
+@DefaultQualifier(NonNull.class)
+public class PrioritizedLifecycleEventHandlerConfigurationImpl<O extends LifecycleEventOwner, E extends LifecycleEvent> extends AbstractLifecycleEventHandlerConfiguration<O, E, PrioritizedLifecycleEventHandlerConfigurationImpl<O, E>> implements PrioritizedLifecycleEventHandlerConfiguration<O> {
+
+    private static final OptionalInt DEFAULT_PRIORITY = OptionalInt.of(0);
+    private static final OptionalInt MONITOR_PRIORITY = OptionalInt.empty();
+
+    private OptionalInt priority = DEFAULT_PRIORITY;
+
+    public PrioritizedLifecycleEventHandlerConfigurationImpl(final LifecycleEventHandler<? super E> handler, final AbstractLifecycleEventType<O, E, ?, PrioritizedLifecycleEventHandlerConfigurationImpl<O, E>> eventType) {
+        super(handler, eventType);
+    }
+
+    @Override
+    public PrioritizedLifecycleEventHandlerConfigurationImpl<O, E> config() {
+        return this;
+    }
+
+    public OptionalInt priority() {
+        return this.priority;
+    }
+
+    @Override
+    public PrioritizedLifecycleEventHandlerConfiguration<O> priority(final int priority) {
+        this.priority = OptionalInt.of(priority);
+        return this;
+    }
+
+    @Override
+    public PrioritizedLifecycleEventHandlerConfiguration<O> monitor() {
+        this.priority = MONITOR_PRIORITY;
+        return this;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/AbstractLifecycleEventType.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/AbstractLifecycleEventType.java
new file mode 100644
index 0000000000000000000000000000000000000000..cabc5a60395f1af6c1c69b173962cd34cd815c56
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/AbstractLifecycleEventType.java
@@ -0,0 +1,51 @@
+package io.papermc.paper.plugin.lifecycle.event.types;
+
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventRunner;
+import io.papermc.paper.plugin.lifecycle.event.handler.LifecycleEventHandler;
+import io.papermc.paper.plugin.lifecycle.event.handler.configuration.AbstractLifecycleEventHandlerConfiguration;
+import io.papermc.paper.plugin.lifecycle.event.handler.configuration.LifecycleEventHandlerConfiguration;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+
+@DefaultQualifier(NonNull.class)
+public abstract class AbstractLifecycleEventType<O extends LifecycleEventOwner, E extends LifecycleEvent, C extends LifecycleEventHandlerConfiguration<O>, CI extends AbstractLifecycleEventHandlerConfiguration<O, E, CI>> implements LifecycleEventType<O, E, C> {
+
+    private final String name;
+    private final Class<? extends O> ownerType;
+
+    protected AbstractLifecycleEventType(final String name, final Class<? extends O> ownerType) {
+        this.name = name;
+        this.ownerType = ownerType;
+    }
+
+    @Override
+    public String name() {
+        return this.name;
+    }
+
+    private void verifyOwner(final O owner) {
+        if (!this.ownerType.isInstance(owner)) {
+            throw new IllegalArgumentException("You cannot register the lifecycle event '" + this.name + "' on " + owner);
+        }
+    }
+
+    public abstract void forEachHandler(Consumer<? super RegisteredHandler<O, E>> consumer, Predicate<? super RegisteredHandler<O, E>> predicate);
+
+    public abstract void removeMatching(Predicate<? super RegisteredHandler<O, E>> predicate);
+
+    protected abstract void register(O owner, LifecycleEventHandler<? super E> handler, CI config);
+
+    public final void tryRegister(final O owner, final LifecycleEventHandler<? super E> handler, final CI config) {
+        this.verifyOwner(owner);
+        LifecycleEventRunner.INSTANCE.checkRegisteredHandler(owner, this);
+        this.register(owner, handler, config);
+    }
+
+    public record RegisteredHandler<O, E extends LifecycleEvent>(O owner, LifecycleEventHandler<? super E> lifecycleEventHandler) {
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/LifecycleEventTypeProviderImpl.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/LifecycleEventTypeProviderImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..0886edad92b40276f268bd745b31bac359fd28af
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/LifecycleEventTypeProviderImpl.java
@@ -0,0 +1,25 @@
+package io.papermc.paper.plugin.lifecycle.event.types;
+
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventRunner;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public final class LifecycleEventTypeProviderImpl implements LifecycleEventTypeProvider {
+
+    public static LifecycleEventTypeProviderImpl instance() {
+        return (LifecycleEventTypeProviderImpl) LifecycleEventTypeProvider.PROVIDER;
+    }
+
+    @Override
+    public <O extends LifecycleEventOwner, E extends LifecycleEvent> LifecycleEventType.Monitorable<O, E> monitor(final String name, final Class<? extends O> ownerType) {
+        return LifecycleEventRunner.INSTANCE.addEventType(new MonitorableLifecycleEventType<>(name, ownerType));
+    }
+
+    @Override
+    public <O extends LifecycleEventOwner, E extends LifecycleEvent> LifecycleEventType.Prioritizable<O, E> prioritized(final String name, final Class<? extends O> ownerType) {
+        return LifecycleEventRunner.INSTANCE.addEventType(new PrioritizableLifecycleEventType<>(name, ownerType));
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/MonitorableLifecycleEventType.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/MonitorableLifecycleEventType.java
new file mode 100644
index 0000000000000000000000000000000000000000..f70a1ebf50a2bcb43af9bc78518a1568e36291f8
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/MonitorableLifecycleEventType.java
@@ -0,0 +1,55 @@
+package io.papermc.paper.plugin.lifecycle.event.types;
+
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import io.papermc.paper.plugin.lifecycle.event.handler.LifecycleEventHandler;
+import io.papermc.paper.plugin.lifecycle.event.handler.configuration.MonitorLifecycleEventHandlerConfiguration;
+import io.papermc.paper.plugin.lifecycle.event.handler.configuration.MonitorLifecycleEventHandlerConfigurationImpl;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+
+@DefaultQualifier(NonNull.class)
+public class MonitorableLifecycleEventType<O extends LifecycleEventOwner, E extends LifecycleEvent> extends AbstractLifecycleEventType<O, E, MonitorLifecycleEventHandlerConfiguration<O>, MonitorLifecycleEventHandlerConfigurationImpl<O, E>> implements LifecycleEventType.Monitorable<O, E> {
+
+    final List<RegisteredHandler<O, E>> handlers = new ArrayList<>();
+    int nonMonitorIdx = 0;
+
+    public MonitorableLifecycleEventType(final String name, final Class<? extends O> ownerType) {
+        super(name, ownerType);
+    }
+
+    @Override
+    public MonitorLifecycleEventHandlerConfigurationImpl<O, E> newHandler(final LifecycleEventHandler<? super E> handler) {
+        return new MonitorLifecycleEventHandlerConfigurationImpl<>(handler, this);
+    }
+
+    @Override
+    protected void register(final O owner, final LifecycleEventHandler<? super E> handler, final MonitorLifecycleEventHandlerConfigurationImpl<O, E> config) {
+        final RegisteredHandler<O, E> registeredHandler = new RegisteredHandler<>(owner, handler);
+        if (!config.isMonitor()) {
+            this.handlers.add(this.nonMonitorIdx, registeredHandler);
+            this.nonMonitorIdx++;
+        } else {
+            this.handlers.add(registeredHandler);
+        }
+    }
+
+    @Override
+    public void forEachHandler(final Consumer<? super RegisteredHandler<O, E>> consumer, final Predicate<? super RegisteredHandler<O, E>> predicate) {
+        for (final RegisteredHandler<O, E> handler : this.handlers) {
+            if (predicate.test(handler)) {
+                consumer.accept(handler);
+            }
+        }
+    }
+
+    @Override
+    public void removeMatching(final Predicate<? super RegisteredHandler<O, E>> predicate) {
+        this.handlers.removeIf(predicate);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/OwnerAwareLifecycleEvent.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/OwnerAwareLifecycleEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..3e7e7474f301c0725fa2bcd6e19e476fc35f2d5a
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/OwnerAwareLifecycleEvent.java
@@ -0,0 +1,15 @@
+package io.papermc.paper.plugin.lifecycle.event.types;
+
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public interface OwnerAwareLifecycleEvent<O extends LifecycleEventOwner> extends LifecycleEvent {
+
+    void setOwner(@Nullable O owner);
+
+    @Nullable O castOwner(LifecycleEventOwner owner);
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PrioritizableLifecycleEventType.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PrioritizableLifecycleEventType.java
new file mode 100644
index 0000000000000000000000000000000000000000..c22674adc487889f950c307166dfac56c63c5887
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PrioritizableLifecycleEventType.java
@@ -0,0 +1,65 @@
+package io.papermc.paper.plugin.lifecycle.event.types;
+
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import io.papermc.paper.plugin.lifecycle.event.handler.LifecycleEventHandler;
+import io.papermc.paper.plugin.lifecycle.event.handler.configuration.PrioritizedLifecycleEventHandlerConfiguration;
+import io.papermc.paper.plugin.lifecycle.event.handler.configuration.PrioritizedLifecycleEventHandlerConfigurationImpl;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.List;
+import java.util.OptionalInt;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+
+@DefaultQualifier(NonNull.class)
+public class PrioritizableLifecycleEventType<O extends LifecycleEventOwner, E extends LifecycleEvent> extends AbstractLifecycleEventType<O, E, PrioritizedLifecycleEventHandlerConfiguration<O>, PrioritizedLifecycleEventHandlerConfigurationImpl<O, E>> implements LifecycleEventType.Prioritizable<O, E> {
+
+    private static final Comparator<PrioritizedHandler<?, ?>> COMPARATOR = Comparator.comparing(PrioritizedHandler::priority, (o1, o2) -> {
+        if (o1.equals(o2)) {
+            return 0;
+        } else if (o1.isEmpty()) {
+            return 1;
+        } else if (o2.isEmpty()) {
+            return -1;
+        } else {
+            return Integer.compare(o1.getAsInt(), o2.getAsInt());
+        }
+    });
+
+    private final List<PrioritizedHandler<O, E>> handlers = new ArrayList<>();
+
+    public PrioritizableLifecycleEventType(final String name, final Class<? extends O> ownerType) {
+        super(name, ownerType);
+    }
+
+    @Override
+    public PrioritizedLifecycleEventHandlerConfiguration<O> newHandler(final LifecycleEventHandler<? super E> handler) {
+        return new PrioritizedLifecycleEventHandlerConfigurationImpl<>(handler, this);
+    }
+
+    @Override
+    protected void register(final O owner, final LifecycleEventHandler<? super E> handler, final PrioritizedLifecycleEventHandlerConfigurationImpl<O, E> config) {
+        this.handlers.add(new PrioritizedHandler<>(new RegisteredHandler<>(owner, handler), config.priority()));
+        this.handlers.sort(COMPARATOR);
+    }
+
+    @Override
+    public void forEachHandler(final Consumer<? super RegisteredHandler<O, E>> consumer, final Predicate<? super RegisteredHandler<O, E>> predicate) {
+        for (final PrioritizedHandler<O, E> handler : this.handlers) {
+            if (predicate.test(handler.handler())) {
+                consumer.accept(handler.handler());
+            }
+        }
+    }
+
+    @Override
+    public void removeMatching(final Predicate<? super RegisteredHandler<O, E>> predicate) {
+        this.handlers.removeIf(prioritizedHandler -> predicate.test(prioritizedHandler.handler()));
+    }
+
+    private record PrioritizedHandler<O extends LifecycleEventOwner, E extends LifecycleEvent>(RegisteredHandler<O, E> handler, OptionalInt priority) {}
+}
diff --git a/src/main/java/io/papermc/paper/plugin/loader/PaperClasspathBuilder.java b/src/main/java/io/papermc/paper/plugin/loader/PaperClasspathBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..032ac7479d9a46cf1d949fe0749923e3d8009e0e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/loader/PaperClasspathBuilder.java
@@ -0,0 +1,70 @@
+package io.papermc.paper.plugin.loader;
+
+import io.papermc.paper.plugin.bootstrap.PluginProviderContext;
+import io.papermc.paper.plugin.entrypoint.classloader.PaperPluginClassLoader;
+import io.papermc.paper.plugin.loader.library.ClassPathLibrary;
+import io.papermc.paper.plugin.loader.library.PaperLibraryStore;
+import io.papermc.paper.plugin.provider.configuration.PaperPluginMeta;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.jar.JarFile;
+import java.util.logging.Logger;
+
+public class PaperClasspathBuilder implements PluginClasspathBuilder {
+
+    private final List<ClassPathLibrary> libraries = new ArrayList<>();
+
+    private final PluginProviderContext context;
+
+    public PaperClasspathBuilder(PluginProviderContext context) {
+        this.context = context;
+    }
+
+    @Override
+    public @NotNull PluginProviderContext getContext() {
+        return this.context;
+    }
+
+    @Override
+    public @NotNull PluginClasspathBuilder addLibrary(@NotNull ClassPathLibrary classPathLibrary) {
+        this.libraries.add(classPathLibrary);
+        return this;
+    }
+
+    public PaperPluginClassLoader buildClassLoader(Logger logger, Path source, JarFile jarFile, PaperPluginMeta configuration) {
+        List<Path> paths = this.buildLibraryPaths(true);
+        URL[] urls = new URL[paths.size()];
+        for (int i = 0; i < paths.size(); i++) {
+            Path path = paths.get(i);
+            try {
+                urls[i] = path.toUri().toURL();
+            } catch (MalformedURLException e) {
+                throw new AssertionError(e);
+            }
+        }
+
+        try {
+            final URLClassLoader libraryLoader = new URLClassLoader(urls, this.getClass().getClassLoader());
+            return new PaperPluginClassLoader(logger, source, jarFile, configuration, this.getClass().getClassLoader(), libraryLoader);
+        } catch (IOException exception) {
+            throw new RuntimeException(exception);
+        }
+    }
+
+    public List<Path> buildLibraryPaths(final boolean remap) {
+        PaperLibraryStore paperLibraryStore = new PaperLibraryStore();
+        for (ClassPathLibrary library : this.libraries) {
+            library.register(paperLibraryStore);
+        }
+
+        List<Path> paths = paperLibraryStore.getPaths();
+        return paths;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/loader/library/PaperLibraryStore.java b/src/main/java/io/papermc/paper/plugin/loader/library/PaperLibraryStore.java
new file mode 100644
index 0000000000000000000000000000000000000000..5fcce65009f715d46dd3013f1f92ec8393d66e15
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/loader/library/PaperLibraryStore.java
@@ -0,0 +1,21 @@
+package io.papermc.paper.plugin.loader.library;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+
+public class PaperLibraryStore implements LibraryStore {
+
+    private final List<Path> paths = new ArrayList<>();
+
+    @Override
+    public void addLibrary(@NotNull Path library) {
+        this.paths.add(library);
+    }
+
+    public List<Path> getPaths() {
+        return this.paths;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/manager/DummyBukkitPluginLoader.java b/src/main/java/io/papermc/paper/plugin/manager/DummyBukkitPluginLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..063623576e9938bdbdf2bfcc284289dca73240bb
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/manager/DummyBukkitPluginLoader.java
@@ -0,0 +1,75 @@
+package io.papermc.paper.plugin.manager;
+
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.provider.type.PluginFileType;
+import org.bukkit.Bukkit;
+import org.bukkit.event.Event;
+import org.bukkit.event.Listener;
+import org.bukkit.plugin.*;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.util.Map;
+import java.util.Set;
+import java.util.jar.JarFile;
+import java.util.regex.Pattern;
+
+/**
+ * A purely internal type that implements the now deprecated {@link PluginLoader} after the implementation
+ * of papers new plugin system.
+ */
+@ApiStatus.Internal
+public class DummyBukkitPluginLoader implements PluginLoader {
+
+    private static final Pattern[] PATTERNS = new Pattern[0];
+
+    @Override
+    public @NotNull Plugin loadPlugin(@NotNull File file) throws InvalidPluginException, UnknownDependencyException {
+        try {
+            return PaperPluginManagerImpl.getInstance().loadPlugin(file);
+        } catch (InvalidDescriptionException e) {
+            throw new InvalidPluginException(e);
+        }
+    }
+
+    @Override
+    public @NotNull PluginDescriptionFile getPluginDescription(@NotNull File file) throws InvalidDescriptionException {
+        try (JarFile jar = new JarFile(file)) {
+            PluginFileType<?, ?> type = PluginFileType.guessType(jar);
+            if (type == null) {
+                throw new InvalidDescriptionException(new FileNotFoundException("Jar does not contain plugin.yml"));
+            }
+
+            PluginMeta meta = type.getConfig(jar);
+            if (meta instanceof PluginDescriptionFile pluginDescriptionFile) {
+                return pluginDescriptionFile;
+            } else {
+                throw new InvalidDescriptionException("Plugin type does not use plugin.yml. Cannot read file description.");
+            }
+        } catch (Exception e) {
+            throw new InvalidDescriptionException(e);
+        }
+    }
+
+    @Override
+    public @NotNull Pattern[] getPluginFileFilters() {
+        return PATTERNS;
+    }
+
+    @Override
+    public @NotNull Map<Class<? extends Event>, Set<RegisteredListener>> createRegisteredListeners(@NotNull Listener listener, @NotNull Plugin plugin) {
+        return PaperPluginManagerImpl.getInstance().paperEventManager.createRegisteredListeners(listener, plugin);
+    }
+
+    @Override
+    public void enablePlugin(@NotNull Plugin plugin) {
+        Bukkit.getPluginManager().enablePlugin(plugin);
+    }
+
+    @Override
+    public void disablePlugin(@NotNull Plugin plugin) {
+        Bukkit.getPluginManager().disablePlugin(plugin);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/manager/MultiRuntimePluginProviderStorage.java b/src/main/java/io/papermc/paper/plugin/manager/MultiRuntimePluginProviderStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..8560d6f70abf6407052a8eff15ffe963c8fa7978
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/manager/MultiRuntimePluginProviderStorage.java
@@ -0,0 +1,58 @@
+package io.papermc.paper.plugin.manager;
+
+import io.papermc.paper.plugin.entrypoint.Entrypoint;
+import io.papermc.paper.plugin.entrypoint.LaunchEntryPointHandler;
+import io.papermc.paper.plugin.entrypoint.dependency.MetaDependencyTree;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.type.paper.PaperPluginParent;
+import io.papermc.paper.plugin.storage.ServerPluginProviderStorage;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.plugin.java.JavaPlugin;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class MultiRuntimePluginProviderStorage extends ServerPluginProviderStorage {
+
+    private final List<JavaPlugin> provided = new ArrayList<>();
+
+    private final MetaDependencyTree dependencyTree;
+
+    MultiRuntimePluginProviderStorage(MetaDependencyTree dependencyTree) {
+        this.dependencyTree = dependencyTree;
+    }
+
+    @Override
+    public void register(PluginProvider<JavaPlugin> provider) {
+        if (provider instanceof PaperPluginParent.PaperServerPluginProvider) {
+            MinecraftServer.LOGGER.warn("Skipping loading of paper plugin requested from SimplePluginManager.");
+            return;
+        }
+        super.register(provider);
+        /*
+        Register the provider into the server entrypoint, this allows it to show in /plugins correctly. Generally it might be better in the future to make a separate storage,
+         as putting it into the entrypoint handlers doesn't make much sense.
+         */
+        LaunchEntryPointHandler.INSTANCE.register(Entrypoint.PLUGIN, provider);
+    }
+
+    @Override
+    public void processProvided(PluginProvider<JavaPlugin> provider, JavaPlugin provided) {
+        super.processProvided(provider, provided);
+        this.provided.add(provided);
+    }
+
+    @Override
+    public boolean throwOnCycle() {
+        return false;
+    }
+
+    public List<JavaPlugin> getLoaded() {
+        return this.provided;
+    }
+
+    @Override
+    public MetaDependencyTree createDependencyTree() {
+        return this.dependencyTree;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/manager/NormalPaperPermissionManager.java b/src/main/java/io/papermc/paper/plugin/manager/NormalPaperPermissionManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..29f8845bbad88e88e11e6365a867e37228bcf6fd
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/manager/NormalPaperPermissionManager.java
@@ -0,0 +1,39 @@
+package io.papermc.paper.plugin.manager;
+
+import org.bukkit.permissions.Permissible;
+import org.bukkit.permissions.Permission;
+
+import java.util.*;
+
+class NormalPaperPermissionManager extends PaperPermissionManager {
+
+    private final Map<String, Permission> permissions = new HashMap<>();
+    private final Map<Boolean, Set<Permission>> defaultPerms = new LinkedHashMap<>();
+    private final Map<String, Map<Permissible, Boolean>> permSubs = new HashMap<>();
+    private final Map<Boolean, Map<Permissible, Boolean>> defSubs = new HashMap<>();
+
+    public NormalPaperPermissionManager() {
+        this.defaultPerms().put(true, new LinkedHashSet<>());
+        this.defaultPerms().put(false, new LinkedHashSet<>());
+    }
+
+    @Override
+    public Map<String, Permission> permissions() {
+        return this.permissions;
+    }
+
+    @Override
+    public Map<Boolean, Set<Permission>> defaultPerms() {
+        return this.defaultPerms;
+    }
+
+    @Override
+    public Map<String, Map<Permissible, Boolean>> permSubs() {
+        return this.permSubs;
+    }
+
+    @Override
+    public Map<Boolean, Map<Permissible, Boolean>> defSubs() {
+        return this.defSubs;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..8be9abfd2142b3ea06a3fc3810b01d1bfe12e94b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
@@ -0,0 +1,182 @@
+package io.papermc.paper.plugin.manager;
+
+import co.aikar.timings.TimedEventExecutor;
+import com.destroystokyo.paper.event.server.ServerExceptionEvent;
+import com.destroystokyo.paper.exception.ServerEventException;
+import com.google.common.collect.Sets;
+import org.bukkit.Server;
+import org.bukkit.Warning;
+import org.bukkit.event.*;
+import org.bukkit.plugin.*;
+import org.jetbrains.annotations.NotNull;
+
+import java.lang.reflect.Method;
+import java.util.*;
+import java.util.logging.Level;
+
+class PaperEventManager {
+
+    private final Server server;
+
+    public PaperEventManager(Server server) {
+        this.server = server;
+    }
+
+    // SimplePluginManager
+    public void callEvent(@NotNull Event event) {
+        if (event.isAsynchronous() && this.server.isPrimaryThread()) {
+            throw new IllegalStateException(event.getEventName() + " may only be triggered asynchronously.");
+        } else if (!event.isAsynchronous() && !this.server.isPrimaryThread() && !this.server.isStopping()) {
+            throw new IllegalStateException(event.getEventName() + " may only be triggered synchronously.");
+        }
+
+        HandlerList handlers = event.getHandlers();
+        RegisteredListener[] listeners = handlers.getRegisteredListeners();
+
+        for (RegisteredListener registration : listeners) {
+            if (!registration.getPlugin().isEnabled()) {
+                continue;
+            }
+
+            try {
+                registration.callEvent(event);
+            } catch (AuthorNagException ex) {
+                Plugin plugin = registration.getPlugin();
+
+                if (plugin.isNaggable()) {
+                    plugin.setNaggable(false);
+
+                    this.server.getLogger().log(Level.SEVERE, String.format(
+                        "Nag author(s): '%s' of '%s' about the following: %s",
+                        plugin.getPluginMeta().getAuthors(),
+                        plugin.getPluginMeta().getDisplayName(),
+                        ex.getMessage()
+                    ));
+                }
+            } catch (Throwable ex) {
+                String msg = "Could not pass event " + event.getEventName() + " to " + registration.getPlugin().getPluginMeta().getDisplayName();
+                this.server.getLogger().log(Level.SEVERE, msg, ex);
+                if (!(event instanceof ServerExceptionEvent)) { // We don't want to cause an endless event loop
+                    this.callEvent(new ServerExceptionEvent(new ServerEventException(msg, ex, registration.getPlugin(), registration.getListener(), event)));
+                }
+            }
+        }
+    }
+
+    public void registerEvents(@NotNull Listener listener, @NotNull Plugin plugin) {
+        if (!plugin.isEnabled()) {
+            throw new IllegalPluginAccessException("Plugin attempted to register " + listener + " while not enabled");
+        }
+
+        for (Map.Entry<Class<? extends Event>, Set<RegisteredListener>> entry : this.createRegisteredListeners(listener, plugin).entrySet()) {
+            this.getEventListeners(this.getRegistrationClass(entry.getKey())).registerAll(entry.getValue());
+        }
+
+    }
+
+    public void registerEvent(@NotNull Class<? extends Event> event, @NotNull Listener listener, @NotNull EventPriority priority, @NotNull EventExecutor executor, @NotNull Plugin plugin) {
+        this.registerEvent(event, listener, priority, executor, plugin, false);
+    }
+
+    public void registerEvent(@NotNull Class<? extends Event> event, @NotNull Listener listener, @NotNull EventPriority priority, @NotNull EventExecutor executor, @NotNull Plugin plugin, boolean ignoreCancelled) {
+        if (!plugin.isEnabled()) {
+            throw new IllegalPluginAccessException("Plugin attempted to register " + event + " while not enabled");
+        }
+
+        executor = new TimedEventExecutor(executor, plugin, null, event);
+        this.getEventListeners(event).register(new RegisteredListener(listener, executor, priority, plugin, ignoreCancelled));
+    }
+
+    @NotNull
+    private HandlerList getEventListeners(@NotNull Class<? extends Event> type) {
+        try {
+            Method method = this.getRegistrationClass(type).getDeclaredMethod("getHandlerList");
+            method.setAccessible(true);
+            return (HandlerList) method.invoke(null);
+        } catch (Exception e) {
+            throw new IllegalPluginAccessException(e.toString());
+        }
+    }
+
+    @NotNull
+    private Class<? extends Event> getRegistrationClass(@NotNull Class<? extends Event> clazz) {
+        try {
+            clazz.getDeclaredMethod("getHandlerList");
+            return clazz;
+        } catch (NoSuchMethodException e) {
+            if (clazz.getSuperclass() != null
+                && !clazz.getSuperclass().equals(Event.class)
+                && Event.class.isAssignableFrom(clazz.getSuperclass())) {
+                return this.getRegistrationClass(clazz.getSuperclass().asSubclass(Event.class));
+            } else {
+                throw new IllegalPluginAccessException("Unable to find handler list for event " + clazz.getName() + ". Static getHandlerList method required!");
+            }
+        }
+    }
+
+    // JavaPluginLoader
+    @NotNull
+    public Map<Class<? extends Event>, Set<RegisteredListener>> createRegisteredListeners(@NotNull Listener listener, @NotNull final Plugin plugin) {
+        Map<Class<? extends Event>, Set<RegisteredListener>> ret = new HashMap<>();
+
+        Set<Method> methods;
+        try {
+            Class<?> listenerClazz = listener.getClass();
+            methods = Sets.union(
+                Set.of(listenerClazz.getMethods()),
+                Set.of(listenerClazz.getDeclaredMethods())
+            );
+        } catch (NoClassDefFoundError e) {
+            plugin.getLogger().severe("Failed to register events for " + listener.getClass() + " because " + e.getMessage() + " does not exist.");
+            return ret;
+        }
+
+        for (final Method method : methods) {
+            final EventHandler eh = method.getAnnotation(EventHandler.class);
+            if (eh == null) continue;
+            // Do not register bridge or synthetic methods to avoid event duplication
+            // Fixes SPIGOT-893
+            if (method.isBridge() || method.isSynthetic()) {
+                continue;
+            }
+            final Class<?> checkClass;
+            if (method.getParameterTypes().length != 1 || !Event.class.isAssignableFrom(checkClass = method.getParameterTypes()[0])) {
+                plugin.getLogger().severe(plugin.getPluginMeta().getDisplayName() + " attempted to register an invalid EventHandler method signature \"" + method.toGenericString() + "\" in " + listener.getClass());
+                continue;
+            }
+            final Class<? extends Event> eventClass = checkClass.asSubclass(Event.class);
+            method.setAccessible(true);
+            Set<RegisteredListener> eventSet = ret.computeIfAbsent(eventClass, k -> new HashSet<>());
+
+            for (Class<?> clazz = eventClass; Event.class.isAssignableFrom(clazz); clazz = clazz.getSuperclass()) {
+                // This loop checks for extending deprecated events
+                if (clazz.getAnnotation(Deprecated.class) != null) {
+                    Warning warning = clazz.getAnnotation(Warning.class);
+                    Warning.WarningState warningState = this.server.getWarningState();
+                    if (!warningState.printFor(warning)) {
+                        break;
+                    }
+                    plugin.getLogger().log(
+                        Level.WARNING,
+                        String.format(
+                            "\"%s\" has registered a listener for %s on method \"%s\", but the event is Deprecated. \"%s\"; please notify the authors %s.",
+                            plugin.getPluginMeta().getDisplayName(),
+                            clazz.getName(),
+                            method.toGenericString(),
+                            (warning != null && warning.reason().length() != 0) ? warning.reason() : "Server performance will be affected",
+                            Arrays.toString(plugin.getPluginMeta().getAuthors().toArray())),
+                        warningState == Warning.WarningState.ON ? new AuthorNagException(null) : null);
+                    break;
+                }
+            }
+
+            EventExecutor executor = new TimedEventExecutor(EventExecutor.create(method, eventClass), plugin, method, eventClass);
+            eventSet.add(new RegisteredListener(listener, executor, eh.priority(), plugin, eh.ignoreCancelled()));
+        }
+        return ret;
+    }
+
+    public void clearEvents() {
+        HandlerList.unregisterAll();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperPermissionManager.java b/src/main/java/io/papermc/paper/plugin/manager/PaperPermissionManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..d01ad99d550b38c42f446a5e68c927faae08fe50
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperPermissionManager.java
@@ -0,0 +1,196 @@
+package io.papermc.paper.plugin.manager;
+
+import com.google.common.collect.ImmutableSet;
+import io.papermc.paper.plugin.PermissionManager;
+import org.bukkit.permissions.Permissible;
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionDefault;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.*;
+
+/**
+ * See
+ * {@link StupidSPMPermissionManagerWrapper}
+ */
+abstract class PaperPermissionManager implements PermissionManager {
+
+    public abstract Map<String, Permission> permissions();
+
+    public abstract Map<Boolean, Set<Permission>> defaultPerms();
+
+    public abstract Map<String, Map<Permissible, Boolean>> permSubs();
+
+    public abstract Map<Boolean, Map<Permissible, Boolean>> defSubs();
+
+    @Override
+    @Nullable
+    public Permission getPermission(@NotNull String name) {
+        return this.permissions().get(name.toLowerCase(Locale.ENGLISH));
+    }
+
+    @Override
+    public void addPermission(@NotNull Permission perm) {
+        this.addPermission(perm, true);
+    }
+
+    @Override
+    public void addPermissions(@NotNull List<Permission> permissions) {
+        for (Permission permission : permissions) {
+            this.addPermission(permission, false);
+        }
+        this.dirtyPermissibles();
+    }
+
+    // Allow suppressing permission default calculations
+    private void addPermission(@NotNull Permission perm, boolean dirty) {
+        String name = perm.getName().toLowerCase(Locale.ENGLISH);
+
+        if (this.permissions().containsKey(name)) {
+            throw new IllegalArgumentException("The permission " + name + " is already defined!");
+        }
+
+        this.permissions().put(name, perm);
+        this.calculatePermissionDefault(perm, dirty);
+    }
+
+    @Override
+    @NotNull
+    public Set<Permission> getDefaultPermissions(boolean op) {
+        return ImmutableSet.copyOf(this.defaultPerms().get(op));
+    }
+
+
+    @Override
+    public void removePermission(@NotNull Permission perm) {
+        this.removePermission(perm.getName());
+    }
+
+
+    @Override
+    public void removePermission(@NotNull String name) {
+        this.permissions().remove(name.toLowerCase(Locale.ENGLISH));
+    }
+
+    @Override
+    public void recalculatePermissionDefaults(@NotNull Permission perm) {
+        // we need a null check here because some plugins for some unknown reason pass null into this?
+        if (perm != null && this.permissions().containsKey(perm.getName().toLowerCase(Locale.ROOT))) {
+            this.defaultPerms().get(true).remove(perm);
+            this.defaultPerms().get(false).remove(perm);
+
+            this.calculatePermissionDefault(perm, true);
+        }
+    }
+
+    private void calculatePermissionDefault(@NotNull Permission perm, boolean dirty) {
+        if ((perm.getDefault() == PermissionDefault.OP) || (perm.getDefault() == PermissionDefault.TRUE)) {
+            this.defaultPerms().get(true).add(perm);
+            if (dirty) {
+                this.dirtyPermissibles(true);
+            }
+        }
+        if ((perm.getDefault() == PermissionDefault.NOT_OP) || (perm.getDefault() == PermissionDefault.TRUE)) {
+            this.defaultPerms().get(false).add(perm);
+            if (dirty) {
+                this.dirtyPermissibles(false);
+            }
+        }
+    }
+
+
+    @Override
+    public void subscribeToPermission(@NotNull String permission, @NotNull Permissible permissible) {
+        String name = permission.toLowerCase(Locale.ENGLISH);
+        Map<Permissible, Boolean> map = this.permSubs().computeIfAbsent(name, k -> new WeakHashMap<>());
+
+        map.put(permissible, true);
+    }
+
+    @Override
+    public void unsubscribeFromPermission(@NotNull String permission, @NotNull Permissible permissible) {
+        String name = permission.toLowerCase(Locale.ENGLISH);
+        Map<Permissible, Boolean> map = this.permSubs().get(name);
+
+        if (map != null) {
+            map.remove(permissible);
+
+            if (map.isEmpty()) {
+                this.permSubs().remove(name);
+            }
+        }
+    }
+
+    @Override
+    @NotNull
+    public Set<Permissible> getPermissionSubscriptions(@NotNull String permission) {
+        String name = permission.toLowerCase(Locale.ENGLISH);
+        Map<Permissible, Boolean> map = this.permSubs().get(name);
+
+        if (map == null) {
+            return ImmutableSet.of();
+        } else {
+            return ImmutableSet.copyOf(map.keySet());
+        }
+    }
+
+    @Override
+    public void subscribeToDefaultPerms(boolean op, @NotNull Permissible permissible) {
+        Map<Permissible, Boolean> map = this.defSubs().computeIfAbsent(op, k -> new WeakHashMap<>());
+
+        map.put(permissible, true);
+    }
+
+    @Override
+    public void unsubscribeFromDefaultPerms(boolean op, @NotNull Permissible permissible) {
+        Map<Permissible, Boolean> map = this.defSubs().get(op);
+
+        if (map != null) {
+            map.remove(permissible);
+
+            if (map.isEmpty()) {
+                this.defSubs().remove(op);
+            }
+        }
+    }
+
+    @Override
+    @NotNull
+    public Set<Permissible> getDefaultPermSubscriptions(boolean op) {
+        Map<Permissible, Boolean> map = this.defSubs().get(op);
+
+        if (map == null) {
+            return ImmutableSet.of();
+        } else {
+            return ImmutableSet.copyOf(map.keySet());
+        }
+    }
+
+    @Override
+    @NotNull
+    public Set<Permission> getPermissions() {
+        return new HashSet<>(this.permissions().values());
+    }
+
+    @Override
+    public void clearPermissions() {
+        this.permissions().clear();
+        this.defaultPerms().get(true).clear();
+        this.defaultPerms().get(false).clear();
+    }
+
+
+    void dirtyPermissibles(boolean op) {
+        Set<Permissible> permissibles = this.getDefaultPermSubscriptions(op);
+
+        for (Permissible p : permissibles) {
+            p.recalculatePermissions();
+        }
+    }
+
+    void dirtyPermissibles() {
+        this.dirtyPermissibles(true);
+        this.dirtyPermissibles(false);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java b/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..792efdeb528571bf62852dc64d9390e7cfa37243
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java
@@ -0,0 +1,322 @@
+package io.papermc.paper.plugin.manager;
+
+import com.google.common.base.Preconditions;
+import com.google.common.graph.GraphBuilder;
+import com.google.common.graph.MutableGraph;
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.entrypoint.Entrypoint;
+import io.papermc.paper.plugin.entrypoint.dependency.MetaDependencyTree;
+import io.papermc.paper.plugin.entrypoint.dependency.SimpleMetaDependencyTree;
+import io.papermc.paper.plugin.entrypoint.strategy.PluginGraphCycleException;
+import io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader;
+import io.papermc.paper.plugin.provider.classloader.PaperClassLoaderStorage;
+import io.papermc.paper.plugin.provider.source.DirectoryProviderSource;
+import io.papermc.paper.plugin.provider.source.FileArrayProviderSource;
+import io.papermc.paper.plugin.provider.source.FileProviderSource;
+import org.bukkit.Bukkit;
+import org.bukkit.Server;
+import org.bukkit.World;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandMap;
+import org.bukkit.command.PluginCommandYamlParser;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.server.PluginDisableEvent;
+import org.bukkit.event.server.PluginEnableEvent;
+import org.bukkit.plugin.*;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.logging.Level;
+
+@SuppressWarnings("UnstableApiUsage")
+class PaperPluginInstanceManager {
+
+    private static final FileProviderSource FILE_PROVIDER_SOURCE = new FileProviderSource("File '%s'"::formatted);
+
+    private final List<Plugin> plugins = new ArrayList<>();
+    private final Map<String, Plugin> lookupNames = new HashMap<>();
+
+    private final PluginManager pluginManager;
+    private final CommandMap commandMap;
+    private final Server server;
+
+    private final MetaDependencyTree dependencyTree = new SimpleMetaDependencyTree(GraphBuilder.directed().build());
+
+    public PaperPluginInstanceManager(PluginManager pluginManager, CommandMap commandMap, Server server) {
+        this.commandMap = commandMap;
+        this.server = server;
+        this.pluginManager = pluginManager;
+    }
+
+    public @Nullable Plugin getPlugin(@NotNull String name) {
+        return this.lookupNames.get(name.replace(' ', '_').toLowerCase(java.util.Locale.ENGLISH)); // Paper
+    }
+
+    public @NotNull Plugin[] getPlugins() {
+        return this.plugins.toArray(new Plugin[0]);
+    }
+
+    public boolean isPluginEnabled(@NotNull String name) {
+        Plugin plugin = this.getPlugin(name);
+
+        return this.isPluginEnabled(plugin);
+    }
+
+    public synchronized boolean isPluginEnabled(@Nullable Plugin plugin) {
+        if ((plugin != null) && (this.plugins.contains(plugin))) {
+            return plugin.isEnabled();
+        } else {
+            return false;
+        }
+    }
+
+    public void loadPlugin(Plugin provided) {
+        PluginMeta configuration = provided.getPluginMeta();
+
+        this.plugins.add(provided);
+        this.lookupNames.put(configuration.getName().toLowerCase(java.util.Locale.ENGLISH), provided);
+        for (String providedPlugin : configuration.getProvidedPlugins()) {
+            this.lookupNames.putIfAbsent(providedPlugin.toLowerCase(java.util.Locale.ENGLISH), provided);
+        }
+
+        this.dependencyTree.add(configuration);
+    }
+
+    // InvalidDescriptionException is never used, because the old JavaPluginLoader would wrap the exception.
+    public @Nullable Plugin loadPlugin(@NotNull Path path) throws InvalidPluginException, UnknownDependencyException {
+        RuntimePluginEntrypointHandler<SingularRuntimePluginProviderStorage> runtimePluginEntrypointHandler = new RuntimePluginEntrypointHandler<>(new SingularRuntimePluginProviderStorage(this.dependencyTree));
+
+        try {
+            path = FILE_PROVIDER_SOURCE.prepareContext(path);
+            FILE_PROVIDER_SOURCE.registerProviders(runtimePluginEntrypointHandler, path);
+        } catch (IllegalArgumentException exception) {
+            return null; // Return null when the plugin file is not valid / plugin type is unknown
+        } catch (PluginGraphCycleException exception) {
+            throw new InvalidPluginException("Cannot import plugin that causes cyclic dependencies!");
+        } catch (Exception e) {
+            throw new InvalidPluginException(e);
+        }
+
+        try {
+            runtimePluginEntrypointHandler.enter(Entrypoint.PLUGIN);
+        } catch (Throwable e) {
+            throw new InvalidPluginException(e);
+        }
+
+        return runtimePluginEntrypointHandler.getPluginProviderStorage().getSingleLoaded()
+            .orElseThrow(() -> new InvalidPluginException("Plugin didn't load any plugin providers?"));
+    }
+
+    public @NotNull Plugin[] loadPlugins(@NotNull File[] files) {
+        RuntimePluginEntrypointHandler<MultiRuntimePluginProviderStorage> runtimePluginEntrypointHandler = new RuntimePluginEntrypointHandler<>(new MultiRuntimePluginProviderStorage(this.dependencyTree));
+        try {
+            List<Path> paths = FileArrayProviderSource.INSTANCE.prepareContext(files);
+            DirectoryProviderSource.INSTANCE.registerProviders(runtimePluginEntrypointHandler, paths);
+            runtimePluginEntrypointHandler.enter(Entrypoint.PLUGIN);
+        } catch (Exception e) {
+            // This should never happen, any errors that occur in this provider should instead be logged.
+            this.server.getLogger().log(Level.SEVERE, "Unknown error occurred while loading plugins through PluginManager.", e);
+        }
+
+        return runtimePluginEntrypointHandler.getPluginProviderStorage().getLoaded().toArray(new JavaPlugin[0]);
+    }
+
+    // The behavior of this is that all errors are logged instead of being thrown
+    public @NotNull Plugin[] loadPlugins(@NotNull Path directory) {
+        Preconditions.checkArgument(Files.isDirectory(directory), "Directory must be a directory"); // Avoid creating a directory if it doesn't exist
+
+        RuntimePluginEntrypointHandler<MultiRuntimePluginProviderStorage> runtimePluginEntrypointHandler = new RuntimePluginEntrypointHandler<>(new MultiRuntimePluginProviderStorage(this.dependencyTree));
+        try {
+            List<Path> files = DirectoryProviderSource.INSTANCE.prepareContext(directory);
+            DirectoryProviderSource.INSTANCE.registerProviders(runtimePluginEntrypointHandler, files);
+            runtimePluginEntrypointHandler.enter(Entrypoint.PLUGIN);
+        } catch (Exception e) {
+            // This should never happen, any errors that occur in this provider should instead be logged.
+            this.server.getLogger().log(Level.SEVERE, "Unknown error occurred while loading plugins through PluginManager.", e);
+        }
+
+        return runtimePluginEntrypointHandler.getPluginProviderStorage().getLoaded().toArray(new JavaPlugin[0]);
+    }
+
+    // Plugins are disabled in order like this inorder to "rougly" prevent
+    // their dependencies unloading first. But, eh.
+    public void disablePlugins() {
+        Plugin[] plugins = this.getPlugins();
+        for (int i = plugins.length - 1; i >= 0; i--) {
+            this.disablePlugin(plugins[i]);
+        }
+    }
+
+    public void clearPlugins() {
+        synchronized (this) {
+            this.disablePlugins();
+            this.plugins.clear();
+            this.lookupNames.clear();
+        }
+    }
+
+    public synchronized void enablePlugin(@NotNull Plugin plugin) {
+        if (plugin.isEnabled()) {
+            return;
+        }
+
+        if (plugin.getPluginMeta() instanceof PluginDescriptionFile) {
+            List<Command> bukkitCommands = PluginCommandYamlParser.parse(plugin);
+
+            if (!bukkitCommands.isEmpty()) {
+                this.commandMap.registerAll(plugin.getPluginMeta().getName(), bukkitCommands);
+            }
+        }
+
+        try {
+            String enableMsg = "Enabling " + plugin.getPluginMeta().getDisplayName();
+            if (plugin.getPluginMeta() instanceof PluginDescriptionFile descriptionFile && CraftMagicNumbers.isLegacy(descriptionFile)) {
+                enableMsg += "*";
+            }
+            plugin.getLogger().info(enableMsg);
+
+            JavaPlugin jPlugin = (JavaPlugin) plugin;
+
+            if (jPlugin.getClass().getClassLoader() instanceof ConfiguredPluginClassLoader classLoader) { // Paper
+                if (PaperClassLoaderStorage.instance().registerUnsafePlugin(classLoader)) {
+                    this.server.getLogger().log(Level.WARNING, "Enabled plugin with unregistered ConfiguredPluginClassLoader " + plugin.getPluginMeta().getDisplayName());
+                }
+            } // Paper
+
+            try {
+                jPlugin.setEnabled(true);
+            } catch (Throwable ex) {
+                this.server.getLogger().log(Level.SEVERE, "Error occurred while enabling " + plugin.getPluginMeta().getDisplayName() + " (Is it up to date?)", ex);
+                // Paper start - Disable plugins that fail to load
+                this.server.getPluginManager().disablePlugin(jPlugin);
+                return;
+                // Paper end
+            }
+
+            // Perhaps abort here, rather than continue going, but as it stands,
+            // an abort is not possible the way it's currently written
+            this.server.getPluginManager().callEvent(new PluginEnableEvent(plugin));
+        } catch (Throwable ex) {
+            this.handlePluginException("Error occurred (in the plugin loader) while enabling "
+                + plugin.getPluginMeta().getDisplayName() + " (Is it up to date?)", ex, plugin);
+        }
+
+        HandlerList.bakeAll();
+    }
+
+    public synchronized void disablePlugin(@NotNull Plugin plugin) {
+        if (!(plugin instanceof JavaPlugin javaPlugin)) {
+            throw new IllegalArgumentException("Only expects java plugins.");
+        }
+        if (!plugin.isEnabled()) {
+            return;
+        }
+
+        String pluginName = plugin.getPluginMeta().getDisplayName();
+
+        try {
+            plugin.getLogger().info("Disabling %s".formatted(pluginName));
+
+            this.server.getPluginManager().callEvent(new PluginDisableEvent(plugin));
+            try {
+                javaPlugin.setEnabled(false);
+            } catch (Throwable ex) {
+                this.server.getLogger().log(Level.SEVERE, "Error occurred while disabling " + pluginName, ex);
+            }
+
+            ClassLoader classLoader = plugin.getClass().getClassLoader();
+            if (classLoader instanceof ConfiguredPluginClassLoader configuredPluginClassLoader) {
+                try {
+                    configuredPluginClassLoader.close();
+                } catch (IOException ex) {
+                    this.server.getLogger().log(Level.WARNING, "Error closing the classloader for '" + pluginName + "'", ex); // Paper - log exception
+                }
+                // Remove from the classloader pool inorder to prevent plugins from trying
+                // to access classes
+                PaperClassLoaderStorage.instance().unregisterClassloader(configuredPluginClassLoader);
+            }
+
+        } catch (Throwable ex) {
+            this.handlePluginException("Error occurred (in the plugin loader) while disabling "
+                + pluginName + " (Is it up to date?)", ex, plugin); // Paper
+        }
+
+        try {
+            this.server.getScheduler().cancelTasks(plugin);
+        } catch (Throwable ex) {
+            this.handlePluginException("Error occurred (in the plugin loader) while cancelling tasks for "
+                + pluginName + " (Is it up to date?)", ex, plugin); // Paper
+        }
+
+        try {
+            this.server.getServicesManager().unregisterAll(plugin);
+        } catch (Throwable ex) {
+            this.handlePluginException("Error occurred (in the plugin loader) while unregistering META-INF for "
+                + pluginName + " (Is it up to date?)", ex, plugin); // Paper
+        }
+
+        try {
+            HandlerList.unregisterAll(plugin);
+        } catch (Throwable ex) {
+            this.handlePluginException("Error occurred (in the plugin loader) while unregistering events for "
+                + pluginName + " (Is it up to date?)", ex, plugin); // Paper
+        }
+
+        // Paper start - lifecycle event system
+        try {
+            io.papermc.paper.plugin.lifecycle.event.LifecycleEventRunner.INSTANCE.unregisterAllEventHandlersFor(plugin);
+        } catch (Throwable ex) {
+            this.handlePluginException("Error occurred (in the plugin loader) while unregistering lifecycle event handlers for "
+                + pluginName + " (Is it up to date?)", ex, plugin);
+        }
+        // Paper end
+
+        try {
+            this.server.getMessenger().unregisterIncomingPluginChannel(plugin);
+            this.server.getMessenger().unregisterOutgoingPluginChannel(plugin);
+        } catch (Throwable ex) {
+            this.handlePluginException("Error occurred (in the plugin loader) while unregistering plugin channels for "
+                + pluginName + " (Is it up to date?)", ex, plugin); // Paper
+        }
+
+        try {
+            for (World world : this.server.getWorlds()) {
+                world.removePluginChunkTickets(plugin);
+            }
+        } catch (Throwable ex) {
+            this.handlePluginException("Error occurred (in the plugin loader) while removing chunk tickets for " + pluginName + " (Is it up to date?)", ex, plugin); // Paper
+        }
+
+    }
+
+    // TODO: Implement event part in future patch (paper patch move up, this patch is lower)
+    private void handlePluginException(String msg, Throwable ex, Plugin plugin) {
+        Bukkit.getServer().getLogger().log(Level.SEVERE, msg, ex);
+        this.pluginManager.callEvent(new com.destroystokyo.paper.event.server.ServerExceptionEvent(new com.destroystokyo.paper.exception.ServerPluginEnableDisableException(msg, ex, plugin)));
+    }
+
+    public boolean isTransitiveDepend(@NotNull PluginMeta plugin, @NotNull PluginMeta depend) {
+        return this.dependencyTree.isTransitiveDependency(plugin, depend);
+    }
+
+    public boolean hasDependency(String pluginIdentifier) {
+        return this.getPlugin(pluginIdentifier) != null;
+    }
+
+    // Debug only
+    @ApiStatus.Internal
+    public MutableGraph<String> getDependencyGraph() {
+        return this.dependencyTree.getGraph();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperPluginManagerImpl.java b/src/main/java/io/papermc/paper/plugin/manager/PaperPluginManagerImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..9455616bb2ac70f91978f33840d77e722a9e4d9d
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperPluginManagerImpl.java
@@ -0,0 +1,239 @@
+package io.papermc.paper.plugin.manager;
+
+import com.google.common.graph.MutableGraph;
+import io.papermc.paper.plugin.PermissionManager;
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.provider.entrypoint.DependencyContext;
+import org.bukkit.Bukkit;
+import org.bukkit.Server;
+import org.bukkit.command.CommandMap;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.event.Event;
+import org.bukkit.event.EventPriority;
+import org.bukkit.event.Listener;
+import org.bukkit.permissions.Permissible;
+import org.bukkit.permissions.Permission;
+import org.bukkit.plugin.*;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.util.List;
+import java.util.Set;
+
+public class PaperPluginManagerImpl implements PluginManager, DependencyContext {
+
+    final PaperPluginInstanceManager instanceManager;
+    final PaperEventManager paperEventManager;
+    PermissionManager permissionManager;
+
+    public PaperPluginManagerImpl(Server server, CommandMap commandMap, @Nullable SimplePluginManager permissionManager) {
+        this.instanceManager = new PaperPluginInstanceManager(this, commandMap, server);
+        this.paperEventManager = new PaperEventManager(server);
+
+        if (permissionManager == null) {
+            this.permissionManager = new NormalPaperPermissionManager();
+        } else {
+            this.permissionManager = new StupidSPMPermissionManagerWrapper(permissionManager); // TODO: See comment when SimplePermissionManager is removed
+        }
+    }
+
+    // REMOVE THIS WHEN SimplePluginManager is removed.
+    // Just cast and use Bukkit.getServer().getPluginManager()
+    public static PaperPluginManagerImpl getInstance() {
+        return ((CraftServer) (Bukkit.getServer())).paperPluginManager;
+    }
+
+    // Plugin Manipulation
+
+    @Override
+    public @Nullable Plugin getPlugin(@NotNull String name) {
+        return this.instanceManager.getPlugin(name);
+    }
+
+    @Override
+    public @NotNull Plugin[] getPlugins() {
+        return this.instanceManager.getPlugins();
+    }
+
+    @Override
+    public boolean isPluginEnabled(@NotNull String name) {
+        return this.instanceManager.isPluginEnabled(name);
+    }
+
+    @Override
+    public boolean isPluginEnabled(@Nullable Plugin plugin) {
+        return this.instanceManager.isPluginEnabled(plugin);
+    }
+
+    public void loadPlugin(Plugin plugin) {
+        this.instanceManager.loadPlugin(plugin);
+    }
+
+    @Override
+    public @Nullable Plugin loadPlugin(@NotNull File file) throws InvalidPluginException, InvalidDescriptionException, UnknownDependencyException {
+        return this.instanceManager.loadPlugin(file.toPath());
+    }
+
+    @Override
+    public @NotNull Plugin[] loadPlugins(@NotNull File directory) {
+        return this.instanceManager.loadPlugins(directory.toPath());
+    }
+
+    @Override
+    public @NotNull Plugin[] loadPlugins(final @NotNull File[] files) {
+        return this.instanceManager.loadPlugins(files);
+    }
+
+    @Override
+    public void disablePlugins() {
+        this.instanceManager.disablePlugins();
+    }
+
+    @Override
+    public synchronized void clearPlugins() {
+        this.instanceManager.clearPlugins();
+        this.permissionManager.clearPermissions();
+        this.paperEventManager.clearEvents();
+    }
+
+    @Override
+    public void enablePlugin(@NotNull Plugin plugin) {
+        this.instanceManager.enablePlugin(plugin);
+    }
+
+    @Override
+    public void disablePlugin(@NotNull Plugin plugin) {
+        this.instanceManager.disablePlugin(plugin);
+    }
+
+    @Override
+    public boolean isTransitiveDependency(PluginMeta pluginMeta, PluginMeta dependencyConfig) {
+        return this.instanceManager.isTransitiveDepend(pluginMeta, dependencyConfig);
+    }
+
+    @Override
+    public boolean hasDependency(String pluginIdentifier) {
+        return this.instanceManager.hasDependency(pluginIdentifier);
+    }
+
+    // Event manipulation
+
+    @Override
+    public void callEvent(@NotNull Event event) throws IllegalStateException {
+        this.paperEventManager.callEvent(event);
+    }
+
+    @Override
+    public void registerEvents(@NotNull Listener listener, @NotNull Plugin plugin) {
+        this.paperEventManager.registerEvents(listener, plugin);
+    }
+
+    @Override
+    public void registerEvent(@NotNull Class<? extends Event> event, @NotNull Listener listener, @NotNull EventPriority priority, @NotNull EventExecutor executor, @NotNull Plugin plugin) {
+        this.paperEventManager.registerEvent(event, listener, priority, executor, plugin);
+    }
+
+    @Override
+    public void registerEvent(@NotNull Class<? extends Event> event, @NotNull Listener listener, @NotNull EventPriority priority, @NotNull EventExecutor executor, @NotNull Plugin plugin, boolean ignoreCancelled) {
+        this.paperEventManager.registerEvent(event, listener, priority, executor, plugin, ignoreCancelled);
+    }
+
+    // Permission manipulation
+
+    @Override
+    public @Nullable Permission getPermission(@NotNull String name) {
+        return this.permissionManager.getPermission(name);
+    }
+
+    @Override
+    public void addPermission(@NotNull Permission perm) {
+        this.permissionManager.addPermission(perm);
+    }
+
+    @Override
+    public void removePermission(@NotNull Permission perm) {
+        this.permissionManager.removePermission(perm);
+    }
+
+    @Override
+    public void removePermission(@NotNull String name) {
+        this.permissionManager.removePermission(name);
+    }
+
+    @Override
+    public @NotNull Set<Permission> getDefaultPermissions(boolean op) {
+        return this.permissionManager.getDefaultPermissions(op);
+    }
+
+    @Override
+    public void recalculatePermissionDefaults(@NotNull Permission perm) {
+        this.permissionManager.recalculatePermissionDefaults(perm);
+    }
+
+    @Override
+    public void subscribeToPermission(@NotNull String permission, @NotNull Permissible permissible) {
+        this.permissionManager.subscribeToPermission(permission, permissible);
+    }
+
+    @Override
+    public void unsubscribeFromPermission(@NotNull String permission, @NotNull Permissible permissible) {
+        this.permissionManager.unsubscribeFromPermission(permission, permissible);
+    }
+
+    @Override
+    public @NotNull Set<Permissible> getPermissionSubscriptions(@NotNull String permission) {
+        return this.permissionManager.getPermissionSubscriptions(permission);
+    }
+
+    @Override
+    public void subscribeToDefaultPerms(boolean op, @NotNull Permissible permissible) {
+        this.permissionManager.subscribeToDefaultPerms(op, permissible);
+    }
+
+    @Override
+    public void unsubscribeFromDefaultPerms(boolean op, @NotNull Permissible permissible) {
+        this.permissionManager.unsubscribeFromDefaultPerms(op, permissible);
+    }
+
+    @Override
+    public @NotNull Set<Permissible> getDefaultPermSubscriptions(boolean op) {
+        return this.permissionManager.getDefaultPermSubscriptions(op);
+    }
+
+    @Override
+    public @NotNull Set<Permission> getPermissions() {
+        return this.permissionManager.getPermissions();
+    }
+
+    @Override
+    public void addPermissions(@NotNull List<Permission> perm) {
+        this.permissionManager.addPermissions(perm);
+    }
+
+    @Override
+    public void clearPermissions() {
+        this.permissionManager.clearPermissions();
+    }
+
+    @Override
+    public void overridePermissionManager(@NotNull Plugin plugin, @Nullable PermissionManager permissionManager) {
+        this.permissionManager = permissionManager;
+    }
+
+    // Etc
+
+    @Override
+    public boolean useTimings() {
+        return co.aikar.timings.Timings.isTimingsEnabled();
+    }
+
+    @Override
+    public void registerInterface(@NotNull Class<? extends PluginLoader> loader) throws IllegalArgumentException {
+        throw new UnsupportedOperationException();
+    }
+
+    public MutableGraph<String> getInstanceManagerGraph() {
+        return instanceManager.getDependencyGraph();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/manager/RuntimePluginEntrypointHandler.java b/src/main/java/io/papermc/paper/plugin/manager/RuntimePluginEntrypointHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..5d50d1d312388e979c0e1cd53a6bf5977ca6e549
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/manager/RuntimePluginEntrypointHandler.java
@@ -0,0 +1,47 @@
+package io.papermc.paper.plugin.manager;
+
+import com.destroystokyo.paper.util.SneakyThrow;
+import io.papermc.paper.plugin.entrypoint.Entrypoint;
+import io.papermc.paper.plugin.entrypoint.EntrypointHandler;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.storage.ProviderStorage;
+import org.bukkit.plugin.InvalidPluginException;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Used for loading plugins during runtime, only supporting providers that are plugins.
+ * This is only used for the plugin manager, as it only allows plugins to be
+ * registered to a provider storage.
+ */
+class RuntimePluginEntrypointHandler<T extends ProviderStorage<JavaPlugin>> implements EntrypointHandler {
+
+    private final T providerStorage;
+
+    RuntimePluginEntrypointHandler(T providerStorage) {
+        this.providerStorage = providerStorage;
+    }
+
+    @Override
+    public <T> void register(Entrypoint<T> entrypoint, PluginProvider<T> provider) {
+        if (!entrypoint.equals(Entrypoint.PLUGIN)) {
+            SneakyThrow.sneaky(new InvalidPluginException("Plugin cannot register entrypoints other than PLUGIN during runtime. Tried registering %s!".formatted(entrypoint)));
+            // We have to throw an invalid plugin exception for legacy reasons
+        }
+
+        this.providerStorage.register((PluginProvider<JavaPlugin>) provider);
+    }
+
+    @Override
+    public void enter(Entrypoint<?> entrypoint) {
+        if (entrypoint != Entrypoint.PLUGIN) {
+            throw new IllegalArgumentException("Only plugin entrypoint supported");
+        }
+        this.providerStorage.enter();
+    }
+
+    @NotNull
+    public T getPluginProviderStorage() {
+        return this.providerStorage;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/manager/SingularRuntimePluginProviderStorage.java b/src/main/java/io/papermc/paper/plugin/manager/SingularRuntimePluginProviderStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..cbebe3d3b18cb44f207e4ff6e9a6c7adc1b0ad1d
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/manager/SingularRuntimePluginProviderStorage.java
@@ -0,0 +1,74 @@
+package io.papermc.paper.plugin.manager;
+
+import com.destroystokyo.paper.util.SneakyThrow;
+import io.papermc.paper.plugin.entrypoint.Entrypoint;
+import io.papermc.paper.plugin.entrypoint.LaunchEntryPointHandler;
+import io.papermc.paper.plugin.entrypoint.dependency.MetaDependencyTree;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.type.paper.PaperPluginParent;
+import io.papermc.paper.plugin.storage.ServerPluginProviderStorage;
+import org.bukkit.plugin.InvalidPluginException;
+import org.bukkit.plugin.java.JavaPlugin;
+
+import java.util.Optional;
+
+/**
+ * Used for registering a single plugin provider.
+ * This has special behavior in that some errors are thrown instead of logged.
+ */
+class SingularRuntimePluginProviderStorage extends ServerPluginProviderStorage {
+
+    private final MetaDependencyTree dependencyTree;
+    private PluginProvider<JavaPlugin> lastProvider;
+    private JavaPlugin singleLoaded;
+
+    SingularRuntimePluginProviderStorage(MetaDependencyTree dependencyTree) {
+        this.dependencyTree = dependencyTree;
+    }
+
+    @Override
+    public void register(PluginProvider<JavaPlugin> provider) {
+        super.register(provider);
+        if (this.lastProvider != null) {
+            SneakyThrow.sneaky(new InvalidPluginException("Plugin registered two JavaPlugins"));
+        }
+        if (provider instanceof PaperPluginParent.PaperServerPluginProvider) {
+            throw new IllegalStateException("Cannot register paper plugins during runtime!");
+        }
+        this.lastProvider = provider;
+        // Register the provider into the server entrypoint, this allows it to show in /plugins correctly.
+        // Generally it might be better in the future to make a separate storage, as putting it into the entrypoint handlers doesn't make much sense.
+        LaunchEntryPointHandler.INSTANCE.register(Entrypoint.PLUGIN, provider);
+    }
+
+    @Override
+    public void enter() {
+        PluginProvider<JavaPlugin> provider = this.lastProvider;
+        if (provider == null) {
+            return;
+        }
+
+        // Go through normal plugin loading logic
+        super.enter();
+    }
+
+    @Override
+    public void processProvided(PluginProvider<JavaPlugin> provider, JavaPlugin provided) {
+        super.processProvided(provider, provided);
+        this.singleLoaded = provided;
+    }
+
+    @Override
+    public boolean throwOnCycle() {
+        return false;
+    }
+
+    public Optional<JavaPlugin> getSingleLoaded() {
+        return Optional.ofNullable(this.singleLoaded);
+    }
+
+    @Override
+    public MetaDependencyTree createDependencyTree() {
+        return this.dependencyTree;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/manager/StupidSPMPermissionManagerWrapper.java b/src/main/java/io/papermc/paper/plugin/manager/StupidSPMPermissionManagerWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..ea8cf22c35242eb9f3914b95df00e20504aef5c1
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/manager/StupidSPMPermissionManagerWrapper.java
@@ -0,0 +1,42 @@
+package io.papermc.paper.plugin.manager;
+
+import org.bukkit.permissions.Permissible;
+import org.bukkit.permissions.Permission;
+import org.bukkit.plugin.SimplePluginManager;
+
+import java.util.Map;
+import java.util.Set;
+
+/*
+This is actually so cursed I hate it.
+We need to wrap these in fields as people override the fields, so we need to access them lazily at all times.
+// TODO: When SimplePluginManager is GONE remove this and cleanup the PaperPermissionManager to use actual fields.
+ */
+class StupidSPMPermissionManagerWrapper extends PaperPermissionManager {
+
+    private final SimplePluginManager simplePluginManager;
+
+    public StupidSPMPermissionManagerWrapper(SimplePluginManager simplePluginManager) {
+        this.simplePluginManager = simplePluginManager;
+    }
+
+    @Override
+    public Map<String, Permission> permissions() {
+        return this.simplePluginManager.permissions;
+    }
+
+    @Override
+    public Map<Boolean, Set<Permission>> defaultPerms() {
+        return this.simplePluginManager.defaultPerms;
+    }
+
+    @Override
+    public Map<String, Map<Permissible, Boolean>> permSubs() {
+        return this.simplePluginManager.permSubs;
+    }
+
+    @Override
+    public Map<Boolean, Map<Permissible, Boolean>> defSubs() {
+        return this.simplePluginManager.defSubs;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/PluginProvider.java b/src/main/java/io/papermc/paper/plugin/provider/PluginProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..6fdf37311431baa5505d85cc5f044823414026ef
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/PluginProvider.java
@@ -0,0 +1,53 @@
+package io.papermc.paper.plugin.provider;
+
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.provider.configuration.LoadOrderConfiguration;
+import io.papermc.paper.plugin.provider.entrypoint.DependencyContext;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.nio.file.Path;
+import java.util.List;
+import java.util.Map;
+import java.util.jar.JarFile;
+
+/**
+ * PluginProviders are created by a {@link io.papermc.paper.plugin.provider.source.ProviderSource},
+ * which is loaded into an {@link io.papermc.paper.plugin.entrypoint.EntrypointHandler}.
+ * <p>
+ * A PluginProvider is responsible for providing part of a plugin, whether it's a Bootstrapper or Server Plugin.
+ * The point of this class is to be able to create the actual instance later, as at the time this is created the server
+ * may be missing some key parts. For example, the Bukkit singleton will not be initialized yet, therefor we need to
+ * have a PluginServerProvider load the server plugin later.
+ * <p>
+ * Plugin providers are currently not exposed in any way of the api. It is preferred that this stays this way,
+ * as providers are only needed for initialization.
+ *
+ * @param <T> provider type
+ */
+@ApiStatus.Internal
+public interface PluginProvider<T> {
+
+    @NotNull
+    Path getSource();
+
+    default Path getFileName() {
+        return this.getSource().getFileName();
+    }
+
+    default Path getParentSource() {
+        return this.getSource().getParent();
+    }
+
+    JarFile file();
+
+    T createInstance();
+
+    PluginMeta getMeta();
+
+    LoadOrderConfiguration createConfiguration(@NotNull Map<String, PluginProvider<?>> toLoad);
+
+    // Returns a list of missing dependencies
+    List<String> validateDependencies(@NotNull DependencyContext context);
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/ProviderStatus.java b/src/main/java/io/papermc/paper/plugin/provider/ProviderStatus.java
new file mode 100644
index 0000000000000000000000000000000000000000..6154e864b0ff01cb70acaaeee5ca8c9f4a90a90e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/ProviderStatus.java
@@ -0,0 +1,13 @@
+package io.papermc.paper.plugin.provider;
+
+import org.jetbrains.annotations.ApiStatus;
+
+/**
+ * This is used for the /plugins command, where it will look in the {@link io.papermc.paper.plugin.entrypoint.LaunchEntryPointHandler} and
+ * use the provider statuses to determine the color.
+ */
+@ApiStatus.Internal
+public enum ProviderStatus {
+    INITIALIZED,
+    ERRORED,
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/ProviderStatusHolder.java b/src/main/java/io/papermc/paper/plugin/provider/ProviderStatusHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..17284d0f61c459dff765c0adae4ad2c641e054c1
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/ProviderStatusHolder.java
@@ -0,0 +1,11 @@
+package io.papermc.paper.plugin.provider;
+
+/**
+ * This is used to mark that a plugin provider is able to hold a status for the /plugins command.
+ */
+public interface ProviderStatusHolder {
+
+    ProviderStatus getLastProvidedStatus();
+
+    void setStatus(ProviderStatus status);
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/FlattenedResolver.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/FlattenedResolver.java
new file mode 100644
index 0000000000000000000000000000000000000000..6ba3bcc468c0a60c76d6d0f0243bda661c737f2f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/FlattenedResolver.java
@@ -0,0 +1,29 @@
+package io.papermc.paper.plugin.provider.configuration;
+
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.spongepowered.configurate.objectmapping.meta.NodeResolver;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+import java.lang.reflect.AnnotatedElement;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface FlattenedResolver {
+
+    final class Factory implements NodeResolver.Factory {
+
+        @Override
+        public @Nullable NodeResolver make(String name, AnnotatedElement element) {
+            if (element.isAnnotationPresent(FlattenedResolver.class)) {
+                return (node) -> node;
+            } else {
+                return null;
+            }
+        }
+    }
+
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/LegacyPaperMeta.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/LegacyPaperMeta.java
new file mode 100644
index 0000000000000000000000000000000000000000..211a28d65a2cd5904787ab3bcdbc2cdb7242dea8
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/LegacyPaperMeta.java
@@ -0,0 +1,142 @@
+package io.papermc.paper.plugin.provider.configuration;
+
+import com.google.gson.reflect.TypeToken;
+import io.papermc.paper.plugin.provider.configuration.type.DependencyConfiguration;
+import io.papermc.paper.plugin.provider.configuration.type.PluginDependencyLifeCycle;
+import org.spongepowered.configurate.CommentedConfigurationNode;
+import org.spongepowered.configurate.ConfigurateException;
+import org.spongepowered.configurate.NodePath;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+import org.spongepowered.configurate.objectmapping.meta.Required;
+import org.spongepowered.configurate.serialize.SerializationException;
+import org.spongepowered.configurate.transformation.ConfigurationTransformation;
+
+import java.util.*;
+
+class LegacyPaperMeta {
+
+
+    private static final TypeToken<Map<PluginDependencyLifeCycle, Map<String, DependencyConfiguration>>> TYPE_TOKEN = new TypeToken<>() {
+    };
+
+    public static void migrate(CommentedConfigurationNode node) throws ConfigurateException {
+        ConfigurationTransformation.chain(notVersioned()).apply(node);
+    }
+
+    private static ConfigurationTransformation notVersioned() {
+        return ConfigurationTransformation.builder()
+            .addAction(NodePath.path(), (path, value) -> {
+                boolean bootstrapSubSection = value.hasChild("bootstrap");
+                boolean serverSubSection = value.hasChild("server");
+
+                // Ignore if using newer format
+                if (bootstrapSubSection || serverSubSection) {
+                    return null;
+                }
+
+                // First collect all load before elements
+                LegacyConfiguration legacyConfiguration;
+                try {
+                    legacyConfiguration = value.require(LegacyConfiguration.class);
+                } catch (SerializationException exception) {
+                    // Ignore if not present
+                    return null;
+                }
+
+                Map<PluginDependencyLifeCycle, Map<String, DependencyConfiguration>> dependencies = new EnumMap<>(PluginDependencyLifeCycle.class);
+                dependencies.put(PluginDependencyLifeCycle.BOOTSTRAP, new HashMap<>());
+                dependencies.put(PluginDependencyLifeCycle.SERVER, new HashMap<>());
+
+                Map<PluginDependencyLifeCycle, Map<String, Set<DependencyFlag>>> dependencyConfigurationMap = new HashMap<>();
+                dependencyConfigurationMap.put(PluginDependencyLifeCycle.BOOTSTRAP, new HashMap<>());
+                dependencyConfigurationMap.put(PluginDependencyLifeCycle.SERVER, new HashMap<>());
+
+                // Migrate loadafter
+                for (LegacyLoadConfiguration legacyConfig : legacyConfiguration.loadAfter) {
+                    Set<DependencyFlag> dependencyFlags = dependencyConfigurationMap
+                        .get(legacyConfig.bootstrap ? PluginDependencyLifeCycle.BOOTSTRAP : PluginDependencyLifeCycle.SERVER)
+                        .computeIfAbsent(legacyConfig.name, s -> EnumSet.noneOf(DependencyFlag.class));
+
+                    dependencyFlags.add(DependencyFlag.LOAD_AFTER);
+                }
+
+                // Migrate loadbefore
+                for (LegacyLoadConfiguration legacyConfig : legacyConfiguration.loadBefore) {
+                    Set<DependencyFlag> dependencyFlags = dependencyConfigurationMap
+                        .get(legacyConfig.bootstrap ? PluginDependencyLifeCycle.BOOTSTRAP : PluginDependencyLifeCycle.SERVER)
+                        .computeIfAbsent(legacyConfig.name, s -> EnumSet.noneOf(DependencyFlag.class));
+
+                    dependencyFlags.add(DependencyFlag.LOAD_BEFORE);
+                }
+
+                // Migrate dependencies
+                for (LegacyDependencyConfiguration legacyConfig : legacyConfiguration.dependencies) {
+                    Set<DependencyFlag> dependencyFlags = dependencyConfigurationMap
+                        .get(legacyConfig.bootstrap ? PluginDependencyLifeCycle.BOOTSTRAP : PluginDependencyLifeCycle.SERVER)
+                        .computeIfAbsent(legacyConfig.name, s -> EnumSet.noneOf(DependencyFlag.class));
+
+                    dependencyFlags.add(DependencyFlag.DEPENDENCY);
+                    if (legacyConfig.required) {
+                        dependencyFlags.add(DependencyFlag.REQUIRED);
+                    }
+                }
+                for (Map.Entry<PluginDependencyLifeCycle, Map<String, Set<DependencyFlag>>> legacyTypes : dependencyConfigurationMap.entrySet()) {
+                    Map<String, DependencyConfiguration> flagMap = dependencies.get(legacyTypes.getKey());
+                    for (Map.Entry<String, Set<DependencyFlag>> entry : legacyTypes.getValue().entrySet()) {
+                        Set<DependencyFlag> flags = entry.getValue();
+
+
+                        DependencyConfiguration.LoadOrder loadOrder = DependencyConfiguration.LoadOrder.OMIT;
+                        // These meanings are now swapped
+                        if (flags.contains(DependencyFlag.LOAD_BEFORE)) {
+                            loadOrder = DependencyConfiguration.LoadOrder.AFTER;
+                        } else if (flags.contains(DependencyFlag.LOAD_AFTER)) {
+                            loadOrder = DependencyConfiguration.LoadOrder.BEFORE;
+                        }
+
+                        flagMap.put(entry.getKey(), new DependencyConfiguration(
+                            loadOrder,
+                            flags.contains(DependencyFlag.REQUIRED),
+                            flags.contains(DependencyFlag.DEPENDENCY)
+                        ));
+                    }
+                }
+
+                value.node("dependencies").set(TYPE_TOKEN.getType(), dependencies);
+                return null;
+            })
+            .build();
+    }
+
+    @ConfigSerializable
+    record LegacyLoadConfiguration(
+        @Required String name,
+        boolean bootstrap
+    ) {
+    }
+
+    @ConfigSerializable
+    private static class LegacyConfiguration {
+
+        private List<LegacyLoadConfiguration> loadAfter = List.of();
+        private List<LegacyLoadConfiguration> loadBefore = List.of();
+        private List<LegacyDependencyConfiguration> dependencies = List.of();
+    }
+
+
+    @ConfigSerializable
+    public record LegacyDependencyConfiguration(
+        @Required String name,
+        boolean required,
+        boolean bootstrap
+    ) {
+    }
+
+    enum DependencyFlag {
+        LOAD_AFTER,
+        LOAD_BEFORE,
+        REQUIRED,
+        DEPENDENCY
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/LoadOrderConfiguration.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/LoadOrderConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..e3430f535e8e9c3b8b44bf2daece8c47e8b14db7
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/LoadOrderConfiguration.java
@@ -0,0 +1,38 @@
+package io.papermc.paper.plugin.provider.configuration;
+
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+/**
+ * This is used for plugins to configure the load order of strategies.
+ */
+public interface LoadOrderConfiguration {
+
+    /**
+     * Provides a list of plugins that THIS configuration should load
+     * before.
+     *
+     * @return list of plugins
+     */
+    @NotNull
+    List<String> getLoadBefore();
+
+    /**
+     * Provides a list of plugins that THIS configuration should load
+     * before.
+     *
+     * @return list of plugins
+     */
+    @NotNull
+    List<String> getLoadAfter();
+
+    /**
+     * Gets the responsible plugin provider's meta.
+     *
+     * @return meta
+     */
+    @NotNull
+    PluginMeta getMeta();
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/PaperPluginMeta.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/PaperPluginMeta.java
new file mode 100644
index 0000000000000000000000000000000000000000..6ae2a15bcf06b781abb824e07b7be0c51fc00fb8
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/PaperPluginMeta.java
@@ -0,0 +1,269 @@
+package io.papermc.paper.plugin.provider.configuration;
+
+import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableList;
+import io.papermc.paper.configuration.constraint.Constraint;
+import io.papermc.paper.configuration.serializer.EnumValueSerializer;
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.provider.configuration.serializer.PermissionConfigurationSerializer;
+import io.papermc.paper.plugin.provider.configuration.serializer.constraints.PluginConfigConstraints;
+import io.papermc.paper.plugin.provider.configuration.type.DependencyConfiguration;
+import io.papermc.paper.plugin.provider.configuration.type.PermissionConfiguration;
+import io.papermc.paper.plugin.provider.configuration.type.PluginDependencyLifeCycle;
+import org.bukkit.craftbukkit.util.ApiVersion;
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionDefault;
+import org.bukkit.plugin.PluginLoadOrder;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.TestOnly;
+import org.spongepowered.configurate.CommentedConfigurationNode;
+import org.spongepowered.configurate.ConfigurateException;
+import org.spongepowered.configurate.loader.HeaderMode;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+import org.spongepowered.configurate.objectmapping.ObjectMapper;
+import org.spongepowered.configurate.objectmapping.meta.Required;
+import org.spongepowered.configurate.serialize.ScalarSerializer;
+import org.spongepowered.configurate.serialize.SerializationException;
+import org.spongepowered.configurate.yaml.NodeStyle;
+import org.spongepowered.configurate.yaml.YamlConfigurationLoader;
+
+import java.io.BufferedReader;
+import java.lang.reflect.Type;
+import java.util.EnumMap;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Predicate;
+
+@SuppressWarnings({"CanBeFinal", "FieldCanBeLocal", "FieldMayBeFinal", "NotNullFieldNotInitialized", "InnerClassMayBeStatic"})
+@ConfigSerializable
+public class PaperPluginMeta implements PluginMeta {
+
+    @PluginConfigConstraints.PluginName
+    @Required
+    private String name;
+    @Required
+    @PluginConfigConstraints.PluginNameSpace
+    private String main;
+    @PluginConfigConstraints.PluginNameSpace
+    private String bootstrapper;
+    @PluginConfigConstraints.PluginNameSpace
+    private String loader;
+    private List<String> provides = List.of();
+    private boolean hasOpenClassloader = false;
+    @Required
+    private String version;
+    private String description;
+    private List<String> authors = List.of();
+    private List<String> contributors = List.of();
+    private String website;
+    private String prefix;
+    private PluginLoadOrder load = PluginLoadOrder.POSTWORLD;
+    @FlattenedResolver
+    private PermissionConfiguration permissionConfiguration = new PermissionConfiguration(PermissionDefault.OP, List.of());
+    @Required
+    private ApiVersion apiVersion;
+
+    private Map<PluginDependencyLifeCycle, Map<String, DependencyConfiguration>> dependencies = new EnumMap<>(PluginDependencyLifeCycle.class);
+
+    public PaperPluginMeta() {
+    }
+
+    static final ApiVersion MINIMUM = ApiVersion.getOrCreateVersion("1.16");
+    public static PaperPluginMeta create(BufferedReader reader) throws ConfigurateException {
+        YamlConfigurationLoader loader = YamlConfigurationLoader.builder()
+            .indent(2)
+            .nodeStyle(NodeStyle.BLOCK)
+            .headerMode(HeaderMode.NONE)
+            .source(() -> reader)
+            .defaultOptions((options) -> {
+
+                return options.serializers((serializers) -> {
+                    serializers
+                        .register(new ScalarSerializer<>(ApiVersion.class) {
+                            @Override
+                            public ApiVersion deserialize(final Type type, final Object obj) throws SerializationException {
+                                try {
+                                    final ApiVersion version = ApiVersion.getOrCreateVersion(obj.toString());
+                                    if (version.isOlderThan(MINIMUM)) {
+                                        throw new SerializationException(version + " is too old for a paper plugin!");
+                                    }
+                                    return version;
+                                } catch (final IllegalArgumentException e) {
+                                    throw new SerializationException(e);
+                                }
+                            }
+
+                            @Override
+                            protected Object serialize(final ApiVersion item, final Predicate<Class<?>> typeSupported) {
+                                return item.getVersionString();
+                            }
+                        })
+                        .register(new EnumValueSerializer())
+                        .register(PermissionConfiguration.class, PermissionConfigurationSerializer.SERIALIZER)
+                        .registerAnnotatedObjects(
+                            ObjectMapper.factoryBuilder()
+                                .addConstraint(Constraint.class, new Constraint.Factory())
+                                .addConstraint(PluginConfigConstraints.PluginName.class, String.class, new PluginConfigConstraints.PluginName.Factory())
+                                .addConstraint(PluginConfigConstraints.PluginNameSpace.class, String.class, new PluginConfigConstraints.PluginNameSpace.Factory())
+                                .addNodeResolver(new FlattenedResolver.Factory())
+                                .build()
+                        );
+
+                });
+            })
+            .build();
+        CommentedConfigurationNode node = loader.load();
+        LegacyPaperMeta.migrate(node);
+        PaperPluginMeta pluginConfiguration = node.require(PaperPluginMeta.class);
+
+        if (!node.node("author").virtual()) {
+            pluginConfiguration.authors = ImmutableList.<String>builder()
+                .addAll(pluginConfiguration.authors)
+                .add(node.node("author").getString())
+                .build();
+        }
+
+        return pluginConfiguration;
+    }
+
+    @Override
+    public @NotNull String getName() {
+        return this.name;
+    }
+
+    @TestOnly
+    public void setName(@NotNull String name) {
+        Preconditions.checkNotNull(name, "name");
+        this.name = name;
+    }
+
+    @Override
+    public @NotNull String getMainClass() {
+        return this.main;
+    }
+
+    @Override
+    public @NotNull String getVersion() {
+        return this.version;
+    }
+
+    @TestOnly
+    public void setVersion(@NotNull String version) {
+        Preconditions.checkNotNull(version, "version");
+        this.version = version;
+    }
+
+    @Override
+    public @Nullable String getLoggerPrefix() {
+        return this.prefix;
+    }
+
+    @Override
+    public @NotNull List<String> getPluginDependencies() {
+        return this.dependencies.getOrDefault(PluginDependencyLifeCycle.SERVER, Map.of())
+            .entrySet()
+            .stream()
+            .filter((entry) -> entry.getValue().required() && entry.getValue().joinClasspath())
+            .map(Map.Entry::getKey)
+            .toList();
+    }
+
+    @Override
+    public @NotNull List<String> getPluginSoftDependencies() {
+        return this.dependencies.getOrDefault(PluginDependencyLifeCycle.SERVER, Map.of())
+            .entrySet()
+            .stream()
+            .filter((entry) -> !entry.getValue().required() && entry.getValue().joinClasspath())
+            .map(Map.Entry::getKey)
+            .toList();
+    }
+
+    @Override
+    public @NotNull List<String> getLoadBeforePlugins() {
+        return this.dependencies.getOrDefault(PluginDependencyLifeCycle.SERVER, Map.of())
+            .entrySet()
+            .stream()
+            // This plugin will load BEFORE all dependencies (so dependencies will load AFTER plugin)
+            .filter((entry) -> entry.getValue().load() == DependencyConfiguration.LoadOrder.AFTER)
+            .map(Map.Entry::getKey)
+            .toList();
+    }
+
+    public @NotNull List<String> getLoadAfterPlugins() {
+        return this.dependencies.getOrDefault(PluginDependencyLifeCycle.SERVER, Map.of())
+            .entrySet()
+            .stream()
+            // This plugin will load AFTER all dependencies (so dependencies will load BEFORE plugin)
+            .filter((entry) -> entry.getValue().load() == DependencyConfiguration.LoadOrder.BEFORE)
+            .map(Map.Entry::getKey)
+            .toList();
+    }
+
+
+    public Map<String, DependencyConfiguration> getServerDependencies() {
+        return this.dependencies.getOrDefault(PluginDependencyLifeCycle.SERVER, Map.of());
+    }
+
+    public Map<String, DependencyConfiguration> getBoostrapDependencies() {
+        return this.dependencies.getOrDefault(PluginDependencyLifeCycle.BOOTSTRAP, Map.of());
+    }
+
+    @Override
+    public @NotNull PluginLoadOrder getLoadOrder() {
+        return this.load;
+    }
+
+    @Override
+    public @NotNull String getDescription() {
+        return this.description;
+    }
+
+    @Override
+    public @NotNull List<String> getAuthors() {
+        return this.authors;
+    }
+
+    @Override
+    public @NotNull List<String> getContributors() {
+        return this.contributors;
+    }
+
+    @Override
+    public String getWebsite() {
+        return this.website;
+    }
+
+    @Override
+    public @NotNull List<Permission> getPermissions() {
+        return this.permissionConfiguration.permissions();
+    }
+
+    @Override
+    public @NotNull PermissionDefault getPermissionDefault() {
+        return this.permissionConfiguration.defaultPerm();
+    }
+
+    @Override
+    public @NotNull String getAPIVersion() {
+        return this.apiVersion.getVersionString();
+    }
+
+    @Override
+    public @NotNull List<String> getProvidedPlugins() {
+        return this.provides;
+    }
+
+    public String getBootstrapper() {
+        return this.bootstrapper;
+    }
+
+    public String getLoader() {
+        return this.loader;
+    }
+
+    public boolean hasOpenClassloader() {
+        return this.hasOpenClassloader;
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/ImmutableCollectionSerializer.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/ImmutableCollectionSerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..f0cdb1bab30faaa438aa3e6de6125ade3fae98c2
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/ImmutableCollectionSerializer.java
@@ -0,0 +1,90 @@
+package io.papermc.paper.plugin.provider.configuration.serializer;
+
+import com.google.common.collect.ImmutableCollection;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.spongepowered.configurate.ConfigurationNode;
+import org.spongepowered.configurate.ConfigurationOptions;
+import org.spongepowered.configurate.serialize.SerializationException;
+import org.spongepowered.configurate.serialize.TypeSerializer;
+import org.spongepowered.configurate.util.CheckedConsumer;
+
+import java.lang.reflect.Type;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+@SuppressWarnings("unchecked")
+public abstract class ImmutableCollectionSerializer<B extends ImmutableCollection.Builder<?>, T extends Collection<?>> implements TypeSerializer<T> {
+
+    protected ImmutableCollectionSerializer() {
+    }
+
+    @Override
+    public final T deserialize(final Type type, final ConfigurationNode node) throws SerializationException {
+        final Type entryType = this.elementType(type);
+        final @Nullable TypeSerializer<?> entrySerial = node.options().serializers().get(entryType);
+        if (entrySerial == null) {
+            throw new SerializationException(node, entryType, "No applicable type serializer for type");
+        }
+
+        if (node.isList()) {
+            final List<? extends ConfigurationNode> values = node.childrenList();
+            final B builder = this.createNew(values.size());
+            for (ConfigurationNode value : values) {
+                try {
+                    this.deserializeSingle(builder, entrySerial.deserialize(entryType, value));
+                } catch (final SerializationException ex) {
+                    ex.initPath(value::path);
+                    throw ex;
+                }
+            }
+            return (T) builder.build();
+        } else {
+            final @Nullable Object unwrappedVal = node.raw();
+            if (unwrappedVal != null) {
+                final B builder = this.createNew(1);
+                this.deserializeSingle(builder, entrySerial.deserialize(entryType, node));
+                return (T) builder.build();
+            }
+        }
+        return this.emptyValue(type, null);
+    }
+
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    @Override
+    public final void serialize(final Type type, final @Nullable T obj, final ConfigurationNode node) throws SerializationException {
+        final Type entryType = this.elementType(type);
+        final @Nullable TypeSerializer entrySerial = node.options().serializers().get(entryType);
+        if (entrySerial == null) {
+            throw new SerializationException(node, entryType, "No applicable type serializer for type");
+        }
+
+        node.raw(Collections.emptyList());
+        if (obj != null) {
+            this.forEachElement(obj, el -> {
+                final ConfigurationNode child = node.appendListNode();
+                try {
+                    entrySerial.serialize(entryType, el, child);
+                } catch (final SerializationException ex) {
+                    ex.initPath(child::path);
+                    throw ex;
+                }
+            });
+        }
+    }
+
+    @SuppressWarnings({"unchecked"})
+    @Override
+    public @Nullable T emptyValue(final Type specificType, final ConfigurationOptions options) {
+        return (T) this.createNew(0).build();
+    }
+
+    protected abstract Type elementType(Type containerType) throws SerializationException;
+
+    protected abstract B createNew(int size);
+
+    protected abstract void forEachElement(T collection, CheckedConsumer<Object, SerializationException> action) throws SerializationException;
+
+    protected abstract void deserializeSingle(B builder, @Nullable Object deserialized) throws SerializationException;
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/ImmutableListSerializer.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/ImmutableListSerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..8ef7143e102de0527592c97c634ef95f8c09b6aa
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/ImmutableListSerializer.java
@@ -0,0 +1,43 @@
+package io.papermc.paper.plugin.provider.configuration.serializer;
+
+import com.google.common.collect.ImmutableList;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.spongepowered.configurate.serialize.SerializationException;
+import org.spongepowered.configurate.util.CheckedConsumer;
+
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.List;
+
+public class ImmutableListSerializer extends ImmutableCollectionSerializer<ImmutableList.Builder<?>, List<?>> {
+
+    @Override
+    protected Type elementType(Type containerType) throws SerializationException {
+        if (!(containerType instanceof ParameterizedType)) {
+            throw new SerializationException(containerType, "Raw types are not supported for collections");
+        }
+        return ((ParameterizedType) containerType).getActualTypeArguments()[0];
+    }
+
+    @Override
+    protected ImmutableList.Builder<?> createNew(int size) {
+        return ImmutableList.builder();
+    }
+
+    @Override
+    protected void forEachElement(List<?> collection, CheckedConsumer<Object, SerializationException> action) throws SerializationException {
+        for (Object obj : collection) {
+            action.accept(obj);
+        }
+    }
+
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    @Override
+    protected void deserializeSingle(ImmutableList.Builder<?> builder, @Nullable Object deserialized) throws SerializationException {
+        if (deserialized == null) {
+            return;
+        }
+
+        ((ImmutableList.Builder) builder).add(deserialized);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/PermissionConfigurationSerializer.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/PermissionConfigurationSerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..f951f4024745503e9cdfa7ff17b9313ac6d7b4c4
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/PermissionConfigurationSerializer.java
@@ -0,0 +1,56 @@
+package io.papermc.paper.plugin.provider.configuration.serializer;
+
+import io.papermc.paper.plugin.provider.configuration.type.PermissionConfiguration;
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionDefault;
+import org.spongepowered.configurate.ConfigurationNode;
+import org.spongepowered.configurate.serialize.SerializationException;
+import org.spongepowered.configurate.serialize.TypeSerializer;
+
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+public class PermissionConfigurationSerializer {
+
+    public static final Serializer SERIALIZER = new Serializer();
+
+    private static final class Serializer implements TypeSerializer<PermissionConfiguration> {
+        private Serializer() {
+            super();
+        }
+
+        @Override
+        public PermissionConfiguration deserialize(Type type, ConfigurationNode node) throws SerializationException {
+            Map<?, ?> map = (Map<?, ?>) node.node("permissions").raw();
+
+            PermissionDefault permissionDefault;
+            ConfigurationNode permNode = node.node("defaultPerm");
+            if (permNode.virtual()) {
+                permissionDefault = PermissionDefault.OP;
+            } else {
+                permissionDefault = PermissionDefault.getByName(permNode.getString());
+            }
+
+            List<Permission> result = new ArrayList<>();
+            if (map != null) {
+                for (Map.Entry<?, ?> entry : map.entrySet()) {
+                    try {
+                        result.add(Permission.loadPermission(entry.getKey().toString(), (Map<?, ?>) entry.getValue(), permissionDefault, result));
+                    } catch (Throwable ex) {
+                        throw new SerializationException((Type) null, "Error loading permission %s".formatted(entry.getKey()), ex);
+                    }
+                }
+            }
+
+            return new PermissionConfiguration(permissionDefault, List.copyOf(result));
+        }
+
+        @Override
+        public void serialize(Type type, @org.checkerframework.checker.nullness.qual.Nullable PermissionConfiguration obj, ConfigurationNode node) throws SerializationException {
+
+        }
+
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/constraints/PluginConfigConstraints.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/constraints/PluginConfigConstraints.java
new file mode 100644
index 0000000000000000000000000000000000000000..da79ce7beeede8639bc2cb30a53ebfa1830de90a
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/constraints/PluginConfigConstraints.java
@@ -0,0 +1,63 @@
+package io.papermc.paper.plugin.provider.configuration.serializer.constraints;
+
+import io.papermc.paper.plugin.util.NamespaceChecker;
+import org.spongepowered.configurate.objectmapping.meta.Constraint;
+import org.spongepowered.configurate.serialize.SerializationException;
+
+import java.lang.annotation.*;
+import java.lang.reflect.Type;
+import java.util.Locale;
+import java.util.Set;
+import java.util.regex.Pattern;
+
+public final class PluginConfigConstraints {
+
+    public static final Set<String> RESERVED_KEYS = Set.of("bukkit", "minecraft", "mojang", "spigot", "paper");
+
+    @Documented
+    @Retention(RetentionPolicy.RUNTIME)
+    @Target(ElementType.FIELD)
+    public @interface PluginName {
+
+        final class Factory implements Constraint.Factory<PluginName, String> {
+
+            private static final Pattern VALID_NAME = Pattern.compile("^[A-Za-z\\d _.-]+$");
+
+            @Override
+            public Constraint<String> make(PluginName data, Type type) {
+                return value -> {
+                    if (value != null) {
+                        if (RESERVED_KEYS.contains(value.toLowerCase(Locale.ROOT))) {
+                            throw new SerializationException("Restricted name, cannot use '%s' as a plugin name.".formatted(data));
+                        } else if (value.indexOf(' ') != -1) {
+                            // For legacy reasons, the space condition has a separate exception message.
+                            throw new SerializationException("Restricted name, cannot use 0x20 (space character) in a plugin name.");
+                        }
+
+                        if (!VALID_NAME.matcher(value).matches()) {
+                            throw new SerializationException("name '" + value + "' contains invalid characters.");
+                        }
+                    }
+                };
+            }
+        }
+    }
+
+    @Documented
+    @Retention(RetentionPolicy.RUNTIME)
+    @Target(ElementType.FIELD)
+    public @interface PluginNameSpace {
+
+        final class Factory implements Constraint.Factory<PluginNameSpace, String> {
+
+            @Override
+            public Constraint<String> make(PluginNameSpace data, Type type) {
+                return value -> {
+                    if (value != null && !NamespaceChecker.isValidNameSpace(value)) {
+                        throw new SerializationException("provided class '%s' is in an invalid namespace.".formatted(value));
+                    }
+                };
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/type/DependencyConfiguration.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/type/DependencyConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..957fb5e60ba6bd8760e8f6016d7bb6e8a405e163
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/type/DependencyConfiguration.java
@@ -0,0 +1,30 @@
+package io.papermc.paper.plugin.provider.configuration.type;
+
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+import static java.util.Objects.requireNonNullElse;
+
+@DefaultQualifier(NonNull.class)
+@ConfigSerializable
+public record DependencyConfiguration(
+    LoadOrder load,
+    Boolean required,
+    Boolean joinClasspath
+) {
+    @SuppressWarnings("DataFlowIssue") // incorrect intellij inspections
+    public DependencyConfiguration {
+        required = requireNonNullElse(required, true);
+        joinClasspath = requireNonNullElse(joinClasspath, true);
+    }
+
+    @ConfigSerializable
+    public enum LoadOrder {
+        // dependency will now load BEFORE your plugin
+        BEFORE,
+        // the dependency will now load AFTER your plugin
+        AFTER,
+        OMIT
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/type/LoadConfiguration.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/type/LoadConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..4184e4232c59f15ef8bbc98f82f501fc524f37c7
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/type/LoadConfiguration.java
@@ -0,0 +1,11 @@
+package io.papermc.paper.plugin.provider.configuration.type;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+import org.spongepowered.configurate.objectmapping.meta.Required;
+
+@ConfigSerializable
+public record LoadConfiguration(
+    @Required String name,
+    boolean bootstrap
+) {
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/type/PermissionConfiguration.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/type/PermissionConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..a180612a1ec395202dbae1ca5b97ec01382097e4
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/type/PermissionConfiguration.java
@@ -0,0 +1,14 @@
+package io.papermc.paper.plugin.provider.configuration.type;
+
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionDefault;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+import java.util.List;
+
+// Record components used for deserialization!!!!
+@ConfigSerializable
+public record PermissionConfiguration(
+    PermissionDefault defaultPerm,
+    List<Permission> permissions) {
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/type/PluginDependencyLifeCycle.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/type/PluginDependencyLifeCycle.java
new file mode 100644
index 0000000000000000000000000000000000000000..49a087381307eab263f7dad43aaa25980db33cc2
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/type/PluginDependencyLifeCycle.java
@@ -0,0 +1,6 @@
+package io.papermc.paper.plugin.provider.configuration.type;
+
+public enum PluginDependencyLifeCycle {
+    BOOTSTRAP,
+    SERVER
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/source/DirectoryProviderSource.java b/src/main/java/io/papermc/paper/plugin/provider/source/DirectoryProviderSource.java
new file mode 100644
index 0000000000000000000000000000000000000000..a22d96e009e3e93fc0acf78f48be2d7917298af2
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/source/DirectoryProviderSource.java
@@ -0,0 +1,65 @@
+package io.papermc.paper.plugin.provider.source;
+
+import io.papermc.paper.plugin.entrypoint.EntrypointHandler;
+import net.minecraft.server.MinecraftServer;
+
+import java.io.IOException;
+import java.nio.file.FileVisitOption;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Consumer;
+
+/**
+ * Loads all plugin providers in the given directory.
+ */
+public class DirectoryProviderSource implements ProviderSource<Path, List<Path>> {
+
+    public static final DirectoryProviderSource INSTANCE = new DirectoryProviderSource();
+    private static final FileProviderSource FILE_PROVIDER_SOURCE = new FileProviderSource("Directory '%s'"::formatted, false); // Paper - Remap plugins
+
+    @Override
+    public List<Path> prepareContext(Path context) throws IOException {
+        // Symlink happy, create file if missing.
+        if (!Files.isDirectory(context)) {
+            Files.createDirectories(context);
+        }
+
+        final List<Path> files = new ArrayList<>();
+        this.walkFiles(context, path -> {
+            try {
+                files.add(FILE_PROVIDER_SOURCE.prepareContext(path));
+            } catch (IllegalArgumentException ignored) {
+                // Ignore illegal argument exceptions from jar checking
+            } catch (final Exception e) {
+                MinecraftServer.LOGGER.error("Error preparing plugin context: " + e.getMessage(), e);
+            }
+        });
+        return files;
+    }
+
+    @Override
+    public void registerProviders(EntrypointHandler entrypointHandler, List<Path> context) {
+        for (Path path : context) {
+            try {
+                FILE_PROVIDER_SOURCE.registerProviders(entrypointHandler, path);
+            } catch (IllegalArgumentException ignored) {
+                // Ignore illegal argument exceptions from jar checking
+            } catch (Exception e) {
+                MinecraftServer.LOGGER.error("Error loading plugin: " + e.getMessage(), e);
+            }
+        }
+    }
+
+    private void walkFiles(Path context, Consumer<Path> consumer) throws IOException {
+        Files.walk(context, 1, FileVisitOption.FOLLOW_LINKS)
+            .filter(this::isValidFile)
+            .forEach(consumer);
+    }
+
+    public boolean isValidFile(Path path) {
+        // Avoid loading plugins that start with a dot
+        return Files.isRegularFile(path) && !path.startsWith(".");
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/source/FileArrayProviderSource.java b/src/main/java/io/papermc/paper/plugin/provider/source/FileArrayProviderSource.java
new file mode 100644
index 0000000000000000000000000000000000000000..426aac127305c2999b9fe02cc47d3cdd000db800
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/source/FileArrayProviderSource.java
@@ -0,0 +1,43 @@
+package io.papermc.paper.plugin.provider.source;
+
+import io.papermc.paper.plugin.entrypoint.EntrypointHandler;
+import net.minecraft.server.MinecraftServer;
+
+import java.io.File;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+
+public class FileArrayProviderSource implements ProviderSource<File[], List<Path>> {
+
+    public static final FileArrayProviderSource INSTANCE = new FileArrayProviderSource();
+    private static final FileProviderSource FILE_PROVIDER_SOURCE = new FileProviderSource("File '%s'"::formatted);
+
+    @Override
+    public List<Path> prepareContext(File[] context) {
+        final List<Path> files = new ArrayList<>();
+        for (File file : context) {
+            try {
+                files.add(FILE_PROVIDER_SOURCE.prepareContext(file.toPath()));
+            } catch (IllegalArgumentException ignored) {
+                // Ignore illegal argument exceptions from jar checking
+            } catch (final Exception e) {
+                MinecraftServer.LOGGER.error("Error preparing plugin context: " + e.getMessage(), e);
+            }
+        }
+        return files;
+    }
+
+    @Override
+    public void registerProviders(EntrypointHandler entrypointHandler, List<Path> context) {
+        for (Path path : context) {
+            try {
+                FILE_PROVIDER_SOURCE.registerProviders(entrypointHandler, path);
+            } catch (IllegalArgumentException ignored) {
+                // Ignore illegal argument exceptions from jar checking
+            } catch (Exception e) {
+                MinecraftServer.LOGGER.error("Error loading plugin: " + e.getMessage(), e);
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/source/FileProviderSource.java b/src/main/java/io/papermc/paper/plugin/provider/source/FileProviderSource.java
new file mode 100644
index 0000000000000000000000000000000000000000..2760492354158cad3a6a7b0d74672b5c8a0b5963
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/source/FileProviderSource.java
@@ -0,0 +1,173 @@
+package io.papermc.paper.plugin.provider.source;
+
+import io.papermc.paper.plugin.PluginInitializerManager;
+import io.papermc.paper.plugin.entrypoint.EntrypointHandler;
+import io.papermc.paper.plugin.provider.type.PluginFileType;
+import org.bukkit.plugin.InvalidPluginException;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.*;
+import java.nio.file.attribute.BasicFileAttributes;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.jar.JarFile;
+
+/**
+ * Loads a plugin provider at the given plugin jar file path.
+ */
+public class FileProviderSource implements ProviderSource<Path, Path> {
+
+    private final Function<Path, String> contextChecker;
+    private final boolean applyRemap;
+
+    public FileProviderSource(Function<Path, String> contextChecker, boolean applyRemap) {
+        this.contextChecker = contextChecker;
+        this.applyRemap = applyRemap;
+    }
+
+    public FileProviderSource(Function<Path, String> contextChecker) {
+        this(contextChecker, true);
+    }
+
+    @Override
+    public Path prepareContext(Path context) throws IOException {
+        String source = this.contextChecker.apply(context);
+
+        if (Files.notExists(context)) {
+            throw new IllegalArgumentException(source + " does not exist, cannot load a plugin from it!");
+        }
+
+        if (!Files.isRegularFile(context)) {
+            throw new IllegalArgumentException(source + " is not a file, cannot load a plugin from it!");
+        }
+
+        if (!context.getFileName().toString().endsWith(".jar")) {
+            throw new IllegalArgumentException(source + " is not a jar file, cannot load a plugin from it!");
+        }
+
+        try {
+            context = this.checkUpdate(context);
+        } catch (Exception exception) {
+            throw new RuntimeException(source + " failed to update!", exception);
+        }
+        return context;
+    }
+
+    @Override
+    public void registerProviders(EntrypointHandler entrypointHandler, Path context) throws Exception {
+        String source = this.contextChecker.apply(context);
+
+        JarFile file = new JarFile(context.toFile(), true, JarFile.OPEN_READ, JarFile.runtimeVersion());
+        PluginFileType<?, ?> type = PluginFileType.guessType(file);
+        if (type == null) {
+            // Throw IAE wrapped in RE to prevent callers from considering this a "invalid parameter" as caller ignores IAE.
+            // TODO: This needs some heavy rework, using illegal argument exception to signal an actual failure is less than ideal.
+            if (file.getEntry("META-INF/versions.list") != null) {
+                throw new RuntimeException(new IllegalArgumentException(context + " appears to be a server jar! Server jars do not belong in the plugin folder."));
+            }
+
+            throw new RuntimeException(
+                new IllegalArgumentException(source + " does not contain a " + String.join(" or ", PluginFileType.getConfigTypes()) + "! Could not determine plugin type, cannot load a plugin from it!")
+            );
+        }
+
+        type.register(entrypointHandler, file, context);
+    }
+
+    /**
+     * Replaces a plugin with a plugin of the same plugin name in the update folder.
+     *
+     * @param file
+     */
+    private Path checkUpdate(Path file) throws InvalidPluginException {
+        PluginInitializerManager pluginSystem = PluginInitializerManager.instance();
+        Path updateDirectory = pluginSystem.pluginUpdatePath();
+        if (updateDirectory == null || !Files.isDirectory(updateDirectory)) {
+            return file;
+        }
+
+        try {
+            String pluginName = this.getPluginName(file);
+            UpdateFileVisitor visitor = new UpdateFileVisitor(pluginName);
+            Files.walkFileTree(updateDirectory, Set.of(), 1, visitor);
+            if (visitor.getValidPlugin() != null) {
+                Path updateLocation = visitor.getValidPlugin();
+
+                try {
+                    Files.copy(updateLocation, file, StandardCopyOption.REPLACE_EXISTING);
+                } catch (IOException exception) {
+                    throw new RuntimeException("Could not copy '" + updateLocation + "' to '" + file + "' in update plugin process", exception);
+                }
+
+                // Idk what this is about, TODO
+                File newName = new File(file.toFile().getParentFile(), updateLocation.toFile().getName());
+                file.toFile().renameTo(newName);
+                updateLocation.toFile().delete();
+                return newName.toPath();
+            }
+        } catch (Exception e) {
+            throw new InvalidPluginException(e);
+        }
+        return file;
+    }
+
+    private String getPluginName(Path path) throws Exception {
+        try (JarFile file = new JarFile(path.toFile())) {
+            PluginFileType<?, ?> type = PluginFileType.guessType(file);
+            if (type == null) {
+                throw new IllegalArgumentException(path + " does not contain a " + String.join(" or ", PluginFileType.getConfigTypes()) + "! Could not determine plugin type, cannot load a plugin from it!");
+            }
+
+            return type.getConfig(file).getName();
+        }
+    }
+
+    private class UpdateFileVisitor implements FileVisitor<Path> {
+
+        private final String targetName;
+        @Nullable
+        private Path validPlugin;
+
+        private UpdateFileVisitor(String targetName) {
+            this.targetName = targetName;
+        }
+
+        @Override
+        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
+            return FileVisitResult.CONTINUE;
+        }
+
+        @Override
+        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
+            try {
+                String updatePluginName = FileProviderSource.this.getPluginName(file);
+                if (this.targetName.equals(updatePluginName)) {
+                    this.validPlugin = file;
+                    return FileVisitResult.TERMINATE;
+                }
+            } catch (Exception e) {
+                // We failed to load this data for some reason, so, we'll skip over this
+            }
+
+
+            return FileVisitResult.CONTINUE;
+        }
+
+        @Override
+        public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
+            return FileVisitResult.CONTINUE;
+        }
+
+        @Override
+        public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
+            return FileVisitResult.CONTINUE;
+        }
+
+        @Nullable
+        public Path getValidPlugin() {
+            return validPlugin;
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/source/PluginFlagProviderSource.java b/src/main/java/io/papermc/paper/plugin/provider/source/PluginFlagProviderSource.java
new file mode 100644
index 0000000000000000000000000000000000000000..3178483447f560573bc4b027e2ca0dd44e37013b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/source/PluginFlagProviderSource.java
@@ -0,0 +1,41 @@
+package io.papermc.paper.plugin.provider.source;
+
+import io.papermc.paper.plugin.entrypoint.EntrypointHandler;
+import net.minecraft.server.MinecraftServer;
+
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Registers providers at the provided files in the add-plugin argument.
+ */
+public class PluginFlagProviderSource implements ProviderSource<List<Path>, List<Path>> {
+
+    public static final PluginFlagProviderSource INSTANCE = new PluginFlagProviderSource();
+    private static final FileProviderSource FILE_PROVIDER_SOURCE = new FileProviderSource("File '%s' specified through 'add-plugin' argument"::formatted, false);
+
+    @Override
+    public List<Path> prepareContext(List<Path> context) {
+        final List<Path> files = new ArrayList<>();
+        for (Path path : context) {
+            try {
+                files.add(FILE_PROVIDER_SOURCE.prepareContext(path));
+            } catch (Exception e) {
+                MinecraftServer.LOGGER.error("Error preparing plugin context: " + e.getMessage(), e);
+            }
+        }
+        return files;
+    }
+
+    @Override
+    public void registerProviders(EntrypointHandler entrypointHandler, List<Path> context) {
+        for (Path path : context) {
+            try {
+                FILE_PROVIDER_SOURCE.registerProviders(entrypointHandler, path);
+            } catch (Exception e) {
+                MinecraftServer.LOGGER.error("Error loading plugin: " + e.getMessage(), e);
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/source/ProviderSource.java b/src/main/java/io/papermc/paper/plugin/provider/source/ProviderSource.java
new file mode 100644
index 0000000000000000000000000000000000000000..3293e0acddf5039f660c55fef6203b623e69cbad
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/source/ProviderSource.java
@@ -0,0 +1,33 @@
+package io.papermc.paper.plugin.provider.source;
+
+import io.papermc.paper.plugin.entrypoint.EntrypointHandler;
+
+import java.io.IOException;
+
+/**
+ * A provider source is responsible for giving PluginTypes an EntrypointHandler for
+ * registering providers at.
+ *
+ * @param <I> input context
+ * @param <C> context
+ */
+public interface ProviderSource<I, C> {
+
+    /**
+     * Prepares the context for use in {@link #registerProviders(EntrypointHandler, Object)}.
+     *
+     * @param context the context to prepare
+     * @return the prepared context, ready for use in {@link #registerProviders(EntrypointHandler, Object)}
+     * @throws IOException if an error occurs while preparing the context
+     */
+    C prepareContext(I context) throws IOException;
+
+    /**
+     * Uses the prepared context to register providers at the given entrypoint handler.
+     *
+     * @param entrypointHandler the entrypoint handler to register providers at
+     * @param context           the context to register providers at
+     * @throws Exception if an error occurs while registering providers
+     */
+    void registerProviders(EntrypointHandler entrypointHandler, C context) throws Exception;
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/source/SparkProviderSource.java b/src/main/java/io/papermc/paper/plugin/provider/source/SparkProviderSource.java
new file mode 100644
index 0000000000000000000000000000000000000000..5a3c52ec0dea1a1cb3368b672961057b7c82028b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/source/SparkProviderSource.java
@@ -0,0 +1,114 @@
+package io.papermc.paper.plugin.provider.source;
+
+import io.papermc.paper.plugin.entrypoint.Entrypoint;
+import io.papermc.paper.plugin.entrypoint.EntrypointHandler;
+import io.papermc.paper.plugin.entrypoint.LaunchEntryPointHandler;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.plugin.java.JavaPlugin;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.InputStreamReader;
+import java.math.BigInteger;
+import java.net.URL;
+import java.net.URLConnection;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.StandardCopyOption;
+import java.security.MessageDigest;
+import java.util.stream.Collectors;
+
+public class SparkProviderSource implements ProviderSource<Path, Path> {
+
+    public static final SparkProviderSource INSTANCE = new SparkProviderSource();
+    private static final FileProviderSource FILE_PROVIDER_SOURCE = new FileProviderSource("File '%s' specified by Purpur"::formatted);
+
+    @Override
+    public Path prepareContext(Path context) {
+        // first, check if user doesn't want spark at all
+        if (Boolean.getBoolean("Purpur.IReallyDontWantSpark")) {
+            return null; // boo!
+        }
+
+        // second, check if user has their own spark
+        if (hasSpark()) {
+            MinecraftServer.LOGGER.info("Purpur: Using user-provided spark plugin instead of our own.");
+            return null; // let's hope it's at least the modern version :3
+        }
+
+        // you can't have errors in your code if you wrap the entire codebase in a try/catch block
+        try {
+
+            // make sure the directory exists where we want to keep spark
+            File file = context.toFile();
+            file.getParentFile().mkdirs();
+
+            boolean shouldDownload;
+
+            // check if our spark exists
+            if (!file.exists()) {
+                // it does not, so let's download it
+                shouldDownload = true;
+            } else {
+                // we have a spark file, let's see if it's up-to-date by comparing shas
+                String fileSha1 = String.format("%040x", new BigInteger(1, MessageDigest.getInstance("SHA-1").digest(Files.readAllBytes(file.toPath()))));
+                String sparkSha1;
+
+                // luck has a nifty endpoint containing the sha of the newest version
+                URLConnection urlConnection = new URL("https://sparkapi.lucko.me/download/bukkit/sha1").openConnection();
+
+                // set a reasonable timeout to prevent servers without internet from hanging for 60+ seconds on startup
+                urlConnection.setReadTimeout(5000);
+                urlConnection.setConnectTimeout(5000);
+
+                // read it
+                try (BufferedReader reader = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()))) {
+                    sparkSha1 = reader.lines().collect(Collectors.joining(""));
+                }
+
+                // compare; we only download a new spark if the shas don't match
+                shouldDownload = !fileSha1.equals(sparkSha1);
+            }
+
+            // ok, finally we can download spark if we need it
+            if (shouldDownload) {
+                URLConnection urlConnection = new URL("https://sparkapi.lucko.me/download/bukkit").openConnection();
+                urlConnection.setReadTimeout(5000);
+                urlConnection.setConnectTimeout(5000);
+                Files.copy(urlConnection.getInputStream(), file.toPath(), StandardCopyOption.REPLACE_EXISTING);
+            }
+
+            // register the spark, newly downloaded or existing
+            return FILE_PROVIDER_SOURCE.prepareContext(context);
+
+        } catch (Throwable e) {
+            MinecraftServer.LOGGER.error("Purpur: Failed to download and install spark plugin", e);
+        }
+        return null;
+    }
+
+    @Override
+    public void registerProviders(final EntrypointHandler entrypointHandler, final Path context) {
+        if (context == null) {
+            return;
+        }
+
+        try {
+            FILE_PROVIDER_SOURCE.registerProviders(entrypointHandler, context);
+        } catch (IllegalArgumentException ignored) {
+            // Ignore illegal argument exceptions from jar checking
+        } catch (Exception e) {
+            MinecraftServer.LOGGER.error("Error loading our spark plugin: " + e.getMessage(), e);
+        }
+    }
+
+    private static boolean hasSpark() {
+        for (PluginProvider<JavaPlugin> provider : LaunchEntryPointHandler.INSTANCE.get(Entrypoint.PLUGIN).getRegisteredProviders()) {
+            if (provider.getMeta().getName().equalsIgnoreCase("spark")) {
+                return true;
+            }
+        }
+        return false;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/PluginFileType.java b/src/main/java/io/papermc/paper/plugin/provider/type/PluginFileType.java
new file mode 100644
index 0000000000000000000000000000000000000000..8d0da6e46d4eb5eb05c3144510c4ef083559d0ec
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/PluginFileType.java
@@ -0,0 +1,86 @@
+package io.papermc.paper.plugin.provider.type;
+
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.entrypoint.Entrypoint;
+import io.papermc.paper.plugin.entrypoint.EntrypointHandler;
+import io.papermc.paper.plugin.provider.configuration.PaperPluginMeta;
+import io.papermc.paper.plugin.provider.type.paper.PaperPluginParent;
+import io.papermc.paper.plugin.provider.type.spigot.SpigotPluginProvider;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.jetbrains.annotations.Nullable;
+
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+
+/**
+ * This is where spigot/paper plugins are registered.
+ * This will get the jar and find a certain config file, create an object
+ * then registering it into a {@link EntrypointHandler} at a certain {@link Entrypoint}.
+ */
+public abstract class PluginFileType<T, C extends PluginMeta> {
+
+    public static final String PAPER_PLUGIN_YML = "paper-plugin.yml";
+    private static final List<String> CONFIG_TYPES = new ArrayList<>();
+    
+    public static final PluginFileType<PaperPluginParent, PaperPluginMeta> PAPER = new PluginFileType<>(PAPER_PLUGIN_YML, PaperPluginParent.FACTORY) {
+        @Override
+        protected void register(EntrypointHandler entrypointHandler, PaperPluginParent parent) {
+            PaperPluginParent.PaperBootstrapProvider bootstrapPluginProvider = null;
+            if (parent.shouldCreateBootstrap()) {
+                bootstrapPluginProvider = parent.createBootstrapProvider();
+                entrypointHandler.register(Entrypoint.BOOTSTRAPPER, bootstrapPluginProvider);
+            }
+
+            entrypointHandler.register(Entrypoint.PLUGIN, parent.createPluginProvider(bootstrapPluginProvider));
+        }
+    };
+    public static final PluginFileType<SpigotPluginProvider, PluginDescriptionFile> SPIGOT = new PluginFileType<>("plugin.yml", SpigotPluginProvider.FACTORY) {
+        @Override
+        protected void register(EntrypointHandler entrypointHandler, SpigotPluginProvider provider) {
+            entrypointHandler.register(Entrypoint.PLUGIN, provider);
+        }
+    };
+
+    private static final List<PluginFileType<?, ?>> VALUES = List.of(PAPER, SPIGOT);
+
+    private final String config;
+    private final PluginTypeFactory<T, C> factory;
+
+    PluginFileType(String config, PluginTypeFactory<T, C> factory) {
+        this.config = config;
+        this.factory = factory;
+        CONFIG_TYPES.add(config);
+    }
+
+    @Nullable
+    public static PluginFileType<?, ?> guessType(JarFile file) {
+        for (PluginFileType<?, ?> type : VALUES) {
+            JarEntry entry = file.getJarEntry(type.config);
+            if (entry != null) {
+                return type;
+            }
+        }
+
+        return null;
+    }
+
+    public T register(EntrypointHandler entrypointHandler, JarFile file, Path context) throws Exception {
+        C config = this.getConfig(file);
+        T provider = this.factory.build(file, config, context);
+        this.register(entrypointHandler, provider);
+        return provider;
+    }
+
+    public C getConfig(JarFile file) throws Exception {
+        return this.factory.create(file, file.getJarEntry(this.config));
+    }
+
+    protected abstract void register(EntrypointHandler entrypointHandler, T provider);
+
+    public static List<String> getConfigTypes() {
+        return CONFIG_TYPES;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/PluginTypeFactory.java b/src/main/java/io/papermc/paper/plugin/provider/type/PluginTypeFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..32f230d66f6953520b59ccbf3079c5a6242ca92c
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/PluginTypeFactory.java
@@ -0,0 +1,21 @@
+package io.papermc.paper.plugin.provider.type;
+
+import io.papermc.paper.plugin.configuration.PluginMeta;
+
+import java.nio.file.Path;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+
+/**
+ * A plugin type factory is responsible for building an object
+ * and config for a certain plugin type.
+ *
+ * @param <T> plugin provider type (may not be a plugin provider)
+ * @param <C> config type
+ */
+public interface PluginTypeFactory<T, C extends PluginMeta> {
+
+    T build(JarFile file, C configuration, Path source) throws Exception;
+
+    C create(JarFile file, JarEntry config) throws Exception;
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperBootstrapOrderConfiguration.java b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperBootstrapOrderConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..e34656fb0573ff6d826eb4d4dcfd517e01589206
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperBootstrapOrderConfiguration.java
@@ -0,0 +1,50 @@
+package io.papermc.paper.plugin.provider.type.paper;
+
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.provider.configuration.LoadOrderConfiguration;
+import io.papermc.paper.plugin.provider.configuration.PaperPluginMeta;
+import io.papermc.paper.plugin.provider.configuration.type.DependencyConfiguration;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+public class PaperBootstrapOrderConfiguration implements LoadOrderConfiguration {
+
+    private final PaperPluginMeta paperPluginMeta;
+    private final List<String> loadBefore = new ArrayList<>();
+    private final List<String> loadAfter = new ArrayList<>();
+
+    public PaperBootstrapOrderConfiguration(PaperPluginMeta paperPluginMeta) {
+        this.paperPluginMeta = paperPluginMeta;
+
+        for (Map.Entry<String, DependencyConfiguration> configuration : paperPluginMeta.getBoostrapDependencies().entrySet()) {
+            String name = configuration.getKey();
+            DependencyConfiguration dependencyConfiguration = configuration.getValue();
+
+            if (dependencyConfiguration.load() == DependencyConfiguration.LoadOrder.AFTER) {
+                // This plugin will load BEFORE all dependencies (so dependencies will load AFTER plugin)
+                this.loadBefore.add(name);
+            } else if (dependencyConfiguration.load() == DependencyConfiguration.LoadOrder.BEFORE) {
+                // This plugin will load AFTER all dependencies (so dependencies will load BEFORE plugin)
+                this.loadAfter.add(name);
+            }
+        }
+    }
+
+    @Override
+    public @NotNull List<String> getLoadBefore() {
+        return this.loadBefore;
+    }
+
+    @Override
+    public @NotNull List<String> getLoadAfter() {
+        return this.loadAfter;
+    }
+
+    @Override
+    public @NotNull PluginMeta getMeta() {
+        return this.paperPluginMeta;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperLoadOrderConfiguration.java b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperLoadOrderConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..d905fb283801f272fbba99a58477d439db357971
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperLoadOrderConfiguration.java
@@ -0,0 +1,37 @@
+package io.papermc.paper.plugin.provider.type.paper;
+
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.provider.configuration.LoadOrderConfiguration;
+import io.papermc.paper.plugin.provider.configuration.PaperPluginMeta;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+public class PaperLoadOrderConfiguration implements LoadOrderConfiguration {
+
+    private final PaperPluginMeta meta;
+    private final List<String> loadBefore;
+    private final List<String> loadAfter;
+
+    public PaperLoadOrderConfiguration(PaperPluginMeta meta) {
+        this.meta = meta;
+
+        this.loadBefore = this.meta.getLoadBeforePlugins();
+        this.loadAfter = this.meta.getLoadAfterPlugins();
+    }
+
+    @Override
+    public @NotNull List<String> getLoadBefore() {
+        return this.loadBefore;
+    }
+
+    @Override
+    public @NotNull List<String> getLoadAfter() {
+        return this.loadAfter;
+    }
+
+    @Override
+    public @NotNull PluginMeta getMeta() {
+        return this.meta;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginParent.java b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginParent.java
new file mode 100644
index 0000000000000000000000000000000000000000..e8463f894308fe6d3b683e934b0990242a827f93
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginParent.java
@@ -0,0 +1,252 @@
+package io.papermc.paper.plugin.provider.type.paper;
+
+import com.destroystokyo.paper.util.SneakyThrow;
+import io.papermc.paper.plugin.bootstrap.PluginBootstrap;
+import io.papermc.paper.plugin.bootstrap.PluginProviderContext;
+import io.papermc.paper.plugin.entrypoint.classloader.PaperPluginClassLoader;
+import io.papermc.paper.plugin.entrypoint.dependency.DependencyContextHolder;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.ProviderStatus;
+import io.papermc.paper.plugin.provider.ProviderStatusHolder;
+import io.papermc.paper.plugin.provider.configuration.LoadOrderConfiguration;
+import io.papermc.paper.plugin.provider.configuration.PaperPluginMeta;
+import io.papermc.paper.plugin.provider.configuration.type.DependencyConfiguration;
+import io.papermc.paper.plugin.provider.entrypoint.DependencyContext;
+import io.papermc.paper.plugin.provider.type.PluginTypeFactory;
+import io.papermc.paper.plugin.provider.util.ProviderUtil;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.NotNull;
+
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.jar.JarFile;
+
+public class PaperPluginParent {
+
+    public static final PluginTypeFactory<PaperPluginParent, PaperPluginMeta> FACTORY = new PaperPluginProviderFactory();
+    private final Path path;
+    private final JarFile jarFile;
+    private final PaperPluginMeta description;
+    private final PaperPluginClassLoader classLoader;
+    private final PluginProviderContext context;
+
+    public PaperPluginParent(Path path, JarFile jarFile, PaperPluginMeta description, PaperPluginClassLoader classLoader, PluginProviderContext context) {
+        this.path = path;
+        this.jarFile = jarFile;
+        this.description = description;
+        this.classLoader = classLoader;
+        this.context = context;
+    }
+
+    public boolean shouldCreateBootstrap() {
+        return this.description.getBootstrapper() != null;
+    }
+
+    public PaperBootstrapProvider createBootstrapProvider() {
+        return new PaperBootstrapProvider();
+    }
+
+    public PaperServerPluginProvider createPluginProvider(PaperBootstrapProvider provider) {
+        return new PaperServerPluginProvider(provider);
+    }
+
+    public class PaperBootstrapProvider implements PluginProvider<PluginBootstrap>, ProviderStatusHolder, DependencyContextHolder {
+
+        private ProviderStatus status;
+        private PluginBootstrap lastProvided;
+
+        @Override
+        public @NotNull Path getSource() {
+            return PaperPluginParent.this.path;
+        }
+
+        @Override
+        public JarFile file() {
+            return PaperPluginParent.this.jarFile;
+        }
+
+        @Override
+        public PluginBootstrap createInstance() {
+            PluginBootstrap bootstrap = ProviderUtil.loadClass(PaperPluginParent.this.description.getBootstrapper(),
+                PluginBootstrap.class, PaperPluginParent.this.classLoader, () -> this.status = ProviderStatus.ERRORED);
+            this.status = ProviderStatus.INITIALIZED;
+            this.lastProvided = bootstrap;
+            return bootstrap;
+        }
+
+        @Override
+        public PaperPluginMeta getMeta() {
+            return PaperPluginParent.this.description;
+        }
+
+        @Override
+        public LoadOrderConfiguration createConfiguration(@NotNull Map<String, PluginProvider<?>> toLoad) {
+            return new PaperBootstrapOrderConfiguration(PaperPluginParent.this.description);
+        }
+
+        @Override
+        public List<String> validateDependencies(@NotNull DependencyContext context) {
+            List<String> missingDependencies = new ArrayList<>();
+            for (Map.Entry<String, DependencyConfiguration> configuration : this.getMeta().getBoostrapDependencies().entrySet()) {
+                String dependency = configuration.getKey();
+                if (configuration.getValue().required() && !context.hasDependency(dependency)) {
+                    missingDependencies.add(dependency);
+                }
+            }
+
+            return missingDependencies;
+        }
+
+        @Override
+        public ProviderStatus getLastProvidedStatus() {
+            return this.status;
+        }
+
+        @Override
+        public void setStatus(ProviderStatus status) {
+            this.status = status;
+        }
+
+        public PluginBootstrap getLastProvided() {
+            return this.lastProvided;
+        }
+
+        @Override
+        public void setContext(DependencyContext context) {
+            PaperPluginParent.this.classLoader.refreshClassloaderDependencyTree(context);
+        }
+
+        @Override
+        public String toString() {
+            return "PaperBootstrapProvider{" +
+                "parent=" + PaperPluginParent.this +
+                "status=" + status +
+                ", lastProvided=" + lastProvided +
+                '}';
+        }
+    }
+
+    public class PaperServerPluginProvider implements PluginProvider<JavaPlugin>, ProviderStatusHolder, DependencyContextHolder {
+
+        private final PaperBootstrapProvider bootstrapProvider;
+
+        private ProviderStatus status;
+
+        PaperServerPluginProvider(PaperBootstrapProvider bootstrapProvider) {
+            this.bootstrapProvider = bootstrapProvider;
+        }
+
+        @Override
+        public @NotNull Path getSource() {
+            return PaperPluginParent.this.path;
+        }
+
+        @Override
+        public JarFile file() {
+            return PaperPluginParent.this.jarFile;
+        }
+
+        @Override
+        public JavaPlugin createInstance() {
+            PluginBootstrap bootstrap = null;
+            if (this.bootstrapProvider != null && this.bootstrapProvider.getLastProvided() != null) {
+                bootstrap = this.bootstrapProvider.getLastProvided();
+            }
+
+            try {
+                JavaPlugin plugin;
+                if (bootstrap == null) {
+                    plugin = ProviderUtil.loadClass(PaperPluginParent.this.description.getMainClass(), JavaPlugin.class, PaperPluginParent.this.classLoader);
+                } else {
+                    plugin = bootstrap.createPlugin(PaperPluginParent.this.context);
+                }
+
+                if (!plugin.getClass().isAssignableFrom(Class.forName(PaperPluginParent.this.description.getMainClass(), true, plugin.getClass().getClassLoader()))) {
+                    MinecraftServer.LOGGER.info("Bootstrap of plugin " + PaperPluginParent.this.description.getName() + " provided a plugin instance of class " + plugin.getClass().getName() + " which does not match the plugin declared main class");
+                }
+
+                this.status = ProviderStatus.INITIALIZED;
+                return plugin;
+            } catch (Throwable throwable) {
+                this.status = ProviderStatus.ERRORED;
+                SneakyThrow.sneaky(throwable);
+            }
+
+            throw new AssertionError(); // Impossible
+        }
+
+        @Override
+        public PaperPluginMeta getMeta() {
+            return PaperPluginParent.this.description;
+        }
+
+        @Override
+        public LoadOrderConfiguration createConfiguration(@NotNull Map<String, PluginProvider<?>> toLoad) {
+            return new PaperLoadOrderConfiguration(PaperPluginParent.this.description);
+        }
+
+        @Override
+        public List<String> validateDependencies(@NotNull DependencyContext context) {
+            List<String> missingDependencies = new ArrayList<>();
+            for (Map.Entry<String, DependencyConfiguration> dependency : this.getMeta().getServerDependencies().entrySet()) {
+                String name = dependency.getKey();
+                if (dependency.getValue().required() && !context.hasDependency(name)) {
+                    missingDependencies.add(name);
+                }
+            }
+
+            return missingDependencies;
+        }
+
+        @Override
+        public ProviderStatus getLastProvidedStatus() {
+            return this.status;
+        }
+
+        @Override
+        public void setStatus(ProviderStatus status) {
+            this.status = status;
+        }
+
+        public boolean shouldSkipCreation() {
+            if (this.bootstrapProvider == null) {
+                return false;
+            }
+
+            return this.bootstrapProvider.getLastProvidedStatus() == ProviderStatus.ERRORED;
+        }
+
+        /*
+        The plugin has to reuse the classloader in order to share the bootstrapper.
+        However, a plugin may have totally separate dependencies during bootstrapping.
+        This is a bit yuck, but in general we have to treat bootstrapping and normal game as connected.
+         */
+        @Override
+        public void setContext(DependencyContext context) {
+            PaperPluginParent.this.classLoader.refreshClassloaderDependencyTree(context);
+        }
+
+        @Override
+        public String toString() {
+            return "PaperServerPluginProvider{" +
+                "parent=" + PaperPluginParent.this +
+                "bootstrapProvider=" + bootstrapProvider +
+                ", status=" + status +
+                '}';
+        }
+    }
+
+
+    @Override
+    public String toString() {
+        return "PaperPluginParent{" +
+            "path=" + path +
+            ", jarFile=" + jarFile +
+            ", description=" + description +
+            ", classLoader=" + classLoader +
+            '}';
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginProviderFactory.java b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginProviderFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..0e511b62c70fdf39f4b2b70d7e10139ec5efce7e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginProviderFactory.java
@@ -0,0 +1,54 @@
+package io.papermc.paper.plugin.provider.type.paper;
+
+import com.destroystokyo.paper.utils.PaperPluginLogger;
+import io.papermc.paper.plugin.bootstrap.PluginProviderContext;
+import io.papermc.paper.plugin.bootstrap.PluginProviderContextImpl;
+import io.papermc.paper.plugin.entrypoint.classloader.PaperPluginClassLoader;
+import io.papermc.paper.plugin.entrypoint.classloader.PaperSimplePluginClassLoader;
+import io.papermc.paper.plugin.loader.PaperClasspathBuilder;
+import io.papermc.paper.plugin.loader.PluginLoader;
+import io.papermc.paper.plugin.provider.configuration.PaperPluginMeta;
+import io.papermc.paper.plugin.provider.type.PluginTypeFactory;
+import io.papermc.paper.plugin.provider.util.ProviderUtil;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.nio.file.Path;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+import java.util.logging.Logger;
+
+class PaperPluginProviderFactory implements PluginTypeFactory<PaperPluginParent, PaperPluginMeta> {
+
+    @Override
+    public PaperPluginParent build(JarFile file, PaperPluginMeta configuration, Path source) {
+        Logger jul = PaperPluginLogger.getLogger(configuration);
+        PluginProviderContext context = PluginProviderContextImpl.create(configuration, source);
+
+        PaperClasspathBuilder builder = new PaperClasspathBuilder(context);
+
+        if (configuration.getLoader() != null) {
+            try (
+                PaperSimplePluginClassLoader simplePluginClassLoader = new PaperSimplePluginClassLoader(source, file, configuration, this.getClass().getClassLoader())
+            ) {
+                PluginLoader loader = ProviderUtil.loadClass(configuration.getLoader(), PluginLoader.class, simplePluginClassLoader);
+                loader.classloader(builder);
+            } catch (IOException e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        PaperPluginClassLoader classLoader = builder.buildClassLoader(jul, source, file, configuration);
+        return new PaperPluginParent(source, file, configuration, classLoader, context);
+    }
+
+    @Override
+    public PaperPluginMeta create(JarFile file, JarEntry config) throws IOException {
+        PaperPluginMeta configuration;
+        try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(file.getInputStream(config)))) {
+            configuration = PaperPluginMeta.create(bufferedReader);
+        }
+        return configuration;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotLoadOrderConfiguration.java b/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotLoadOrderConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..c96ea4d129c5127c67805c8ed752ede75194502a
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotLoadOrderConfiguration.java
@@ -0,0 +1,66 @@
+package io.papermc.paper.plugin.provider.type.spigot;
+
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.configuration.LoadOrderConfiguration;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.*;
+
+public class SpigotLoadOrderConfiguration implements LoadOrderConfiguration {
+
+    private final PluginDescriptionFile meta;
+    private final List<String> loadBefore;
+    private final List<String> loadAfter;
+
+    public SpigotLoadOrderConfiguration(SpigotPluginProvider spigotPluginProvider, Map<String, PluginProvider<?>> toLoad) {
+        this.meta = spigotPluginProvider.getMeta();
+
+        this.loadBefore = meta.getLoadBeforePlugins();
+        this.loadAfter = new ArrayList<>();
+        this.loadAfter.addAll(meta.getDepend());
+        this.loadAfter.addAll(meta.getSoftDepend());
+
+        // First: Remove as load after IF already in loadbefore
+        // Some plugins would put a plugin both in depends and in loadbefore,
+        // so in this case, we just ignore the effects of depend.
+        for (String loadBefore : this.loadBefore) {
+            this.loadAfter.remove(loadBefore);
+        }
+
+        // Second: Do a basic check to see if any other dependencies refer back to this plugin.
+        Iterator<String> iterators = this.loadAfter.iterator();
+        while (iterators.hasNext()) {
+            String loadAfter = iterators.next();
+            PluginProvider<?> provider = toLoad.get(loadAfter);
+            if (provider != null) {
+                PluginMeta configuration = provider.getMeta();
+                // Does a configuration refer back to this plugin?
+                Set<String> dependencies = new HashSet<>();
+                dependencies.addAll(configuration.getPluginDependencies());
+                dependencies.addAll(configuration.getPluginSoftDependencies());
+
+                if (configuration.getName().equals(this.meta.getName()) || dependencies.contains(this.meta.getName())) {
+                    iterators.remove(); // Let the other config deal with it
+                }
+            }
+        }
+
+    }
+
+    @Override
+    public @NotNull List<String> getLoadBefore() {
+        return this.loadBefore;
+    }
+
+    @Override
+    public @NotNull List<String> getLoadAfter() {
+        return this.loadAfter;
+    }
+
+    @Override
+    public @NotNull PluginMeta getMeta() {
+        return this.meta;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProvider.java b/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..00b7057a16bb454a97ea3efcdc1cd614233b93ae
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProvider.java
@@ -0,0 +1,187 @@
+package io.papermc.paper.plugin.provider.type.spigot;
+
+import com.destroystokyo.paper.util.SneakyThrow;
+import com.destroystokyo.paper.utils.PaperPluginLogger;
+import io.papermc.paper.plugin.entrypoint.dependency.DependencyContextHolder;
+import io.papermc.paper.plugin.manager.PaperPluginManagerImpl;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.ProviderStatus;
+import io.papermc.paper.plugin.provider.ProviderStatusHolder;
+import io.papermc.paper.plugin.provider.configuration.LoadOrderConfiguration;
+import io.papermc.paper.plugin.provider.entrypoint.DependencyContext;
+import io.papermc.paper.plugin.provider.type.PluginTypeFactory;
+import org.bukkit.Bukkit;
+import org.bukkit.Server;
+import org.bukkit.plugin.InvalidPluginException;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.plugin.UnknownDependencyException;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.bukkit.plugin.java.LibraryLoader;
+import org.bukkit.plugin.java.PluginClassLoader;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.File;
+import java.nio.file.Path;
+import java.util.*;
+import java.util.jar.JarFile;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+public class SpigotPluginProvider implements PluginProvider<JavaPlugin>, ProviderStatusHolder, DependencyContextHolder {
+
+    public static final PluginTypeFactory<SpigotPluginProvider, PluginDescriptionFile> FACTORY = new SpigotPluginProviderFactory();
+    private static final LibraryLoader LIBRARY_LOADER = new LibraryLoader(Logger.getLogger("SpigotLibraryLoader"));
+    private final Path path;
+    private final PluginDescriptionFile description;
+    private final JarFile jarFile;
+    private final Logger logger;
+    private final List<Path> paperLibraryPaths;
+    private ProviderStatus status;
+    private DependencyContext dependencyContext;
+
+    SpigotPluginProvider(Path path, JarFile file, PluginDescriptionFile description, List<Path> paperLibraryPaths) {
+        this.path = path;
+        this.jarFile = file;
+        this.description = description;
+        this.logger = PaperPluginLogger.getLogger(description);
+        this.paperLibraryPaths = paperLibraryPaths;
+    }
+
+    @Override
+    public @NotNull Path getSource() {
+        return this.path;
+    }
+
+    @Override
+    public JarFile file() {
+        return this.jarFile;
+    }
+
+    @Override
+    public JavaPlugin createInstance() {
+        Server server = Bukkit.getServer();
+        try {
+
+            final File parentFile = server.getPluginsFolder(); // Paper
+            final File dataFolder = new File(parentFile, this.description.getName());
+            @SuppressWarnings("deprecation") final File oldDataFolder = new File(parentFile, this.description.getRawName());
+
+            // Found old data folder
+            if (dataFolder.equals(oldDataFolder)) {
+                // They are equal -- nothing needs to be done!
+            } else if (dataFolder.isDirectory() && oldDataFolder.isDirectory()) {
+                server.getLogger().warning(String.format(
+                    "While loading %s (%s) found old-data folder: `%s' next to the new one `%s'",
+                    this.description.getFullName(),
+                    this.path,
+                    oldDataFolder,
+                    dataFolder
+                ));
+            } else if (oldDataFolder.isDirectory() && !dataFolder.exists()) {
+                if (!oldDataFolder.renameTo(dataFolder)) {
+                    throw new InvalidPluginException("Unable to rename old data folder: `" + oldDataFolder + "' to: `" + dataFolder + "'");
+                }
+                server.getLogger().log(Level.INFO, String.format(
+                    "While loading %s (%s) renamed data folder: `%s' to `%s'",
+                    this.description.getFullName(),
+                    this.path,
+                    oldDataFolder,
+                    dataFolder
+                ));
+            }
+
+            if (dataFolder.exists() && !dataFolder.isDirectory()) {
+                throw new InvalidPluginException(String.format(
+                    "Projected datafolder: `%s' for %s (%s) exists and is not a directory",
+                    dataFolder,
+                    this.description.getFullName(),
+                    this.path
+                ));
+            }
+
+            Set<String> missingHardDependencies = new HashSet<>(this.description.getDepend().size()); // Paper - list all missing hard depends
+            for (final String pluginName : this.description.getDepend()) {
+                if (!this.dependencyContext.hasDependency(pluginName)) {
+                    missingHardDependencies.add(pluginName); // Paper - list all missing hard depends
+                }
+            }
+            // Paper start - list all missing hard depends
+            if (!missingHardDependencies.isEmpty()) {
+                throw new UnknownDependencyException(missingHardDependencies, this.description.getFullName());
+            }
+            // Paper end
+
+            server.getUnsafe().checkSupported(this.description);
+
+            final PluginClassLoader loader;
+            try {
+                loader = new PluginClassLoader(this.getClass().getClassLoader(), this.description, dataFolder, this.path.toFile(), LIBRARY_LOADER.createLoader(this.description, this.paperLibraryPaths), this.jarFile, this.dependencyContext); // Paper
+            } catch (InvalidPluginException ex) {
+                throw ex;
+            } catch (Throwable ex) {
+                throw new InvalidPluginException(ex);
+            }
+
+            // Override dependency context.
+            // We must provide a temporary context in order to properly handle dependencies on the plugin classloader constructor.
+            loader.dependencyContext = PaperPluginManagerImpl.getInstance();
+
+
+            this.status = ProviderStatus.INITIALIZED;
+            return loader.getPlugin();
+        } catch (Throwable ex) {
+            this.status = ProviderStatus.ERRORED;
+            SneakyThrow.sneaky(ex);
+        }
+
+        throw new AssertionError(); // Shouldn't happen
+    }
+
+    @Override
+    public PluginDescriptionFile getMeta() {
+        return this.description;
+    }
+
+    @Override
+    public LoadOrderConfiguration createConfiguration(@NotNull Map<String, PluginProvider<?>> toLoad) {
+        return new SpigotLoadOrderConfiguration(this, toLoad);
+    }
+
+    @Override
+    public List<String> validateDependencies(@NotNull DependencyContext context) {
+        List<String> missingDependencies = new ArrayList<>();
+        for (String hardDependency : this.getMeta().getPluginDependencies()) {
+            if (!context.hasDependency(hardDependency)) {
+                missingDependencies.add(hardDependency);
+            }
+        }
+
+        return missingDependencies;
+    }
+
+    @Override
+    public ProviderStatus getLastProvidedStatus() {
+        return this.status;
+    }
+
+    @Override
+    public void setStatus(ProviderStatus status) {
+        this.status = status;
+    }
+
+    @Override
+    public void setContext(DependencyContext context) {
+        this.dependencyContext = context;
+    }
+
+    @Override
+    public String toString() {
+        return "SpigotPluginProvider{" +
+            "path=" + path +
+            ", description=" + description +
+            ", jarFile=" + jarFile +
+            ", status=" + status +
+            ", dependencyContext=" + dependencyContext +
+            '}';
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProviderFactory.java b/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProviderFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..7709ec32c89dbc3121fdb3242947772c2dc7b07e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProviderFactory.java
@@ -0,0 +1,71 @@
+package io.papermc.paper.plugin.provider.type.spigot;
+
+import io.papermc.paper.plugin.bootstrap.PluginProviderContextImpl;
+import io.papermc.paper.plugin.entrypoint.classloader.PaperSimplePluginClassLoader;
+import io.papermc.paper.plugin.loader.PaperClasspathBuilder;
+import io.papermc.paper.plugin.loader.PluginLoader;
+import io.papermc.paper.plugin.provider.configuration.serializer.constraints.PluginConfigConstraints;
+import io.papermc.paper.plugin.provider.type.PluginTypeFactory;
+import io.papermc.paper.plugin.provider.util.ProviderUtil;
+import org.bukkit.plugin.InvalidDescriptionException;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.yaml.snakeyaml.error.YAMLException;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Path;
+import java.util.List;
+import java.util.Locale;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+
+class SpigotPluginProviderFactory implements PluginTypeFactory<SpigotPluginProvider, PluginDescriptionFile> {
+
+    @Override
+    public SpigotPluginProvider build(JarFile file, PluginDescriptionFile configuration, Path source) throws InvalidDescriptionException {
+        // Copied from SimplePluginManager#loadPlugins
+        // Spigot doesn't validate the name when the config is created, and instead when the plugin is loaded.
+        // Paper plugin configuration will do these checks in config serializer instead of when this is created.
+        String name = configuration.getRawName();
+        if (PluginConfigConstraints.RESERVED_KEYS.contains(name.toLowerCase(Locale.ROOT))) {
+            throw new InvalidDescriptionException("Restricted name, cannot use %s as a plugin name.".formatted(name));
+        } else if (name.indexOf(' ') != -1) {
+            throw new InvalidDescriptionException("Restricted name, cannot use 0x20 (space character) in a plugin name.");
+        }
+
+        final List<Path> paperLibraryPaths;
+        if (configuration.getPaperPluginLoader() != null) {
+            PaperClasspathBuilder builder = new PaperClasspathBuilder(PluginProviderContextImpl.create(
+                configuration, source
+            ));
+
+            try (
+                PaperSimplePluginClassLoader simplePluginClassLoader = new PaperSimplePluginClassLoader(source, file, configuration, this.getClass().getClassLoader())
+            ) {
+                PluginLoader loader = ProviderUtil.loadClass(configuration.getPaperPluginLoader(), PluginLoader.class, simplePluginClassLoader);
+                loader.classloader(builder);
+            } catch (IOException e) {
+                throw new RuntimeException(e);
+            }
+
+            paperLibraryPaths = builder.buildLibraryPaths(false);
+        } else {
+            paperLibraryPaths = null;
+        }
+
+        return new SpigotPluginProvider(source, file, configuration, paperLibraryPaths);
+    }
+
+    @Override
+    public PluginDescriptionFile create(JarFile file, JarEntry config) throws InvalidDescriptionException {
+        PluginDescriptionFile descriptionFile;
+        try (InputStream inputStream = file.getInputStream(config)) {
+            descriptionFile = new PluginDescriptionFile(inputStream);
+        } catch (IOException | YAMLException ex) {
+            throw new InvalidDescriptionException(ex);
+        }
+
+        return descriptionFile;
+    }
+}
+
diff --git a/src/main/java/io/papermc/paper/plugin/storage/BootstrapProviderStorage.java b/src/main/java/io/papermc/paper/plugin/storage/BootstrapProviderStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..be19fe6d29d6b6b98a200e9e871bac43b4753f03
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/storage/BootstrapProviderStorage.java
@@ -0,0 +1,62 @@
+package io.papermc.paper.plugin.storage;
+
+import io.papermc.paper.plugin.PluginInitializerManager;
+import io.papermc.paper.plugin.bootstrap.PluginBootstrap;
+import io.papermc.paper.plugin.bootstrap.PluginBootstrapContextImpl;
+import io.papermc.paper.plugin.entrypoint.dependency.BootstrapMetaDependencyTree;
+import io.papermc.paper.plugin.entrypoint.dependency.DependencyContextHolder;
+import io.papermc.paper.plugin.entrypoint.dependency.MetaDependencyTree;
+import io.papermc.paper.plugin.entrypoint.strategy.ProviderConfiguration;
+import io.papermc.paper.plugin.entrypoint.strategy.modern.ModernPluginLoadingStrategy;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.ProviderStatus;
+import io.papermc.paper.plugin.provider.ProviderStatusHolder;
+import io.papermc.paper.plugin.provider.entrypoint.DependencyContext;
+import net.minecraft.server.MinecraftServer;
+
+public class BootstrapProviderStorage extends SimpleProviderStorage<PluginBootstrap> {
+
+    public BootstrapProviderStorage() {
+        super(new ModernPluginLoadingStrategy<>(new ProviderConfiguration<>() {
+            @Override
+            public void applyContext(PluginProvider<PluginBootstrap> provider, DependencyContext dependencyContext) {
+                if (provider instanceof DependencyContextHolder contextHolder) {
+                    contextHolder.setContext(dependencyContext);
+                }
+            }
+
+            @Override
+            public boolean load(PluginProvider<PluginBootstrap> provider, PluginBootstrap provided) {
+                try {
+                    PluginBootstrapContextImpl context = PluginBootstrapContextImpl.create(provider, PluginInitializerManager.instance().pluginDirectoryPath()); // Paper - lifecycle events
+                    provided.bootstrap(context);
+                    context.lockLifecycleEventRegistration(); // Paper - lifecycle events
+                    return true;
+                } catch (Throwable e) {
+                    MinecraftServer.LOGGER.error("Failed to run bootstrapper for %s. This plugin will not be loaded.".formatted(provider.getSource()), e);
+                    if (provider instanceof ProviderStatusHolder statusHolder) {
+                        statusHolder.setStatus(ProviderStatus.ERRORED);
+                    }
+                    return false;
+                }
+            }
+
+            @Override
+            public void onGenericError(PluginProvider<PluginBootstrap> provider) {
+                if (provider instanceof ProviderStatusHolder statusHolder) {
+                    statusHolder.setStatus(ProviderStatus.ERRORED);
+                }
+            }
+        }));
+    }
+
+    @Override
+    public MetaDependencyTree createDependencyTree() {
+        return new BootstrapMetaDependencyTree();
+    }
+
+    @Override
+    public String toString() {
+        return "BOOTSTRAP:" + super.toString();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/storage/ConfiguredProviderStorage.java b/src/main/java/io/papermc/paper/plugin/storage/ConfiguredProviderStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..75a0dac2ac233d64eec23695f05bb1d6867fb84d
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/storage/ConfiguredProviderStorage.java
@@ -0,0 +1,17 @@
+package io.papermc.paper.plugin.storage;
+
+import io.papermc.paper.plugin.entrypoint.strategy.LegacyPluginLoadingStrategy;
+import io.papermc.paper.plugin.entrypoint.strategy.ProviderConfiguration;
+import io.papermc.paper.plugin.entrypoint.strategy.modern.ModernPluginLoadingStrategy;
+
+public abstract class ConfiguredProviderStorage<T> extends SimpleProviderStorage<T> {
+
+    public static final boolean LEGACY_PLUGIN_LOADING = Boolean.getBoolean("paper.useLegacyPluginLoading");
+
+    protected ConfiguredProviderStorage(ProviderConfiguration<T> onLoad) {
+        // This doesn't work with reloading.
+        // Should we care?
+        super(LEGACY_PLUGIN_LOADING ? new LegacyPluginLoadingStrategy<>(onLoad) : new ModernPluginLoadingStrategy<>(onLoad));
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/storage/ProviderStorage.java b/src/main/java/io/papermc/paper/plugin/storage/ProviderStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..39cd3acd3f76b3b0d065e0efb04a3eacea1c2e6b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/storage/ProviderStorage.java
@@ -0,0 +1,21 @@
+package io.papermc.paper.plugin.storage;
+
+import io.papermc.paper.plugin.entrypoint.dependency.MetaDependencyTree;
+import io.papermc.paper.plugin.provider.PluginProvider;
+
+/**
+ * A provider storage is meant to be a singleton that stores providers.
+ *
+ * @param <T> provider type
+ */
+public interface ProviderStorage<T> {
+
+    void register(PluginProvider<T> provider);
+
+    MetaDependencyTree createDependencyTree();
+
+    void enter();
+
+    Iterable<PluginProvider<T>> getRegisteredProviders();
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/storage/ServerPluginProviderStorage.java b/src/main/java/io/papermc/paper/plugin/storage/ServerPluginProviderStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..3e7b4035c0e5b9a154ffd1e029fdfd2a0f61c452
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/storage/ServerPluginProviderStorage.java
@@ -0,0 +1,64 @@
+package io.papermc.paper.plugin.storage;
+
+import io.papermc.paper.plugin.entrypoint.dependency.DependencyContextHolder;
+import io.papermc.paper.plugin.entrypoint.strategy.ProviderConfiguration;
+import io.papermc.paper.plugin.manager.PaperPluginManagerImpl;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.entrypoint.DependencyContext;
+import io.papermc.paper.plugin.provider.type.paper.PaperPluginParent;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.java.JavaPlugin;
+
+import java.util.List;
+
+public class ServerPluginProviderStorage extends ConfiguredProviderStorage<JavaPlugin> {
+
+    public ServerPluginProviderStorage() {
+        super(new ProviderConfiguration<>() {
+            @Override
+            public void applyContext(PluginProvider<JavaPlugin> provider, DependencyContext dependencyContext) {
+                Plugin alreadyLoadedPlugin = PaperPluginManagerImpl.getInstance().getPlugin(provider.getMeta().getName());
+                if (alreadyLoadedPlugin != null) {
+                    throw new IllegalStateException("Provider " + provider + " attempted to add duplicate plugin identifier " + alreadyLoadedPlugin + " THIS WILL CREATE BUGS!!!");
+                }
+
+                if (provider instanceof DependencyContextHolder contextHolder) {
+                    contextHolder.setContext(dependencyContext);
+                }
+            }
+
+            @Override
+            public boolean load(PluginProvider<JavaPlugin> provider, JavaPlugin provided) {
+                // Add it to the map here, we have to run the actual loading logic later.
+                PaperPluginManagerImpl.getInstance().loadPlugin(provided);
+                return true;
+            }
+        });
+    }
+
+    @Override
+    protected void filterLoadingProviders(List<PluginProvider<JavaPlugin>> pluginProviders) {
+         /*
+        Have to do this to prevent loading plugin providers that have failed initializers.
+        This is a hack and a better solution here would be to store failed plugin providers elsewhere.
+         */
+        pluginProviders.removeIf((provider) -> (provider instanceof PaperPluginParent.PaperServerPluginProvider pluginProvider && pluginProvider.shouldSkipCreation()));
+    }
+
+    // We need to call the load methods AFTER all plugins are constructed
+    @Override
+    public void processProvided(PluginProvider<JavaPlugin> provider, JavaPlugin provided) {
+        try {
+            provided.getLogger().info(String.format("Loading server plugin %s", provided.getPluginMeta().getDisplayName()));
+            provided.onLoad();
+        } catch (Throwable ex) {
+            // Don't mark that provider as ERRORED, as this apparently still needs to run the onEnable logic.
+            provided.getSLF4JLogger().error("Error initializing plugin '%s' in folder '%s' (Is it up to date?)".formatted(provider.getFileName(), provider.getParentSource()), ex);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "PLUGIN:" + super.toString();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/storage/SimpleProviderStorage.java b/src/main/java/io/papermc/paper/plugin/storage/SimpleProviderStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..9a0c7529f8e23f080dba904476e83a8b4172e5f2
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/storage/SimpleProviderStorage.java
@@ -0,0 +1,90 @@
+package io.papermc.paper.plugin.storage;
+
+import com.google.common.graph.GraphBuilder;
+import io.papermc.paper.plugin.entrypoint.dependency.MetaDependencyTree;
+import io.papermc.paper.plugin.entrypoint.dependency.SimpleMetaDependencyTree;
+import io.papermc.paper.plugin.entrypoint.strategy.PluginGraphCycleException;
+import io.papermc.paper.plugin.entrypoint.strategy.ProviderLoadingStrategy;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import net.minecraft.server.MinecraftServer;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.Collectors;
+
+public abstract class SimpleProviderStorage<T> implements ProviderStorage<T> {
+
+    protected final List<PluginProvider<T>> providers = new ArrayList<>();
+    protected ProviderLoadingStrategy<T> strategy;
+
+    protected SimpleProviderStorage(ProviderLoadingStrategy<T> strategy) {
+        this.strategy = strategy;
+    }
+
+    @Override
+    public void register(PluginProvider<T> provider) {
+        this.providers.add(provider);
+    }
+
+    @Override
+    public void enter() {
+        List<PluginProvider<T>> providerList = new ArrayList<>(this.providers);
+        this.filterLoadingProviders(providerList);
+
+        try {
+            for (ProviderLoadingStrategy.ProviderPair<T> providerPair : this.strategy.loadProviders(providerList, this.createDependencyTree())) {
+                this.processProvided(providerPair.provider(), providerPair.provided());
+            }
+        } catch (PluginGraphCycleException exception) {
+            this.handleCycle(exception);
+        }
+    }
+
+    @Override
+    public MetaDependencyTree createDependencyTree() {
+        return new SimpleMetaDependencyTree(GraphBuilder.directed().build());
+    }
+
+    @Override
+    public Iterable<PluginProvider<T>> getRegisteredProviders() {
+        return this.providers;
+    }
+
+    public void processProvided(PluginProvider<T> provider, T provided) {
+    }
+
+    // Mutable enter
+    protected void filterLoadingProviders(List<PluginProvider<T>> providers) {
+    }
+
+    protected void handleCycle(PluginGraphCycleException exception) {
+        List<String> logMessages = new ArrayList<>();
+        for (List<String> list : exception.getCycles()) {
+            logMessages.add(String.join(" -> ", list) + " -> " + list.get(0));
+        }
+
+        MinecraftServer.LOGGER.error("Circular plugin loading detected!");
+        MinecraftServer.LOGGER.error("Circular load order:");
+        for (String logMessage : logMessages) {
+            MinecraftServer.LOGGER.error("  {}", logMessage);
+        }
+        MinecraftServer.LOGGER.error("Please report this to the plugin authors of the first plugin of each loop or join the PaperMC Discord server for further help.");
+        MinecraftServer.LOGGER.error("If you would like to still load these plugins, acknowledging that there may be unexpected plugin loading issues, run the server with -Dpaper.useLegacyPluginLoading=true");
+
+        if (this.throwOnCycle()) {
+            throw new IllegalStateException("Circular plugin loading from plugins " + exception.getCycles().stream().map(cycle -> cycle.get(0)).collect(Collectors.joining(", ")));
+        }
+    }
+
+    public boolean throwOnCycle() {
+        return true;
+    }
+
+    @Override
+    public String toString() {
+        return "SimpleProviderStorage{" +
+            "providers=" + this.providers +
+            ", strategy=" + this.strategy +
+            '}';
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/storage/package-info.java b/src/main/java/io/papermc/paper/plugin/storage/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..c1114675137e862ac9682b635bfdbfbc1d7c6e67
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/storage/package-info.java
@@ -0,0 +1,5 @@
+/**
+ * Classes in this package are supposed to connect components of {@link io.papermc.paper.plugin.entrypoint} and {@link io.papermc.paper.plugin.provider} packages.
+ * @see io.papermc.paper.plugin.entrypoint.Entrypoint
+ */
+package io.papermc.paper.plugin.storage;
diff --git a/src/main/java/io/papermc/paper/plugin/util/EntrypointUtil.java b/src/main/java/io/papermc/paper/plugin/util/EntrypointUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..b475d03c992dfe98d0ef84e5bb39dd8f508e06c4
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/util/EntrypointUtil.java
@@ -0,0 +1,17 @@
+package io.papermc.paper.plugin.util;
+
+import io.papermc.paper.plugin.entrypoint.LaunchEntryPointHandler;
+import io.papermc.paper.plugin.provider.source.ProviderSource;
+import net.minecraft.server.MinecraftServer;
+
+public final class EntrypointUtil {
+
+    public static <I, C> void registerProvidersFromSource(ProviderSource<I, C> source, I contextInput) {
+        try {
+            C context = source.prepareContext(contextInput);
+            source.registerProviders(LaunchEntryPointHandler.INSTANCE, context);
+        } catch (Throwable e) {
+            MinecraftServer.LOGGER.error(e.getMessage(), e);
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/util/NamespaceChecker.java b/src/main/java/io/papermc/paper/plugin/util/NamespaceChecker.java
new file mode 100644
index 0000000000000000000000000000000000000000..fd55fd1d6518ebd1bc2513dd331f072018fd4782
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/util/NamespaceChecker.java
@@ -0,0 +1,37 @@
+package io.papermc.paper.plugin.util;
+
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+@ApiStatus.Internal
+public class NamespaceChecker {
+
+    private static final String[] QUICK_INVALID_NAMESPACES = {
+        "net.minecraft.",
+        "org.bukkit.",
+        "io.papermc.paper.",
+        "com.destroystokoyo.paper."
+    };
+
+    /**
+     * Used for a variety of namespaces that shouldn't be resolved and should instead be moved to
+     * other classloaders. We can assume this because only plugins should be using this classloader.
+     *
+     * @param name namespace
+     */
+    public static void validateNameSpaceForClassloading(@NotNull String name) throws ClassNotFoundException {
+        if (!isValidNameSpace(name)) {
+            throw new ClassNotFoundException(name);
+        }
+    }
+
+    public static boolean isValidNameSpace(@NotNull String name) {
+        for (String string : QUICK_INVALID_NAMESPACES) {
+            if (name.startsWith(string)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index 15b972b4a93b8fe3655acec47bc84b0f2c4620a6..8198aa500da42d848c6ecf54faade8204717a3ba 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -15,6 +15,8 @@ import java.nio.file.Paths;
 import java.util.Optional;
 import java.util.concurrent.CompletableFuture;
 import java.util.function.BooleanSupplier;
+
+import io.papermc.paper.plugin.PluginInitializerManager;
 import io.papermc.paper.world.ThreadedWorldUpgrader;
 import joptsimple.NonOptionArgumentSpec;
 import joptsimple.OptionParser;
@@ -97,6 +99,8 @@ public class Main {
 
         try {
             CrashReport.h();
+
+            PluginInitializerManager.load(optionset); // Paper
             DispenserRegistry.init();
             DispenserRegistry.c();
             SystemUtils.l();
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index b148da0e7383307db6095fb66decc6e33b095af1..7aab16fd5b7cc5ab8815e34d5a01607758108625 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -360,6 +360,12 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
         return this.propertyManager.getProperties().spawnNpcs && super.getSpawnNPCs();
     }
 
+    // Paper start
+    public java.io.File getPluginsFolder() {
+        return (java.io.File) this.options.valueOf("plugins");
+    }
+    // Paper end
+
     public String ba() {
         DedicatedServerProperties dedicatedserverproperties = this.propertyManager.getProperties();
         String s;
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 565327531e1792be4828daf045eed58529626487..4854c0b10a6cf1edc21f8f52b99a3ab39efb213b 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -4,7 +4,6 @@ import com.google.common.base.Charsets;
 import com.google.common.base.Function;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterators;
 import com.google.common.collect.Lists;
 import com.google.common.collect.MapMaker;
@@ -18,36 +17,10 @@ import com.mojang.serialization.Lifecycle;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufOutputStream;
 import io.netty.buffer.Unpooled;
-import io.papermc.paper.datapack.PaperDatapackManager; // Paper
+import io.papermc.paper.datapack.PaperDatapackManager;
 import io.papermc.paper.util.TraceUtil;
 import it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenHashMap;
-import java.awt.image.BufferedImage;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.nio.ByteBuffer;
-import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Base64;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Properties;
-import java.util.Random;
-import java.util.Set;
-import java.util.UUID;
-import java.util.function.Consumer;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import javax.imageio.ImageIO;
+import net.md_5.bungee.api.chat.BaseComponent;
 import net.minecraft.advancements.Advancement;
 import net.minecraft.commands.CommandDispatcher;
 import net.minecraft.commands.CommandListenerWrapper;
@@ -60,7 +33,6 @@ import net.minecraft.nbt.NBTBase;
 import net.minecraft.resources.MinecraftKey;
 import net.minecraft.resources.RegistryReadOps;
 import net.minecraft.resources.ResourceKey;
-//import jline.console.ConsoleReader; // Paper
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.ServerCommand;
 import net.minecraft.server.bossevents.BossBattleCustom;
@@ -106,33 +78,12 @@ import net.minecraft.world.level.storage.WorldNBTStorage;
 import net.minecraft.world.level.storage.loot.LootTableRegistry;
 import net.minecraft.world.phys.Vec3D;
 import org.apache.commons.lang.Validate;
-import org.bukkit.BanList;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.GameMode;
-import org.bukkit.Keyed;
-import org.bukkit.Location;
-import org.bukkit.NamespacedKey;
-import org.bukkit.OfflinePlayer;
-import org.bukkit.Server;
-import org.bukkit.StructureType;
-import org.bukkit.UnsafeValues;
+import org.bukkit.*;
 import org.bukkit.Warning.WarningState;
-import org.bukkit.World;
 import org.bukkit.World.Environment;
-import org.bukkit.WorldCreator;
 import org.bukkit.block.data.BlockData;
-import org.bukkit.boss.BarColor;
-import org.bukkit.boss.BarFlag;
-import org.bukkit.boss.BarStyle;
-import org.bukkit.boss.BossBar;
-import org.bukkit.boss.KeyedBossBar;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandException;
-import org.bukkit.command.CommandSender;
-import org.bukkit.command.ConsoleCommandSender;
-import org.bukkit.command.PluginCommand;
-import org.bukkit.command.SimpleCommandMap;
+import org.bukkit.boss.*;
+import org.bukkit.command.*;
 import org.bukkit.configuration.ConfigurationSection;
 import org.bukkit.configuration.file.YamlConfiguration;
 import org.bukkit.configuration.serialization.ConfigurationSerialization;
@@ -146,19 +97,7 @@ import org.bukkit.craftbukkit.command.VanillaCommandWrapper;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.craftbukkit.generator.CraftChunkData;
 import org.bukkit.craftbukkit.help.SimpleHelpMap;
-import org.bukkit.craftbukkit.inventory.CraftBlastingRecipe;
-import org.bukkit.craftbukkit.inventory.CraftCampfireRecipe;
-import org.bukkit.craftbukkit.inventory.CraftFurnaceRecipe;
-import org.bukkit.craftbukkit.inventory.CraftItemFactory;
-import org.bukkit.craftbukkit.inventory.CraftItemStack;
-import org.bukkit.craftbukkit.inventory.CraftMerchantCustom;
-import org.bukkit.craftbukkit.inventory.CraftRecipe;
-import org.bukkit.craftbukkit.inventory.CraftShapedRecipe;
-import org.bukkit.craftbukkit.inventory.CraftShapelessRecipe;
-import org.bukkit.craftbukkit.inventory.CraftSmithingRecipe;
-import org.bukkit.craftbukkit.inventory.CraftSmokingRecipe;
-import org.bukkit.craftbukkit.inventory.CraftStonecuttingRecipe;
-import org.bukkit.craftbukkit.inventory.RecipeIterator;
+import org.bukkit.craftbukkit.inventory.*;
 import org.bukkit.craftbukkit.inventory.util.CraftInventoryCreator;
 import org.bukkit.craftbukkit.map.CraftMapView;
 import org.bukkit.craftbukkit.metadata.EntityMetadataStore;
@@ -170,12 +109,7 @@ import org.bukkit.craftbukkit.scoreboard.CraftScoreboardManager;
 import org.bukkit.craftbukkit.tag.CraftBlockTag;
 import org.bukkit.craftbukkit.tag.CraftFluidTag;
 import org.bukkit.craftbukkit.tag.CraftItemTag;
-import org.bukkit.craftbukkit.util.CraftChatMessage;
-import org.bukkit.craftbukkit.util.CraftIconCache;
-import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.bukkit.craftbukkit.util.CraftNamespacedKey;
-import org.bukkit.craftbukkit.util.DatFileFilter;
-import org.bukkit.craftbukkit.util.Versioning;
+import org.bukkit.craftbukkit.util.*;
 import org.bukkit.craftbukkit.util.permissions.CraftDefaultPermissions;
 import org.bukkit.entity.Entity;
 import org.bukkit.entity.Player;
@@ -188,31 +122,12 @@ import org.bukkit.event.world.WorldLoadEvent;
 import org.bukkit.event.world.WorldUnloadEvent;
 import org.bukkit.generator.ChunkGenerator;
 import org.bukkit.help.HelpMap;
-import org.bukkit.inventory.BlastingRecipe;
-import org.bukkit.inventory.CampfireRecipe;
-import org.bukkit.inventory.ComplexRecipe;
-import org.bukkit.inventory.FurnaceRecipe;
-import org.bukkit.inventory.Inventory;
-import org.bukkit.inventory.InventoryHolder;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.inventory.Merchant;
-import org.bukkit.inventory.Recipe;
-import org.bukkit.inventory.ShapedRecipe;
-import org.bukkit.inventory.ShapelessRecipe;
-import org.bukkit.inventory.SmithingRecipe;
-import org.bukkit.inventory.SmokingRecipe;
-import org.bukkit.inventory.StonecuttingRecipe;
+import org.bukkit.inventory.*;
 import org.bukkit.loot.LootTable;
 import org.bukkit.map.MapView;
 import org.bukkit.permissions.Permissible;
 import org.bukkit.permissions.Permission;
-import org.bukkit.plugin.Plugin;
-import org.bukkit.plugin.PluginLoadOrder;
-import org.bukkit.plugin.PluginManager;
-import org.bukkit.plugin.ServicesManager;
-import org.bukkit.plugin.SimplePluginManager;
-import org.bukkit.plugin.SimpleServicesManager;
-import org.bukkit.plugin.java.JavaPluginLoader;
+import org.bukkit.plugin.*;
 import org.bukkit.plugin.messaging.Messenger;
 import org.bukkit.plugin.messaging.StandardMessenger;
 import org.bukkit.potion.Potion;
@@ -225,10 +140,17 @@ import org.yaml.snakeyaml.Yaml;
 import org.yaml.snakeyaml.constructor.SafeConstructor;
 import org.yaml.snakeyaml.error.MarkedYAMLException;
 
-import net.md_5.bungee.api.chat.BaseComponent; // Spigot
-
-import javax.annotation.Nullable; // Paper
-import javax.annotation.Nonnull; // Paper
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+import javax.imageio.ImageIO;
+import java.awt.image.BufferedImage;
+import java.io.*;
+import java.nio.ByteBuffer;
+import java.nio.charset.StandardCharsets;
+import java.util.*;
+import java.util.function.Consumer;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 
 public final class CraftServer implements Server {
     private final String serverName = "VSpigot"; // Paper // Tuinity // Purpur
@@ -240,7 +162,8 @@ public final class CraftServer implements Server {
     private final CraftCommandMap commandMap = new CraftCommandMap(this);
     private final SimpleHelpMap helpMap = new SimpleHelpMap(this);
     private final StandardMessenger messenger = new StandardMessenger();
-    private final SimplePluginManager pluginManager = new SimplePluginManager(this, commandMap);
+    private final SimplePluginManager pluginManager; // Paper - Move down
+    public final io.papermc.paper.plugin.manager.PaperPluginManagerImpl paperPluginManager; // Paper
     protected final DedicatedServer console;
     protected final DedicatedPlayerList playerList;
     private final Map<String, World> worlds = new LinkedHashMap<String, World>();
@@ -288,6 +211,10 @@ public final class CraftServer implements Server {
 
         Bukkit.setServer(this);
 
+        this.pluginManager = new SimplePluginManager(this, commandMap);
+        this.paperPluginManager = new io.papermc.paper.plugin.manager.PaperPluginManagerImpl(this, this.commandMap, pluginManager);
+        this.pluginManager.paperPluginManager = this.paperPluginManager;
+
         // Register all the Enchantments and PotionTypes now so we can stop new registration immediately after
         Enchantments.DAMAGE_ALL.getClass();
         org.bukkit.enchantments.Enchantment.stopAcceptingRegistrations();
@@ -382,29 +309,7 @@ public final class CraftServer implements Server {
     }
 
     public void loadPlugins() {
-        pluginManager.registerInterface(JavaPluginLoader.class);
-
-        File pluginFolder = (File) console.options.valueOf("plugins");
-
-        // Paper start
-        if (true || pluginFolder.exists()) {
-            if (!pluginFolder.exists()) {
-                pluginFolder.mkdirs();
-            }
-            Plugin[] plugins = pluginManager.loadPlugins(pluginFolder, this.extraPluginJars());
-            // Paper end
-            for (Plugin plugin : plugins) {
-                try {
-                    String message = String.format("Loading %s", plugin.getDescription().getFullName());
-                    plugin.getLogger().info(message);
-                    plugin.onLoad();
-                } catch (Throwable ex) {
-                    Logger.getLogger(CraftServer.class.getName()).log(Level.SEVERE, ex.getMessage() + " initializing " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
-                }
-            }
-        } else {
-            pluginFolder.mkdir();
-        }
+        io.papermc.paper.plugin.entrypoint.LaunchEntryPointHandler.INSTANCE.enter(io.papermc.paper.plugin.entrypoint.Entrypoint.PLUGIN); // Paper - replace implementation
     }
 
     // Paper start
@@ -966,9 +871,11 @@ public final class CraftServer implements Server {
             ));
             if (console.isDebugging()) TraceUtil.dumpTraceForThread(worker.getThread(), "still running"); // Paper
         }
+        io.papermc.paper.plugin.PluginInitializerManager.reload(this.console); // Paper
         loadPlugins();
         enablePlugins(PluginLoadOrder.STARTUP);
         enablePlugins(PluginLoadOrder.POSTWORLD);
+        // Paper start - brigadier command API
         getPluginManager().callEvent(new ServerLoadEvent(ServerLoadEvent.LoadType.RELOAD));
         org.spigotmc.WatchdogThread.hasStarted = true; // Paper - Disable watchdog early timeout on reload
     }
@@ -1066,6 +973,10 @@ public final class CraftServer implements Server {
         }
     }
 
+    @Override
+    public File getPluginsFolder() {
+        return this.console.getPluginsFolder();
+    }
     @Override
     public String toString() {
         return "CraftServer{" + "serverName=" + serverName + ",serverVersion=" + serverVersion + ",minecraftVersion=" + console.getVersion() + '}';
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java b/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java
index 49dc0c441b9dd7e7745cf15ced67f383ebee1f99..9c9cda5f24fe8fcc9f67807e29c92f92bd8bcb09 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java
@@ -10,6 +10,7 @@ import org.bukkit.plugin.PluginBase;
 import org.bukkit.plugin.PluginDescriptionFile;
 import org.bukkit.plugin.PluginLoader;
 import org.bukkit.plugin.PluginLogger;
+import org.jetbrains.annotations.NotNull;
 
 import java.io.File;
 import java.io.InputStream;
@@ -45,6 +46,13 @@ public class MinecraftInternalPlugin extends PluginBase {
         throw new UnsupportedOperationException("Not supported.");
     }
 
+    // Paper start
+    @Override
+    public io.papermc.paper.plugin.configuration.PluginMeta getPluginMeta() {
+        return pdf;
+    }
+    // Paper end
+
     @Override
     public InputStream getResource(String filename) {
         throw new UnsupportedOperationException("Not supported.");
@@ -129,4 +137,11 @@ public class MinecraftInternalPlugin extends PluginBase {
     public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {
         throw new UnsupportedOperationException("Not supported.");
     }
+
+    // Paper start - lifecycle events
+    @Override
+    public @NotNull io.papermc.paper.plugin.lifecycle.event.LifecycleEventManager<org.bukkit.plugin.Plugin> getLifecycleManager() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+    // Paper end - lifecycle events
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/util/ApiVersion.java b/src/main/java/org/bukkit/craftbukkit/util/ApiVersion.java
new file mode 100644
index 0000000000000000000000000000000000000000..50df9a5363af7553a5cceb62ccc197b9b560be26
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/util/ApiVersion.java
@@ -0,0 +1,126 @@
+package org.bukkit.craftbukkit.util;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public final class ApiVersion implements Comparable<ApiVersion> {
+
+    public static final ApiVersion CURRENT;
+    public static final ApiVersion FLATTENING;
+    public static final ApiVersion FIELD_NAME_PARITY;
+    public static final ApiVersion NONE;
+
+    private static final Map<String, ApiVersion> versions;
+
+    static {
+        versions = new HashMap<>();
+        CURRENT = getOrCreateVersion("1.20.6");
+        FLATTENING = getOrCreateVersion("1.13");
+        FIELD_NAME_PARITY = getOrCreateVersion("1.20.5");
+        NONE = getOrCreateVersion("none");
+    }
+
+    private final boolean none;
+    private final int major;
+    private final int minor;
+    private final int patch;
+
+    private ApiVersion() {
+        this.none = true;
+        this.major = Integer.MIN_VALUE;
+        this.minor = Integer.MIN_VALUE;
+        this.patch = Integer.MIN_VALUE;
+    }
+
+    private ApiVersion(int major, int minor, int patch) {
+        this.none = false;
+        this.major = major;
+        this.minor = minor;
+        this.patch = patch;
+    }
+
+    public static ApiVersion getOrCreateVersion(String versionString) {
+        if (versionString == null || versionString.trim().isEmpty() || versionString.equalsIgnoreCase("none")) {
+            return ApiVersion.versions.computeIfAbsent("none", s -> new ApiVersion());
+        }
+
+        ApiVersion version = ApiVersion.versions.get(versionString);
+
+        if (version != null) {
+            return version;
+        }
+
+        String[] versionParts = versionString.split("\\.");
+
+        if (versionParts.length != 2 && versionParts.length != 3) {
+            throw new IllegalArgumentException(String.format("API version string should be of format \"major.minor.patch\" or \"major.minor\", where \"major\", \"minor\" and \"patch\" are numbers. For example \"1.18.2\" or \"1.13\", but got '%s' instead.", versionString));
+        }
+
+        int major = ApiVersion.parseNumber(versionParts[0]);
+        int minor = ApiVersion.parseNumber(versionParts[1]);
+
+        int patch;
+        if (versionParts.length == 3) {
+            patch = ApiVersion.parseNumber(versionParts[2]);
+        } else {
+            patch = 0;
+        }
+
+        versionString = ApiVersion.toVersionString(major, minor, patch);
+        return ApiVersion.versions.computeIfAbsent(versionString, s -> new ApiVersion(major, minor, patch));
+    }
+
+    private static int parseNumber(String number) {
+        return Integer.parseInt(number);
+    }
+
+    private static String toVersionString(int major, int minor, int patch) {
+        return major + "." + minor + "." + patch;
+    }
+
+    @Override
+    public int compareTo(@NotNull ApiVersion other) {
+        int result = Integer.compare(this.major, other.major);
+
+        if (result == 0) {
+            result = Integer.compare(this.minor, other.minor);
+        }
+
+        if (result == 0) {
+            result = Integer.compare(this.patch, other.patch);
+        }
+
+        return result;
+    }
+
+    public String getVersionString() {
+        if (this.none) {
+            return "none";
+        }
+
+        return ApiVersion.toVersionString(this.major, this.minor, this.patch);
+    }
+
+    public boolean isNewerThan(ApiVersion apiVersion) {
+        return this.compareTo(apiVersion) > 0;
+    }
+
+    public boolean isOlderThan(ApiVersion apiVersion) {
+        return this.compareTo(apiVersion) < 0;
+    }
+
+    public boolean isNewerThanOrSameAs(ApiVersion apiVersion) {
+        return this.compareTo(apiVersion) >= 0;
+    }
+
+    public boolean isOlderThanOrSameAs(ApiVersion apiVersion) {
+        return this.compareTo(apiVersion) <= 0;
+    }
+
+    @Override
+    public String toString() {
+        return this.getVersionString();
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
index f34761396dee9b57a1a3ec8e5a51787ceccbbabf..91d50163510e3bc39bcc1ee922aef858eb99110b 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
@@ -540,6 +540,13 @@ public final class CraftMagicNumbers implements UnsafeValues {
         return attributeMapBuilder.build();
     }
 
+    // Paper start - lifecycle event API
+    @Override
+    public io.papermc.paper.plugin.lifecycle.event.LifecycleEventManager<org.bukkit.plugin.Plugin> createPluginLifecycleEventManager(final org.bukkit.plugin.java.JavaPlugin plugin, final java.util.function.BooleanSupplier registrationCheck) {
+        return new io.papermc.paper.plugin.lifecycle.event.PaperLifecycleEventManager<>(plugin, registrationCheck);
+    }
+    // Paper end - lifecycle event API
+
     @Override
     public int getProtocolVersion() {
         return net.minecraft.SharedConstants.getGameVersion().getProtocolVersion();
diff --git a/src/main/resources/META-INF/services/io.papermc.paper.plugin.lifecycle.event.types.LifecycleEventTypeProvider b/src/main/resources/META-INF/services/io.papermc.paper.plugin.lifecycle.event.types.LifecycleEventTypeProvider
new file mode 100644
index 0000000000000000000000000000000000000000..808b1192b60348ad05f0bfbdeda6f94df4876743
--- /dev/null
+++ b/src/main/resources/META-INF/services/io.papermc.paper.plugin.lifecycle.event.types.LifecycleEventTypeProvider
@@ -0,0 +1 @@
+io.papermc.paper.plugin.lifecycle.event.types.LifecycleEventTypeProviderImpl
diff --git a/src/main/resources/META-INF/services/io.papermc.paper.plugin.provider.classloader.PaperClassLoaderStorage b/src/main/resources/META-INF/services/io.papermc.paper.plugin.provider.classloader.PaperClassLoaderStorage
new file mode 100644
index 0000000000000000000000000000000000000000..a22647244037cd92262b3b5a6582f0a11172fdc8
--- /dev/null
+++ b/src/main/resources/META-INF/services/io.papermc.paper.plugin.provider.classloader.PaperClassLoaderStorage
@@ -0,0 +1 @@
+io.papermc.paper.plugin.entrypoint.classloader.group.PaperPluginClassLoaderStorage
diff --git a/src/main/resources/META-INF/services/org.bukkit.plugin.PluginLoader b/src/main/resources/META-INF/services/org.bukkit.plugin.PluginLoader
new file mode 100644
index 0000000000000000000000000000000000000000..4f78bc62d03460463b9694de933e5b73da8df6e3
--- /dev/null
+++ b/src/main/resources/META-INF/services/org.bukkit.plugin.PluginLoader
@@ -0,0 +1 @@
+io.papermc.paper.plugin.manager.DummyBukkitPluginLoader
diff --git a/src/test/java/com/destroystokyo/paper/entity/ai/VanillaMobGoalTest.java b/src/test/java/com/destroystokyo/paper/entity/ai/VanillaMobGoalTest.java
index c0525216a8469613c3e0d4b5774a82f69e70fb16..b5b75c110f6052b024e1c8eb078598c7982a1c57 100644
--- a/src/test/java/com/destroystokyo/paper/entity/ai/VanillaMobGoalTest.java
+++ b/src/test/java/com/destroystokyo/paper/entity/ai/VanillaMobGoalTest.java
@@ -88,7 +88,7 @@ public class VanillaMobGoalTest {
         try (ScanResult scanResult = new ClassGraph().enableAllInfo().whitelistPackages("net.minecraft.world.entity").scan()) {
             classes = scanResult.getSubclasses("net.minecraft.world.entity.EntityInsentient").loadClasses();
         }
-        Assert.assertNotEquals("There are supposed to be more than 0 entity types!", Collections.emptyList(), classes);
+        Assert.assertNotSame("There are supposed to be more than 0 entity types!", Collections.emptyList(), classes);
 
         boolean shouldFail = false;
         for (Class<?> nmsClass : classes) {
diff --git a/src/test/java/io/papermc/paper/util/ItemStackRepairCheckTest.java b/src/test/java/io/papermc/paper/util/ItemStackRepairCheckTest.java
deleted file mode 100644
index 8d9c9b3bd53d407391d4fcb7fc773153d1a7b402..0000000000000000000000000000000000000000
--- a/src/test/java/io/papermc/paper/util/ItemStackRepairCheckTest.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package io.papermc.paper.util;
-
-import org.bukkit.Material;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Test;
-
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertThrows;
-import static org.junit.Assert.assertTrue;
-
-public class ItemStackRepairCheckTest extends AbstractTestingBase {
-
-    @Test
-    public void testIsRepariableBy() {
-        ItemStack diamondPick = new ItemStack(Material.DIAMOND_PICKAXE);
-
-        assertTrue("diamond pick isn't repairable by a diamond", diamondPick.isRepairableBy(new ItemStack(Material.DIAMOND)));
-    }
-
-    @Test
-    public void testCanRepair() {
-        ItemStack diamond = new ItemStack(Material.DIAMOND);
-
-        assertTrue("diamond can't repair a diamond axe", diamond.canRepair(new ItemStack(Material.DIAMOND_AXE)));
-    }
-
-    @Test
-    public void testIsNotRepairableBy() {
-        ItemStack notDiamondPick = new ItemStack(Material.ACACIA_SAPLING);
-
-        assertFalse("acacia sapling is repairable by a diamond", notDiamondPick.isRepairableBy(new ItemStack(Material.DIAMOND)));
-    }
-
-    @Test
-    public void testCanNotRepair() {
-        ItemStack diamond = new ItemStack(Material.DIAMOND);
-
-        assertFalse("diamond can repair oak button", diamond.canRepair(new ItemStack(Material.OAK_BUTTON)));
-    }
-
-    @Test
-    public void testInvalidItem() {
-        ItemStack badItemStack = new ItemStack(Material.ACACIA_WALL_SIGN);
-
-        assertFalse("acacia wall sign is repairable by diamond", badItemStack.isRepairableBy(new ItemStack(Material.DIAMOND)));
-    }
-}
diff --git a/src/test/java/org/bukkit/ArtTest.java b/src/test/java/org/bukkit/ArtTest.java
deleted file mode 100644
index 4fc985e4d4d7882c56edf3758e17666e29005718..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/ArtTest.java
+++ /dev/null
@@ -1,65 +0,0 @@
-package org.bukkit;
-
-import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-import com.google.common.collect.Lists;
-import java.util.Collections;
-import java.util.EnumMap;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import net.minecraft.core.IRegistry;
-import net.minecraft.resources.MinecraftKey;
-import net.minecraft.world.entity.decoration.Paintings;
-import org.bukkit.craftbukkit.CraftArt;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Test;
-
-public class ArtTest extends AbstractTestingBase {
-    private static final int UNIT_MULTIPLIER = 16;
-
-    @Test
-    public void verifyMapping() {
-        List<Art> arts = Lists.newArrayList(Art.values());
-
-        for (MinecraftKey key : IRegistry.MOTIVE.keySet()) {
-            Paintings enumArt = IRegistry.MOTIVE.get(key);
-            String name = key.getKey();
-            int width = enumArt.getWidth() / UNIT_MULTIPLIER;
-            int height = enumArt.getHeight() / UNIT_MULTIPLIER;
-
-            Art subject = CraftArt.NotchToBukkit(enumArt);
-
-            String message = String.format("org.bukkit.Art is missing '%s'", name);
-            assertNotNull(message, subject);
-
-            assertThat(Art.getByName(name), is(subject));
-            assertThat("Art." + subject + "'s width", subject.getBlockWidth(), is(width));
-            assertThat("Art." + subject + "'s height", subject.getBlockHeight(), is(height));
-
-            arts.remove(subject);
-        }
-
-        assertThat("org.bukkit.Art has too many arts", arts, is(Collections.EMPTY_LIST));
-    }
-
-    @Test
-    public void testCraftArtToNotch() {
-        Map<Paintings, Art> cache = new HashMap<>();
-        for (Art art : Art.values()) {
-            Paintings enumArt = CraftArt.BukkitToNotch(art);
-            assertNotNull(art.name(), enumArt);
-            assertThat(art.name(), cache.put(enumArt, art), is(nullValue()));
-        }
-    }
-
-    @Test
-    public void testCraftArtToBukkit() {
-        Map<Art, Paintings> cache = new EnumMap(Art.class);
-        for (Paintings enumArt : IRegistry.MOTIVE) {
-            Art art = CraftArt.NotchToBukkit(enumArt);
-            assertNotNull("Could not CraftArt.NotchToBukkit " + enumArt, art);
-            assertThat("Duplicate artwork " + enumArt, cache.put(art, enumArt), is(nullValue()));
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/BiomeTest.java b/src/test/java/org/bukkit/BiomeTest.java
deleted file mode 100644
index 3f478abc08465c9c7c40f0ff1c5e5722e560cb8a..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/BiomeTest.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package org.bukkit;
-
-import net.minecraft.data.RegistryGeneration;
-import net.minecraft.world.level.biome.BiomeBase;
-import org.bukkit.block.Biome;
-import org.bukkit.craftbukkit.block.CraftBlock;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class BiomeTest extends AbstractTestingBase {
-
-    @Test
-    public void testBukkitToMinecraft() {
-        for (Biome biome : Biome.values()) {
-            if (biome == Biome.CUSTOM) {
-                continue;
-            }
-
-            Assert.assertNotNull("No NMS mapping for " + biome, CraftBlock.biomeToBiomeBase(RegistryGeneration.WORLDGEN_BIOME, biome));
-        }
-    }
-
-    @Test
-    public void testMinecraftToBukkit() {
-        for (BiomeBase biomeBase : RegistryGeneration.WORLDGEN_BIOME) {
-            Biome biome = CraftBlock.biomeBaseToBiome(RegistryGeneration.WORLDGEN_BIOME, biomeBase);
-            Assert.assertTrue("No Bukkit mapping for " + biomeBase, biome != null && biome != Biome.CUSTOM);
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/BlockDataConversionTest.java b/src/test/java/org/bukkit/BlockDataConversionTest.java
deleted file mode 100644
index a53d0530b708ed0310bd197bece80eb973b91cdf..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/BlockDataConversionTest.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package org.bukkit;
-
-import java.util.ArrayList;
-import java.util.List;
-import net.minecraft.core.IRegistry;
-import net.minecraft.world.level.block.Block;
-import net.minecraft.world.level.block.state.IBlockData;
-import org.bukkit.craftbukkit.block.data.CraftBlockData;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Assert;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-
-/**
- * This test class ensures that all Blocks (as registered in IRegistry.BLOCK)
- * can be converted into their CraftBlockData equivalent.
- */
-@RunWith(Parameterized.class)
-public class BlockDataConversionTest extends AbstractTestingBase {
-
-    @Parameterized.Parameters(name = "{index}: {0}")
-    public static List<Object[]> args() {
-        List<Object[]> list = new ArrayList<>();
-        for (Block block : (Iterable<Block>) IRegistry.BLOCK) {
-            list.add(new Object[]{block.getBlockData()});
-        }
-        return list;
-    }
-
-    @Parameterized.Parameter(0) public IBlockData data;
-
-    @Test
-    public void testNotNull() {
-        Assert.assertNotNull(data);
-        Assert.assertNotNull(CraftBlockData.fromData(data));
-    }
-}
diff --git a/src/test/java/org/bukkit/BlockDataTest.java b/src/test/java/org/bukkit/BlockDataTest.java
deleted file mode 100644
index 985bf898de82761d6e523c81873e91ef7b1e3a42..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/BlockDataTest.java
+++ /dev/null
@@ -1,172 +0,0 @@
-package org.bukkit;
-
-import static org.hamcrest.Matchers.*;
-import net.minecraft.core.EnumDirection;
-import net.minecraft.world.level.block.BlockCake;
-import net.minecraft.world.level.block.BlockChest;
-import net.minecraft.world.level.block.Blocks;
-import org.bukkit.block.BlockFace;
-import org.bukkit.block.data.BlockData;
-import org.bukkit.block.data.type.Cake;
-import org.bukkit.block.data.type.Chest;
-import org.bukkit.craftbukkit.block.data.CraftBlockData;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class BlockDataTest extends AbstractTestingBase {
-
-    @Test
-    public void testParsing() {
-        BlockData cakeTest = CraftBlockData.fromData(Blocks.CAKE.getBlockData().set(BlockCake.BITES, 3));
-
-        BlockData materialString = CraftBlockData.newData(Material.CAKE, "[bites=3]");
-        Assert.assertThat(materialString, is(cakeTest));
-
-        BlockData combined = CraftBlockData.newData(null, "cake[bites=3]");
-        Assert.assertThat(combined, is(cakeTest));
-
-        BlockData combinedMinecraft = CraftBlockData.newData(null, "minecraft:cake[bites=3]");
-        Assert.assertThat(combinedMinecraft, is(cakeTest));
-
-        BlockData inverted = CraftBlockData.newData(null, cakeTest.getAsString());
-        Assert.assertThat(inverted, is(cakeTest));
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testBadMaterial() {
-        CraftBlockData.newData(null, "invalid");
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testBadSyntax() {
-        CraftBlockData.newData(null, "minecraft:cake[bites=3");
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testDoubleMaterial() {
-        CraftBlockData.newData(Material.CAKE, "minecraft:cake[bites=3]");
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testMistake() {
-        BlockData cakeTest = CraftBlockData.fromData(Blocks.CAKE.getBlockData().set(BlockCake.BITES, 3));
-
-        CraftBlockData.newData(Material.CAKE, cakeTest.toString());
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testItem() {
-        CraftBlockData.newData(Material.DIAMOND_AXE, null);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testItemParse() {
-        CraftBlockData.newData(null, "minecraft:diamond_axe");
-    }
-
-    @Test
-    public void testClone() {
-        Cake cakeTest = (Cake) CraftBlockData.fromData(Blocks.CAKE.getBlockData().set(BlockCake.BITES, 3));
-        Cake clone = (Cake) cakeTest.clone();
-
-        Assert.assertFalse("Clone did not return new object", cakeTest == clone);
-        Assert.assertThat("Clone is not equal", clone, is(cakeTest));
-
-        clone.setBites(1);
-        Assert.assertThat("Clone is not actually clone", clone, is(not(cakeTest)));
-    }
-
-    @Test
-    public void testMerge() {
-        Chest trueTarget = (Chest) CraftBlockData.newData(null, "minecraft:chest[facing=east,waterlogged=true]");
-        Chest falseTarget = (Chest) CraftBlockData.newData(null, "minecraft:chest[facing=east,waterlogged=false]");
-        Chest waterlogged = (Chest) CraftBlockData.newData(null, "minecraft:chest[waterlogged=true]");
-
-        BlockData candidate;
-
-        Assert.assertFalse("Target and match are not yet equal", trueTarget.equals(waterlogged));
-        candidate = trueTarget.merge(waterlogged);
-        Assert.assertTrue("Target and candidate are now equal", trueTarget.equals(candidate));
-
-        Assert.assertFalse("Target and match are not yet equal", falseTarget.equals(waterlogged));
-        candidate = falseTarget.merge(waterlogged);
-        Assert.assertFalse("Target and candidate are still not equal", falseTarget.equals(candidate));
-    }
-
-    @Test
-    public void testMergeAny() {
-        Chest trueTarget = (Chest) CraftBlockData.newData(null, "minecraft:chest[facing=east,waterlogged=true]");
-        Chest falseTarget = (Chest) CraftBlockData.newData(null, "minecraft:chest[facing=east,waterlogged=false]");
-        Chest any = (Chest) CraftBlockData.newData(null, "minecraft:chest");
-
-        BlockData candidate;
-
-        Assert.assertFalse("Target and match are not yet equal", trueTarget.equals(any));
-        candidate = trueTarget.merge(any);
-        Assert.assertTrue("Target and candidate are now equal", trueTarget.equals(candidate));
-
-        Assert.assertFalse("Target and match are not yet equal", falseTarget.equals(any));
-        candidate = falseTarget.merge(any);
-        Assert.assertTrue("Target and candidate are now equal", falseTarget.equals(candidate));
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testCannotMerge1() {
-        Chest one = (Chest) CraftBlockData.newData(null, "minecraft:chest[facing=east,waterlogged=true]");
-        Chest two = (Chest) CraftBlockData.fromData(Blocks.CHEST.getBlockData());
-
-        one.merge(two);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testCannotMerge2() {
-        Chest one = (Chest) CraftBlockData.newData(null, "minecraft:chest[waterlogged=true]");
-        Chest two = (Chest) CraftBlockData.newData(null, "minecraft:chest[waterlogged=true]");
-
-        one.merge(two);
-
-        two.setFacing(BlockFace.NORTH);
-        one.merge(two);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testCannotMerge3() {
-        Chest one = (Chest) CraftBlockData.newData(null, "minecraft:chest[waterlogged=true]");
-        Chest two = (Chest) CraftBlockData.newData(null, "minecraft:trapped_chest[waterlogged=true]");
-
-        one.merge(two);
-    }
-
-    @Test
-    public void testMatch() {
-        Assert.assertTrue(CraftBlockData.newData(null, "minecraft:chest[facing=east,waterlogged=true]").matches(CraftBlockData.newData(null, "minecraft:chest[waterlogged=true]")));
-        Assert.assertFalse(CraftBlockData.newData(null, "minecraft:chest[facing=east,waterlogged=false]").matches(CraftBlockData.newData(null, "minecraft:chest[waterlogged=true]")));
-        Assert.assertTrue(CraftBlockData.newData(null, "minecraft:chest[facing=east,waterlogged=true]").matches(CraftBlockData.newData(null, "minecraft:chest")));
-        Assert.assertFalse(CraftBlockData.newData(null, "minecraft:trapped_chest[facing=east,waterlogged=false]").matches(CraftBlockData.newData(null, "minecraft:chest[waterlogged=true]")));
-        Assert.assertTrue(CraftBlockData.newData(null, "minecraft:chest[facing=east,waterlogged=true]").matches(CraftBlockData.newData(null, "minecraft:chest[waterlogged=true,facing=east]")));
-
-        Chest one = (Chest) CraftBlockData.fromData(Blocks.CHEST.getBlockData().set(BlockChest.FACING, EnumDirection.EAST));
-        Chest two = (Chest) CraftBlockData.newData(null, "minecraft:chest[waterlogged=false]");
-
-        Assert.assertTrue(one.matches(two));
-        Assert.assertFalse(two.matches(one));
-    }
-
-    @Test
-    public void testGetAsString() {
-        String dataString = "minecraft:chest[facing=east,waterlogged=true]";
-        BlockData data = CraftBlockData.newData(null, dataString);
-
-        Assert.assertThat(data.getAsString(true), is(dataString));
-        Assert.assertThat(data.getAsString(false), is("minecraft:chest[facing=east,type=single,waterlogged=true]"));
-    }
-
-    @Test
-    public void testGetAsString2() {
-        Chest data = (Chest) CraftBlockData.fromData(Blocks.CHEST.getBlockData().set(BlockChest.FACING, EnumDirection.EAST));
-
-        Assert.assertThat(data.getAsString(true), is("minecraft:chest[facing=east,type=single,waterlogged=false]"));
-        Assert.assertThat(data.getAsString(false), is("minecraft:chest[facing=east,type=single,waterlogged=false]"));
-    }
-}
diff --git a/src/test/java/org/bukkit/ChatTest.java b/src/test/java/org/bukkit/ChatTest.java
deleted file mode 100644
index 30e96a0d6a10a3f1130eb25e11ef2591b8d17773..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/ChatTest.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package org.bukkit;
-
-import static org.junit.Assert.*;
-import net.minecraft.EnumChatFormat;
-import net.minecraft.network.chat.IChatBaseComponent;
-import org.bukkit.craftbukkit.util.CraftChatMessage;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class ChatTest {
-
-    @Test
-    public void testColors() {
-        for (ChatColor color : ChatColor.values()) {
-            Assert.assertNotNull(CraftChatMessage.getColor(color));
-            Assert.assertEquals(color, CraftChatMessage.getColor(CraftChatMessage.getColor(color)));
-        }
-
-        for (EnumChatFormat format : EnumChatFormat.values()) {
-            Assert.assertNotNull(CraftChatMessage.getColor(format));
-            Assert.assertEquals(format, CraftChatMessage.getColor(CraftChatMessage.getColor(format)));
-        }
-    }
-
-    @Test
-    public void testURLJsonConversion() {
-        IChatBaseComponent[] components;
-        components = CraftChatMessage.fromString("https://spigotmc.org/test Test Message");
-        assertEquals("{\"extra\":[{\"clickEvent\":{\"action\":\"open_url\",\"value\":\"https://spigotmc.org/test\"},\"text\":\"https://spigotmc.org/test\"},{\"text\":\" Test Message\"}],\"text\":\"\"}",
-                CraftChatMessage.toJSON(components[0]));
-
-        components = CraftChatMessage.fromString("123 " + ChatColor.GOLD + "https://spigotmc.org " + ChatColor.BOLD + "test");
-        assertEquals("{\"extra\":[{\"text\":\"123 \"},{\"bold\":false,\"italic\":false,\"underlined\":false,\"strikethrough\":false,\"obfuscated\":false,\"color\":\"gold\",\"clickEvent\":{\"action\":\"open_url\",\"value\":\"https://spigotmc.org\"},\"text\":\"https://spigotmc.org\"},{\"bold\":false,\"italic\":false,\"underlined\":false,\"strikethrough\":false,\"obfuscated\":false,\"color\":\"gold\",\"text\":\" \"},{\"bold\":true,\"italic\":false,\"underlined\":false,\"strikethrough\":false,\"obfuscated\":false,\"color\":\"gold\",\"text\":\"test\"}],\"text\":\"\"}",
-                CraftChatMessage.toJSON(components[0]));
-
-        components = CraftChatMessage.fromString("multiCase http://SpigotMC.ORg/SpOngeBobMeEMeGoESHeRE");
-        assertEquals("{\"extra\":[{\"text\":\"multiCase \"},{\"clickEvent\":{\"action\":\"open_url\",\"value\":\"http://SpigotMC.ORg/SpOngeBobMeEMeGoESHeRE\"},\"text\":\"http://SpigotMC.ORg/SpOngeBobMeEMeGoESHeRE\"}],\"text\":\"\"}",
-                CraftChatMessage.toJSON(components[0]));
-    }
-}
diff --git a/src/test/java/org/bukkit/DyeColorsTest.java b/src/test/java/org/bukkit/DyeColorsTest.java
deleted file mode 100644
index e650cd93d23bbc1dd12af7443b03ef2e81a092ba..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/DyeColorsTest.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package org.bukkit;
-
-import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-import java.util.ArrayList;
-import java.util.List;
-import net.minecraft.world.item.EnumColor;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameter;
-import org.junit.runners.Parameterized.Parameters;
-
-@RunWith(Parameterized.class)
-public class DyeColorsTest extends AbstractTestingBase {
-
-    @Parameters(name = "{index}: {0}")
-    public static List<Object[]> data() {
-        List<Object[]> list = new ArrayList<Object[]>();
-        for (DyeColor dye : DyeColor.values()) {
-            list.add(new Object[] {dye});
-        }
-        return list;
-    }
-
-    @Parameter public DyeColor dye;
-
-    @Test
-    public void checkColor() {
-        Color color = dye.getColor();
-        float[] nmsColorArray = EnumColor.fromColorIndex(dye.getWoolData()).getColor();
-        Color nmsColor = Color.fromRGB((int) (nmsColorArray[0] * 255), (int) (nmsColorArray[1] * 255), (int) (nmsColorArray[2] * 255));
-        assertThat(color, is(nmsColor));
-    }
-
-    @Test
-    public void checkFireworkColor() {
-        Color color = dye.getFireworkColor();
-        int nmsColor = EnumColor.fromColorIndex(dye.getWoolData()).getFireworksColor();
-        assertThat(color, is(Color.fromRGB(nmsColor)));
-    }
-}
diff --git a/src/test/java/org/bukkit/EnchantmentTest.java b/src/test/java/org/bukkit/EnchantmentTest.java
deleted file mode 100644
index 073559da15760cc14e506fa5a0256ff4f4861f12..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/EnchantmentTest.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package org.bukkit;
-
-import net.minecraft.core.IRegistry;
-import net.minecraft.resources.MinecraftKey;
-import org.bukkit.craftbukkit.util.CraftNamespacedKey;
-import org.bukkit.enchantments.Enchantment;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class EnchantmentTest extends AbstractTestingBase {
-
-    @Test
-    public void verifyMapping() {
-        for (MinecraftKey key : IRegistry.ENCHANTMENT.keySet()) {
-            net.minecraft.world.item.enchantment.Enchantment nms = IRegistry.ENCHANTMENT.get(key);
-
-            Enchantment bukkitById = Enchantment.getByKey(CraftNamespacedKey.fromMinecraft(key));
-
-            Assert.assertFalse("Unknown enchant name for " + key, bukkitById.getName().startsWith("UNKNOWN"));
-
-            Assert.assertNotNull("Unknown target for " + key, bukkitById.getItemTarget());
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/GameRuleTest.java b/src/test/java/org/bukkit/GameRuleTest.java
deleted file mode 100644
index b9ac29bde2610bee90075751fe5ba48f6764e5ff..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/GameRuleTest.java
+++ /dev/null
@@ -1,56 +0,0 @@
-package org.bukkit;
-
-import java.util.Map;
-import net.minecraft.world.level.GameRules;
-import org.bukkit.craftbukkit.CraftWorld;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class GameRuleTest {
-
-    @Test
-    public void testBukkitRules() {
-        GameRule<?>[] rules = GameRule.values();
-
-        for (GameRule<?> rule : rules) {
-            GameRule<?> registeredRule = GameRule.getByName(rule.getName());
-            Assert.assertNotNull("Null GameRule", registeredRule);
-            Assert.assertEquals("Invalid GameRule equality", rule, registeredRule);
-        }
-    }
-
-    @Test
-    public void testMinecraftRules() {
-        Map<String, GameRules.GameRuleKey<?>> minecraftRules = CraftWorld.getGameRulesNMS();
-
-        for (Map.Entry<String, GameRules.GameRuleKey<?>> entry : minecraftRules.entrySet()) {
-            GameRule<?> bukkitRule = GameRule.getByName(entry.getKey());
-
-            Assert.assertNotNull("Missing " + entry.getKey(), bukkitRule);
-            Assert.assertEquals("Invalid GameRule Name", bukkitRule.getName(), entry.getKey());
-        }
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void nullGameRuleName() {
-        GameRule.getByName(null);
-    }
-
-    @Test
-    public void emptyGameRuleName() {
-        Assert.assertNull(GameRule.getByName(""));
-    }
-
-    @Test
-    public void incorrectGameRuleName() {
-        Assert.assertNull(GameRule.getByName("doAnnounceAdvancements"));
-        Assert.assertNull(GameRule.getByName("sendCommandBlockFeedback"));
-    }
-
-    @Test
-    public void invalidCasing() {
-        Assert.assertNull(GameRule.getByName("CommandBlockOutput"));
-        Assert.assertNull(GameRule.getByName("spAwnRadius"));
-        Assert.assertNull(GameRule.getByName("rand0mTickSpeEd"));
-    }
-}
diff --git a/src/test/java/org/bukkit/LootTablesTest.java b/src/test/java/org/bukkit/LootTablesTest.java
deleted file mode 100644
index 9bfbfb1a32e2769ad5d5cbc74b639de24bf4c61c..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/LootTablesTest.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package org.bukkit;
-
-import net.minecraft.resources.MinecraftKey;
-import org.bukkit.craftbukkit.util.CraftNamespacedKey;
-import org.bukkit.loot.LootTable;
-import org.bukkit.loot.LootTables;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class LootTablesTest extends AbstractTestingBase {
-
-    @Test
-    public void testLootTablesEnumExists() {
-        LootTables[] tables = LootTables.values();
-
-        for (LootTables table : tables) {
-            LootTable lootTable = Bukkit.getLootTable(table.getKey());
-
-            Assert.assertNotNull("Unknown LootTable " + table.getKey(), lootTable);
-            Assert.assertEquals(lootTable.getKey(), table.getKey());
-        }
-    }
-
-    @Test
-    public void testNMS() {
-        for (MinecraftKey key : net.minecraft.world.level.storage.loot.LootTables.a()) {
-            NamespacedKey bukkitKey = CraftNamespacedKey.fromMinecraft(key);
-            LootTables lootTable = Registry.LOOT_TABLES.get(bukkitKey);
-
-            Assert.assertNotNull("Unknown LootTable " + key, lootTable);
-            Assert.assertEquals(lootTable.getKey(), bukkitKey);
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/MaterialTest.java b/src/test/java/org/bukkit/MaterialTest.java
deleted file mode 100644
index 59682a687904615517e50f6485332aee11ce7340..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/MaterialTest.java
+++ /dev/null
@@ -1,75 +0,0 @@
-package org.bukkit;
-
-import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-import com.google.common.collect.Maps;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.stream.StreamSupport;
-import net.minecraft.core.IRegistry;
-import net.minecraft.resources.MinecraftKey;
-import net.minecraft.world.item.Item;
-import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Test;
-
-public class MaterialTest extends AbstractTestingBase {
-
-    @Test
-    public void verifyMapping() {
-        Map<MinecraftKey, Material> materials = Maps.newHashMap();
-        for (Material material : Material.values()) {
-            if (INVALIDATED_MATERIALS.contains(material)) {
-                continue;
-            }
-
-            materials.put(CraftMagicNumbers.key(material), material);
-        }
-
-        Iterator<Item> items = IRegistry.ITEM.iterator();
-
-        while (items.hasNext()) {
-            Item item = items.next();
-            if (item == null) continue;
-
-            MinecraftKey id = IRegistry.ITEM.getKey(item);
-            String name = item.getName();
-
-            Material material = materials.remove(id);
-
-            assertThat("Missing " + name + "(" + id + ")", material, is(not(nullValue())));
-            assertNotNull("No item mapping for " + name, CraftMagicNumbers.getMaterial(item));
-        }
-
-        assertThat(materials, is(Collections.EMPTY_MAP));
-    }
-
-    @Test
-    public void verifyMaterialOrder() {
-        List<Material> expectedOrder = new ArrayList<>(Material.values().length);
-
-        // Start with items in the same order as IRegistry.ITEM
-        StreamSupport.stream(IRegistry.ITEM.spliterator(), false)
-                .map(CraftMagicNumbers::getMaterial)
-                .forEach(expectedOrder::add);
-
-        // Then non-item blocks in the same order as IRegistry.BLOCK
-        StreamSupport.stream(IRegistry.BLOCK.spliterator(), false)
-                .map(CraftMagicNumbers::getMaterial)
-                .filter(block -> !block.isItem())
-                .forEach(expectedOrder::add);
-
-        // Then legacy materials in order of ID
-        Arrays.stream(Material.values())
-                .filter(Material::isLegacy)
-                .sorted(Comparator.comparingInt(Material::getId))
-                .forEach(expectedOrder::add);
-
-        assertArrayEquals(expectedOrder.toArray(), Material.values());
-    }
-}
diff --git a/src/test/java/org/bukkit/NibbleArrayTest.java b/src/test/java/org/bukkit/NibbleArrayTest.java
deleted file mode 100644
index 95f35775eeb7546432cce68edef99abd128fbd88..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/NibbleArrayTest.java
+++ /dev/null
@@ -1,29 +0,0 @@
-package org.bukkit;
-
-import java.util.Random;
-import net.minecraft.world.level.chunk.NibbleArray;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class NibbleArrayTest {
-
-    private static final int NIBBLE_SIZE = 4096;
-
-    @Test
-    public void testNibble() {
-        Random random = new Random();
-        byte[] classic = new byte[NIBBLE_SIZE];
-        NibbleArray nibble = new NibbleArray();
-
-        for (int i = 0; i < classic.length; i++) {
-            byte number = (byte) (random.nextInt() & 0xF);
-
-            classic[i] = number;
-            nibble.a(i, number);
-        }
-
-        for (int i = 0; i < classic.length; i++) {
-            Assert.assertEquals("Nibble array mismatch", classic[i], nibble.b(i));
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/ParticleTest.java b/src/test/java/org/bukkit/ParticleTest.java
deleted file mode 100644
index 49282d69199c05a78874a996ab26f7eaa10685b7..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/ParticleTest.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package org.bukkit;
-
-import net.minecraft.core.IRegistry;
-import org.bukkit.block.data.BlockData;
-import org.bukkit.craftbukkit.CraftParticle;
-import org.bukkit.craftbukkit.block.data.CraftBlockData;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.material.MaterialData;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class ParticleTest extends AbstractTestingBase {
-
-    @Test
-    public void verifyMapping() {
-        for (Particle bukkit : Particle.values()) {
-            Object data = null;
-            if (bukkit.getDataType().equals(ItemStack.class)) {
-                data = new ItemStack(Material.STONE);
-            } else if (bukkit.getDataType() == MaterialData.class) {
-                data = new MaterialData(Material.LEGACY_STONE);
-            } else if (bukkit.getDataType() == Particle.DustOptions.class) {
-                data = new Particle.DustOptions(Color.BLACK, 0);
-            } else if (bukkit.getDataType() == BlockData.class) {
-                data = CraftBlockData.newData(Material.STONE, "");
-            }
-
-            Assert.assertNotNull("Missing Bukkit->NMS particle mapping for " + bukkit, CraftParticle.toNMS(bukkit, data));
-        }
-        for (net.minecraft.core.particles.Particle nms : IRegistry.PARTICLE_TYPE) {
-            Assert.assertNotNull("Missing NMS->Bukkit particle mapping for " + IRegistry.PARTICLE_TYPE.getKey(nms), CraftParticle.toBukkit(nms));
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/PerMaterialTest.java b/src/test/java/org/bukkit/PerMaterialTest.java
deleted file mode 100644
index a777d0d8fba48d2e08395f03d755717bb75b07b1..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/PerMaterialTest.java
+++ /dev/null
@@ -1,270 +0,0 @@
-package org.bukkit;
-
-import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-import com.google.common.collect.Lists;
-import java.util.List;
-import java.util.Map;
-import net.minecraft.core.BlockPosition;
-import net.minecraft.world.EnumHand;
-import net.minecraft.world.entity.EntityInsentient;
-import net.minecraft.world.entity.player.EntityHuman;
-import net.minecraft.world.item.Item;
-import net.minecraft.world.item.ItemRecord;
-import net.minecraft.world.level.BlockAccessAir;
-import net.minecraft.world.level.block.Block;
-import net.minecraft.world.level.block.BlockFalling;
-import net.minecraft.world.level.block.BlockFire;
-import net.minecraft.world.level.block.Blocks;
-import net.minecraft.world.level.block.entity.TileEntityFurnace;
-import net.minecraft.world.level.block.state.BlockBase;
-import net.minecraft.world.level.block.state.IBlockData;
-import net.minecraft.world.phys.MovingObjectPositionBlock;
-import org.bukkit.craftbukkit.CraftEquipmentSlot;
-import org.bukkit.craftbukkit.inventory.CraftItemStack;
-import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.bukkit.enchantments.EnchantmentTarget;
-import org.bukkit.inventory.EquipmentSlot;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.support.AbstractTestingBase;
-import org.bukkit.support.Util;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameter;
-import org.junit.runners.Parameterized.Parameters;
-
-@RunWith(Parameterized.class)
-public class PerMaterialTest extends AbstractTestingBase {
-    private static Map<Block, Integer> fireValues;
-
-    @BeforeClass
-    public static void getFireValues() {
-        fireValues = Util.getInternalState(BlockFire.class, Blocks.FIRE, "flameChances");
-    }
-
-    @Parameters(name = "{index}: {0}")
-    public static List<Object[]> data() {
-        List<Object[]> list = Lists.newArrayList();
-        for (Material material : Material.values()) {
-            if (!material.isLegacy()) {
-                list.add(new Object[] {material});
-            }
-        }
-        return list;
-    }
-
-    @Parameter public Material material;
-
-    @Test
-    public void isBlock() {
-        if (material != Material.AIR && material != Material.CAVE_AIR && material != Material.VOID_AIR) {
-            assertThat(material.isBlock(), is(not(CraftMagicNumbers.getBlock(material) == null)));
-        }
-    }
-
-    @Test
-    public void isSolid() {
-        if (material == Material.AIR) {
-            assertFalse(material.isSolid());
-        } else if (material.isBlock()) {
-            assertThat(material.isSolid(), is(CraftMagicNumbers.getBlock(material).getBlockData().getMaterial().isSolid()));
-        } else {
-            assertFalse(material.isSolid());
-        }
-    }
-
-    @Test
-    public void isEdible() {
-        if (material.isBlock()) {
-            assertFalse(material.isEdible());
-        } else {
-            assertThat(material.isEdible(), is(CraftMagicNumbers.getItem(material).isFood()));
-        }
-    }
-
-    @Test
-    public void isRecord() {
-        assertThat(material.isRecord(), is(CraftMagicNumbers.getItem(material) instanceof ItemRecord));
-    }
-
-    @Test
-    public void maxDurability() {
-        if (INVALIDATED_MATERIALS.contains(material)) return;
-
-        if (material == Material.AIR) {
-            assertThat((int) material.getMaxDurability(), is(0));
-        } else if (material.isBlock()) {
-            Item item = CraftMagicNumbers.getItem(material);
-            assertThat((int) material.getMaxDurability(), is(item.getMaxDurability()));
-        }
-    }
-
-    @Test
-    public void maxStackSize() {
-        if (INVALIDATED_MATERIALS.contains(material)) return;
-
-        final ItemStack bukkit = new ItemStack(material);
-        final CraftItemStack craft = CraftItemStack.asCraftCopy(bukkit);
-        if (material == Material.AIR) {
-            final int MAX_AIR_STACK = 0 /* Why can't I hold all of these AIR? */;
-            assertThat(material.getMaxStackSize(), is(MAX_AIR_STACK));
-            assertThat(bukkit.getMaxStackSize(), is(MAX_AIR_STACK));
-            assertThat(craft.getMaxStackSize(), is(MAX_AIR_STACK));
-        } else {
-            assertThat(material.getMaxStackSize(), is(CraftMagicNumbers.getItem(material).getMaxStackSize()));
-            assertThat(bukkit.getMaxStackSize(), is(material.getMaxStackSize()));
-            assertThat(craft.getMaxStackSize(), is(material.getMaxStackSize()));
-        }
-    }
-
-    @Test
-    public void isTransparent() {
-        if (material == Material.AIR) {
-            assertTrue(material.isTransparent());
-        } else if (material.isBlock()) {
-            // assertThat(material.isTransparent(), is(not(CraftMagicNumbers.getBlock(material).getBlockData().getMaterial().blocksLight()))); // PAIL: not unit testable anymore (17w50a)
-        } else {
-            assertFalse(material.isTransparent());
-        }
-    }
-
-    @Test
-    public void isFlammable() {
-        if (material != Material.AIR && material.isBlock()) {
-            assertThat(material.isFlammable(), is(CraftMagicNumbers.getBlock(material).getBlockData().getMaterial().isBurnable()));
-        } else {
-            assertFalse(material.isFlammable());
-        }
-    }
-
-    @Test
-    public void isBurnable() {
-        if (material.isBlock()) {
-            Block block = CraftMagicNumbers.getBlock(material);
-            assertThat(material.isBurnable(), is(fireValues.containsKey(block) && fireValues.get(block) > 0));
-        } else {
-            assertFalse(material.isBurnable());
-        }
-    }
-
-    @Test
-    public void isFuel() {
-        assertThat(material.isFuel(), is(TileEntityFurnace.isFuel(new net.minecraft.world.item.ItemStack(CraftMagicNumbers.getItem(material)))));
-    }
-
-    @Test
-    public void isOccluding() {
-        if (material.isBlock()) {
-            assertThat(material.isOccluding(), is(CraftMagicNumbers.getBlock(material).getBlockData().isOccluding(BlockAccessAir.INSTANCE, BlockPosition.ZERO)));
-        } else {
-            assertFalse(material.isOccluding());
-        }
-    }
-
-    @Test
-    public void hasGravity() {
-        if (material.isBlock()) {
-            assertThat(material.hasGravity(), is(CraftMagicNumbers.getBlock(material) instanceof BlockFalling));
-        } else {
-            assertFalse(material.hasGravity());
-        }
-    }
-
-    @Test
-    public void usesDurability() {
-        if (!material.isBlock()) {
-            assertThat(EnchantmentTarget.BREAKABLE.includes(material), is(CraftMagicNumbers.getItem(material).usesDurability()));
-        } else {
-            assertFalse(EnchantmentTarget.BREAKABLE.includes(material));
-        }
-    }
-
-    @Test
-    public void testDurability() {
-        if (!material.isBlock()) {
-            assertThat(material.getMaxDurability(), is((short) CraftMagicNumbers.getItem(material).getMaxDurability()));
-        } else {
-            assertThat(material.getMaxDurability(), is((short) 0));
-        }
-    }
-
-    @Test
-    public void testBlock() {
-        if (material == Material.AIR) {
-            assertTrue(material.isBlock());
-        } else {
-            assertThat(material.isBlock(), is(equalTo(CraftMagicNumbers.getBlock(material) != null)));
-        }
-    }
-
-    @Test
-    public void testAir() {
-        if (material.isBlock()) {
-            assertThat(material.isAir(), is(equalTo(CraftMagicNumbers.getBlock(material).getBlockData().isAir())));
-        } else {
-            assertThat(material.isAir(), is(equalTo(false)));
-        }
-    }
-
-    @Test
-    public void testItem() {
-        if (material == Material.AIR) {
-            assertTrue(material.isItem());
-        } else {
-            assertThat(material.isItem(), is(equalTo(CraftMagicNumbers.getItem(material) != null)));
-        }
-    }
-
-    @Test
-    public void testInteractable() throws ReflectiveOperationException {
-        if (material.isBlock()) {
-            assertThat(material.isInteractable(),
-                    is(!CraftMagicNumbers.getBlock(material).getClass()
-                            .getMethod("interact", IBlockData.class, net.minecraft.world.level.World.class, BlockPosition.class, EntityHuman.class, EnumHand.class, MovingObjectPositionBlock.class)
-                            .getDeclaringClass().equals(BlockBase.class)));
-        } else {
-            assertFalse(material.isInteractable());
-        }
-    }
-
-    @Test
-    public void testBlockHardness() {
-        if (material.isBlock()) {
-            assertThat(material.getHardness(), is(CraftMagicNumbers.getBlock(material).getBlockData().strength));
-        }
-    }
-
-    @Test
-    public void testBlastResistance() {
-        if (material.isBlock()) {
-            assertThat(material.getBlastResistance(), is(CraftMagicNumbers.getBlock(material).getDurability()));
-        }
-    }
-
-    @Test
-    public void testBlockDataCreation() {
-        if (material.isBlock()) {
-            assertNotNull(material.createBlockData());
-        }
-    }
-
-    @Test
-    public void testCraftingRemainingItem() {
-        if (material.isItem()) {
-            Item expectedItem = CraftMagicNumbers.getItem(material).getCraftingRemainingItem();
-            Material expected = expectedItem == null ? null : CraftMagicNumbers.getMaterial(expectedItem);
-
-            assertThat(material.getCraftingRemainingItem(), is(expected));
-        }
-    }
-
-    @Test
-    public void testEquipmentSlot() {
-        if (material.isItem()) {
-            EquipmentSlot expected = CraftEquipmentSlot.getSlot(EntityInsentient.j(CraftItemStack.asNMSCopy(new ItemStack(material)))); // PAIL rename getEquipmentSlotForItem
-            assertThat(material.getEquipmentSlot(), is(expected));
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/SoundTest.java b/src/test/java/org/bukkit/SoundTest.java
deleted file mode 100644
index 3e05466c9211d4469df85165c4c55c3891ec61dd..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/SoundTest.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package org.bukkit;
-
-import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-import net.minecraft.core.IRegistry;
-import net.minecraft.resources.MinecraftKey;
-import org.bukkit.craftbukkit.CraftSound;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Test;
-
-public class SoundTest extends AbstractTestingBase {
-
-    @Test
-    public void testGetSound() {
-        for (Sound sound : Sound.values()) {
-            assertThat(sound.name(), CraftSound.getSoundEffect(sound), is(not(nullValue())));
-        }
-    }
-
-    @Test
-    public void testReverse() {
-        for (MinecraftKey effect : IRegistry.SOUND_EVENT.keySet()) {
-            assertNotNull(effect + "", Sound.valueOf(effect.getKey().replace('.', '_').toUpperCase(java.util.Locale.ENGLISH)));
-        }
-    }
-
-    @Test
-    public void testCategory() {
-        for (SoundCategory category : SoundCategory.values()) {
-            assertNotNull(category + "", net.minecraft.sounds.SoundCategory.valueOf(category.name()));
-        }
-    }
-
-    @Test
-    public void testCategoryReverse() {
-        for (net.minecraft.sounds.SoundCategory category : net.minecraft.sounds.SoundCategory.values()) {
-            assertNotNull(category + "", SoundCategory.valueOf(category.name()));
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/StatisticsAndAchievementsTest.java b/src/test/java/org/bukkit/StatisticsAndAchievementsTest.java
deleted file mode 100644
index d9c70d3956869a4fe58c3ffc93cce1de36db2d38..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/StatisticsAndAchievementsTest.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package org.bukkit;
-
-import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-import com.google.common.collect.HashMultiset;
-import net.minecraft.core.IRegistry;
-import net.minecraft.stats.StatisticWrapper;
-import net.minecraft.world.entity.EntityTypes;
-import org.bukkit.craftbukkit.CraftStatistic;
-import org.bukkit.entity.EntityType;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Test;
-
-public class StatisticsAndAchievementsTest extends AbstractTestingBase {
-
-    @Test
-    @SuppressWarnings("unchecked")
-    public void verifyEntityMapping() throws Throwable {
-        for (Statistic statistic : Statistic.values()) {
-            if (statistic.getType() == Statistic.Type.ENTITY) {
-                for (EntityType entity : EntityType.values()) {
-                    if (entity.getName() != null) {
-                        assertNotNull(statistic + " missing for " + entity, CraftStatistic.getEntityStatistic(statistic, entity));
-                    }
-                }
-            }
-        }
-    }
-
-    @Test
-    @SuppressWarnings("unchecked")
-    public void verifyStatisticMapping() throws Throwable {
-        HashMultiset<Statistic> statistics = HashMultiset.create();
-        for (StatisticWrapper wrapper : IRegistry.STATS) {
-            for (Object child : wrapper.getRegistry()) {
-                net.minecraft.stats.Statistic<?> statistic = wrapper.b(child);
-                String message = String.format("org.bukkit.Statistic is missing: '%s'", statistic);
-
-                Statistic subject = CraftStatistic.getBukkitStatistic(statistic);
-                assertThat(message, subject, is(not(nullValue())));
-
-                if (wrapper.getRegistry() == IRegistry.BLOCK || wrapper.getRegistry() == IRegistry.ITEM) {
-                    assertNotNull("Material type map missing for " + wrapper.getRegistry().getKey(child), CraftStatistic.getMaterialFromStatistic(statistic));
-                } else if (wrapper.getRegistry() == IRegistry.ENTITY_TYPE) {
-                    assertNotNull("Entity type map missing for " + EntityTypes.getName((EntityTypes<?>) child), CraftStatistic.getEntityTypeFromStatistic((net.minecraft.stats.Statistic<EntityTypes<?>>) statistic));
-                }
-
-                statistics.add(subject);
-            }
-        }
-
-        for (Statistic statistic : Statistic.values()) {
-            String message = String.format("org.bukkit.Statistic.%s does not have a corresponding minecraft statistic", statistic.name());
-            assertThat(message, statistics.remove(statistic, statistics.count(statistic)), is(greaterThan(0)));
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/StructureTypeTest.java b/src/test/java/org/bukkit/StructureTypeTest.java
deleted file mode 100644
index 4522e65e88c31917d31f93d6adf4c296d2b7b3ac..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/StructureTypeTest.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package org.bukkit;
-
-import java.util.Map;
-import net.minecraft.core.IRegistry;
-import net.minecraft.resources.MinecraftKey;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Assert;
-import org.junit.BeforeClass;
-import org.junit.Test;
-
-/**
- * This test makes sure that Bukkit always has Minecraft structure types up to
- * date.
- */
-public class StructureTypeTest extends AbstractTestingBase {
-
-    private static Map<String, StructureType> structures;
-
-    @BeforeClass
-    public static void setUp() {
-        structures = StructureType.getStructureTypes();
-    }
-
-    @Test
-    public void testMinecraftToBukkit() {
-        for (MinecraftKey key : IRegistry.STRUCTURE_FEATURE.keySet()) {
-            Assert.assertNotNull(key.getKey(), structures.get(key.getKey()));
-        }
-    }
-
-    @Test
-    public void testBukkit() {
-        for (Map.Entry<String, StructureType> entry : structures.entrySet()) {
-            Assert.assertNotNull(entry.getKey(), StructureType.getStructureTypes().get(entry.getKey()));
-            Assert.assertNotNull(entry.getValue().getName(), StructureType.getStructureTypes().get(entry.getValue().getName()));
-        }
-    }
-
-    @Test
-    public void testBukkitToMinecraft() {
-        for (Map.Entry<String, StructureType> entry : structures.entrySet()) {
-            Assert.assertNotNull(entry.getKey(), IRegistry.STRUCTURE_FEATURE.get(new MinecraftKey(entry.getKey())));
-            Assert.assertNotNull(entry.getValue().getName(), IRegistry.STRUCTURE_FEATURE.get(new MinecraftKey(entry.getValue().getName())));
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/block/banner/PatternTypeTest.java b/src/test/java/org/bukkit/block/banner/PatternTypeTest.java
deleted file mode 100644
index c7b6eed1159ab40168d2934c359df0b6687380d6..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/block/banner/PatternTypeTest.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package org.bukkit.block.banner;
-
-import junit.framework.Assert;
-import net.minecraft.world.level.block.entity.EnumBannerPatternType;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Test;
-
-public class PatternTypeTest extends AbstractTestingBase {
-
-    @Test
-    public void testToBukkit() {
-        for (EnumBannerPatternType nms : EnumBannerPatternType.values()) {
-            PatternType bukkit = PatternType.getByIdentifier(nms.b());
-
-            Assert.assertNotNull("No Bukkit banner for " + nms + " " + nms.b(), bukkit);
-        }
-    }
-
-    @Test
-    public void testToNMS() {
-        for (PatternType bukkit : PatternType.values()) {
-            EnumBannerPatternType found = null;
-            for (EnumBannerPatternType nms : EnumBannerPatternType.values()) {
-                if (bukkit.getIdentifier().equals(nms.b())) {
-                    found = nms;
-                    break;
-                }
-            }
-
-            Assert.assertNotNull("No NMS banner for " + bukkit + " " + bukkit.getIdentifier(), found);
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/craftbukkit/HeightMapTest.java b/src/test/java/org/bukkit/craftbukkit/HeightMapTest.java
deleted file mode 100644
index 356ba66452c6dec4c48dda9f79f96638dc2bb201..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/HeightMapTest.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package org.bukkit.craftbukkit;
-
-import org.bukkit.HeightMap;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class HeightMapTest {
-
-    @Test
-    public void heightMapConversionFromNMSToBukkitShouldNotThrowExceptio() {
-        for (net.minecraft.world.level.levelgen.HeightMap.Type nmsHeightMapType : net.minecraft.world.level.levelgen.HeightMap.Type.values()) {
-            Assert.assertNotNull("fromNMS", CraftHeightMap.fromNMS(nmsHeightMapType));
-        }
-    }
-
-    @Test
-    public void heightMapConversionFromBukkitToNMSShouldNotThrowExceptio() {
-        for (HeightMap bukkitHeightMap : HeightMap.values()) {
-            Assert.assertNotNull("toNMS", CraftHeightMap.toNMS(bukkitHeightMap));
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/craftbukkit/attribute/AttributeTest.java b/src/test/java/org/bukkit/craftbukkit/attribute/AttributeTest.java
deleted file mode 100644
index 09b61c24784d882fcfc7b2f696ecdf0fcb67d6c5..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/attribute/AttributeTest.java
+++ /dev/null
@@ -1,30 +0,0 @@
-package org.bukkit.craftbukkit.attribute;
-
-import net.minecraft.core.IRegistry;
-import net.minecraft.resources.MinecraftKey;
-import net.minecraft.world.entity.ai.attributes.AttributeBase;
-import org.bukkit.attribute.Attribute;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class AttributeTest extends AbstractTestingBase {
-
-    @Test
-    public void testToBukkit() {
-        for (MinecraftKey nms : IRegistry.ATTRIBUTE.keySet()) {
-            Attribute bukkit = CraftAttributeMap.fromMinecraft(nms.toString());
-
-            Assert.assertNotNull(nms.toString(), bukkit);
-        }
-    }
-
-    @Test
-    public void testToNMS() {
-        for (Attribute attribute : Attribute.values()) {
-            AttributeBase nms = CraftAttributeMap.toMinecraft(attribute);
-
-            Assert.assertNotNull(attribute.name(), nms);
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/craftbukkit/generator/ChunkDataTest.java b/src/test/java/org/bukkit/craftbukkit/generator/ChunkDataTest.java
deleted file mode 100644
index b59b28aa9c3824d352b89394eb3a506a11a0dff6..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/generator/ChunkDataTest.java
+++ /dev/null
@@ -1,81 +0,0 @@
-package org.bukkit.craftbukkit.generator;
-
-import static org.junit.Assert.*;
-import org.bukkit.Material;
-import org.bukkit.block.data.BlockData;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Test;
-
-public class ChunkDataTest extends AbstractTestingBase {
-
-    private static final BlockData RED_WOOL = Material.RED_WOOL.createBlockData();
-    private static final BlockData AIR = Material.AIR.createBlockData();
-
-    private boolean testSetBlock(CraftChunkData data, int x, int y, int z, BlockData type, BlockData expected) {
-        data.setBlock(x, y, z, type);
-        return expected.equals(data.getBlockData(x, y, z)) && expected.getMaterial().equals(data.getType(x, y, z));
-    }
-
-    private void testSetRegion(CraftChunkData data, int minx, int miny, int minz, int maxx, int maxy, int maxz, BlockData type) {
-        data.setRegion(minx, miny, minz, maxx, maxy, maxz, type);
-        for (int y = 0; y < data.getMaxHeight(); y++) {
-            for (int z = 0; z < 16; z++) {
-                for (int x = 0; x < 16; x++) {
-                    boolean inRegion = miny <= y && y < maxy && minx <= x && x < maxx && minz <= z && z < maxz;
-                    if (inRegion != type.equals(data.getBlockData(x, y, z))) {
-                        throw new IllegalStateException(
-                                "setRegion(" + minx + ", " + miny + ", " + minz + ", " + maxx + ", " + maxy + ", " + maxz + ", " + type + ")"
-                                + "-> block at " + x + ", " + y + ", " + z + " is " + data.getBlockData(x, y, z));
-                    }
-                }
-            }
-        }
-    }
-
-    @Test
-    public void testMaxHeight() {
-        CraftChunkData data = new CraftChunkData(128);
-        assertTrue("Could not set block above max height", testSetBlock(data, 0, 128, 0, RED_WOOL, AIR));
-        assertTrue("Could set block below max height", testSetBlock(data, 0, 127, 0, RED_WOOL, RED_WOOL));
-    }
-
-    @Test
-    public void testBoundsCheckingSingle() {
-        CraftChunkData data = new CraftChunkData(256);
-        assertTrue("Can set block inside chunk bounds", testSetBlock(data, 0, 0, 0, RED_WOOL, RED_WOOL));
-        assertTrue("Can set block inside chunk bounds", testSetBlock(data, 15, 255, 15, RED_WOOL, RED_WOOL));
-        assertTrue("Can no set block outside chunk bounds", testSetBlock(data, -1, 0, 0, RED_WOOL, AIR));
-        assertTrue("Can no set block outside chunk bounds", testSetBlock(data, 0, -1, 0, RED_WOOL, AIR));
-        assertTrue("Can no set block outside chunk bounds", testSetBlock(data, 0, 0, -1, RED_WOOL, AIR));
-        assertTrue("Can no set block outside chunk bounds", testSetBlock(data, 16, 0, 0, RED_WOOL, AIR));
-        assertTrue("Can no set block outside chunk bounds", testSetBlock(data, 0, 256, 0, RED_WOOL, AIR));
-        assertTrue("Can no set block outside chunk bounds", testSetBlock(data, 0, 0, 16, RED_WOOL, AIR));
-    }
-
-    @Test
-    public void testSetRegion() {
-        CraftChunkData data = new CraftChunkData(256);
-        testSetRegion(data, -100, 0, -100, 0, 256, 0, RED_WOOL); // exclusively outside
-        testSetRegion(data, 16, 256, 16, 0, 0, 0, RED_WOOL); // minimum >= maximum
-        testSetRegion(data, 0, 0, 0, 0, 0, 0, RED_WOOL); // minimum == maximum
-        testSetRegion(data, 0, 0, 0, 16, 16, 16, RED_WOOL); // Whole Chunk Section
-        data.setRegion(0, 0, 0, 16, 256, 16, AIR);
-        testSetRegion(data, 0, 8, 0, 16, 24, 16, RED_WOOL); // Start middle of this section, end middle of next
-        data.setRegion(0, 0, 0, 16, 256, 16, AIR);
-        testSetRegion(data, 0, 4, 0, 16, 12, 16, RED_WOOL); // Start in this section, end in this section
-        data.setRegion(0, 0, 0, 16, 256, 16, AIR);
-        testSetRegion(data, 0, 0, 0, 16, 16, 1, RED_WOOL); // Whole Chunk Section
-        data.setRegion(0, 0, 0, 16, 256, 16, AIR);
-        testSetRegion(data, 0, 8, 0, 16, 24, 1, RED_WOOL); // Start middle of this section, end middle of next
-        data.setRegion(0, 0, 0, 16, 256, 16, AIR);
-        testSetRegion(data, 0, 4, 0, 16, 12, 1, RED_WOOL); // Start in this section, end in this section
-        data.setRegion(0, 0, 0, 16, 256, 16, AIR);
-        testSetRegion(data, 0, 0, 0, 1, 16, 1, RED_WOOL); // Whole Chunk Section
-        data.setRegion(0, 0, 0, 16, 256, 16, AIR);
-        testSetRegion(data, 0, 8, 0, 1, 24, 1, RED_WOOL); // Start middle of this section, end middle of next
-        data.setRegion(0, 0, 0, 16, 256, 16, AIR);
-        testSetRegion(data, 0, 4, 0, 1, 12, 1, RED_WOOL); // Start in this section, end in this section
-        data.setRegion(0, 0, 0, 16, 256, 16, AIR);
-        testSetRegion(data, 0, 0, 0, 1, 1, 1, RED_WOOL); // Set single block.
-    }
-}
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/CompositeSerialization.java b/src/test/java/org/bukkit/craftbukkit/inventory/CompositeSerialization.java
deleted file mode 100644
index 1bbfa365b068d3e4c40d1c3d5c86085fdd07bb2b..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/inventory/CompositeSerialization.java
+++ /dev/null
@@ -1,70 +0,0 @@
-package org.bukkit.craftbukkit.inventory;
-
-import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import org.bukkit.ChatColor;
-import org.bukkit.Material;
-import org.bukkit.configuration.InvalidConfigurationException;
-import org.bukkit.configuration.file.YamlConfiguration;
-import org.bukkit.enchantments.Enchantment;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.inventory.meta.ItemMeta;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Test;
-
-public class CompositeSerialization extends AbstractTestingBase {
-
-    public YamlConfiguration getConfig() {
-        return new YamlConfiguration();
-    }
-
-    @Test
-    public void testSaveRestoreCompositeList() throws InvalidConfigurationException {
-        YamlConfiguration out = getConfig();
-
-        List<ItemStack> stacks = new ArrayList<ItemStack>();
-        stacks.add(new ItemStack(Material.STONE));
-        stacks.add(new ItemStack(Material.GRASS));
-        stacks.add(new ItemStack(Material.DIRT));
-        stacks.add(new ItemStack(Material.COBBLESTONE, 17));
-        stacks.add(new ItemStack(Material.OAK_PLANKS, 63));
-        stacks.add(new ItemStack(Material.OAK_SAPLING, 1, (short) 1));
-        stacks.add(new ItemStack(Material.OAK_LEAVES, 32, (short) 2));
-
-        ItemStack item7 = new ItemStack(Material.IRON_SHOVEL);
-        item7.addUnsafeEnchantment(Enchantment.PROTECTION_FIRE, 1);
-        stacks.add(item7);
-
-        ItemStack item8 = new ItemStack(Material.IRON_PICKAXE);
-        item8.addUnsafeEnchantment(Enchantment.PROTECTION_FALL, 2);
-        item8.addUnsafeEnchantment(Enchantment.PROTECTION_EXPLOSIONS, 1);
-        item8.addUnsafeEnchantment(Enchantment.PROTECTION_PROJECTILE, 5);
-        item8.addUnsafeEnchantment(Enchantment.OXYGEN, 4);
-        stacks.add(item8);
-
-        ItemStack item9 = new ItemStack(Material.APPLE);
-        ItemMeta meta9 = item9.getItemMeta();
-        meta9.setDisplayName(ChatColor.RED + "DisplayName");
-        meta9.setLocalizedName(ChatColor.AQUA + "LocalizedName");
-        meta9.setLore(Arrays.asList(ChatColor.BLUE + "Lore1", ChatColor.DARK_AQUA + "Lore2"));
-        item9.setItemMeta(meta9);
-        stacks.add(item9);
-
-        out.set("composite-list.abc.def", stacks);
-        String yaml = out.saveToString();
-
-        YamlConfiguration in = new YamlConfiguration();
-        in.loadFromString(yaml);
-        List<?> raw = in.getList("composite-list.abc.def");
-
-        assertThat(stacks, hasSize(raw.size()));
-
-        for (int i = 0; i < raw.size(); i++) {
-            assertThat(String.valueOf(i), (Object) stacks.get(i), is((Object) raw.get(i)));
-        }
-    }
-}
-
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/DeprecatedItemMetaCustomValueTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/DeprecatedItemMetaCustomValueTest.java
deleted file mode 100644
index b075749edf6e68f740160d1c7241140ea218d4af..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/inventory/DeprecatedItemMetaCustomValueTest.java
+++ /dev/null
@@ -1,313 +0,0 @@
-package org.bukkit.craftbukkit.inventory;
-
-import static org.junit.Assert.*;
-import java.io.StringReader;
-import java.lang.reflect.Array;
-import java.nio.ByteBuffer;
-import java.util.Map;
-import java.util.UUID;
-import net.minecraft.nbt.NBTTagCompound;
-import org.bukkit.Bukkit;
-import org.bukkit.Material;
-import org.bukkit.NamespacedKey;
-import org.bukkit.configuration.file.YamlConfiguration;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.inventory.meta.ItemMeta;
-import org.bukkit.inventory.meta.tags.CustomItemTagContainer;
-import org.bukkit.inventory.meta.tags.ItemTagAdapterContext;
-import org.bukkit.inventory.meta.tags.ItemTagType;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Before;
-import org.junit.Test;
-
-public class DeprecatedItemMetaCustomValueTest extends AbstractTestingBase {
-
-    private static NamespacedKey VALID_KEY;
-
-    @Before
-    public void setup() {
-        VALID_KEY = new NamespacedKey("test", "validkey");
-    }
-
-    /*
-        Sets a test
-     */
-    @Test(expected = IllegalArgumentException.class)
-    public void testSetNoAdapter() {
-        ItemMeta itemMeta = createNewItemMeta();
-        itemMeta.getCustomTagContainer().setCustomTag(VALID_KEY, new PrimitiveTagType<>(boolean.class), true);
-    }
-
-    /*
-        Contains a tag
-     */
-    @Test(expected = IllegalArgumentException.class)
-    public void testHasNoAdapter() {
-        ItemMeta itemMeta = createNewItemMeta();
-        itemMeta.getCustomTagContainer().setCustomTag(VALID_KEY, ItemTagType.INTEGER, 1); // We gotta set this so we at least try to compare it
-        itemMeta.getCustomTagContainer().hasCustomTag(VALID_KEY, new PrimitiveTagType<>(boolean.class));
-    }
-
-    /*
-        Getting a tag
-     */
-    @Test(expected = IllegalArgumentException.class)
-    public void testGetNoAdapter() {
-        ItemMeta itemMeta = createNewItemMeta();
-        itemMeta.getCustomTagContainer().setCustomTag(VALID_KEY, ItemTagType.INTEGER, 1); //We gotta set this so we at least try to compare it
-        itemMeta.getCustomTagContainer().getCustomTag(VALID_KEY, new PrimitiveTagType<>(boolean.class));
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testGetWrongType() {
-        ItemMeta itemMeta = createNewItemMeta();
-        itemMeta.getCustomTagContainer().setCustomTag(VALID_KEY, ItemTagType.INTEGER, 1);
-        itemMeta.getCustomTagContainer().getCustomTag(VALID_KEY, ItemTagType.STRING);
-    }
-
-    @Test
-    public void testDifferentNamespace() {
-        NamespacedKey namespacedKeyA = new NamespacedKey("plugin-a", "damage");
-        NamespacedKey namespacedKeyB = new NamespacedKey("plugin-b", "damage");
-
-        ItemMeta meta = createNewItemMeta();
-        meta.getCustomTagContainer().setCustomTag(namespacedKeyA, ItemTagType.LONG, 15L);
-        meta.getCustomTagContainer().setCustomTag(namespacedKeyB, ItemTagType.LONG, 160L);
-
-        assertEquals(15L, (long) meta.getCustomTagContainer().getCustomTag(namespacedKeyA, ItemTagType.LONG));
-        assertEquals(160L, (long) meta.getCustomTagContainer().getCustomTag(namespacedKeyB, ItemTagType.LONG));
-    }
-
-    private ItemMeta createNewItemMeta() {
-        return Bukkit.getItemFactory().getItemMeta(Material.DIAMOND_PICKAXE);
-    }
-
-    private NamespacedKey requestKey(String keyName) {
-        return new NamespacedKey("test-plugin", keyName.toLowerCase());
-    }
-
-    /*
-        Removing a tag
-     */
-    @Test
-    public void testNBTTagStoring() {
-        CraftMetaItem itemMeta = createComplexItemMeta();
-
-        NBTTagCompound compound = new NBTTagCompound();
-        itemMeta.applyToItem(compound);
-
-        assertEquals(itemMeta, new CraftMetaItem(compound));
-    }
-
-    @Test
-    public void testMapStoring() {
-        CraftMetaItem itemMeta = createComplexItemMeta();
-
-        Map<String, Object> serialize = itemMeta.serialize();
-        assertEquals(itemMeta, new CraftMetaItem(serialize));
-    }
-
-    @Test
-    public void testYAMLStoring() {
-        ItemStack stack = new ItemStack(Material.DIAMOND);
-        CraftMetaItem meta = createComplexItemMeta();
-        stack.setItemMeta(meta);
-
-        YamlConfiguration configuration = new YamlConfiguration();
-        configuration.set("testpath", stack);
-
-        String configValue = configuration.saveToString();
-        YamlConfiguration loadedConfig = YamlConfiguration.loadConfiguration(new StringReader(configValue));
-
-        assertEquals(stack, loadedConfig.getSerializable("testpath", ItemStack.class));
-        assertNotEquals(new ItemStack(Material.DIAMOND), loadedConfig.getSerializable("testpath", ItemStack.class));
-    }
-
-    @Test
-    public void testCorrectType() {
-        ItemStack stack = new ItemStack(Material.DIAMOND);
-        CraftMetaItem meta = createComplexItemMeta();
-
-        meta.getCustomTagContainer().setCustomTag(requestKey("int"), ItemTagType.STRING, "1");
-        meta.getCustomTagContainer().setCustomTag(requestKey("double"), ItemTagType.STRING, "1.33");
-        stack.setItemMeta(meta);
-
-        YamlConfiguration configuration = new YamlConfiguration();
-        configuration.set("testpath", stack);
-
-        String configValue = configuration.saveToString();
-        YamlConfiguration loadedConfig = YamlConfiguration.loadConfiguration(new StringReader(configValue));
-        ItemStack newStack = loadedConfig.getSerializable("testpath", ItemStack.class);
-
-        assertTrue(newStack.getItemMeta().getCustomTagContainer().hasCustomTag(requestKey("int"), ItemTagType.STRING));
-        assertEquals(newStack.getItemMeta().getCustomTagContainer().getCustomTag(requestKey("int"), ItemTagType.STRING), "1");
-
-        assertTrue(newStack.getItemMeta().getCustomTagContainer().hasCustomTag(requestKey("double"), ItemTagType.STRING));
-        assertEquals(newStack.getItemMeta().getCustomTagContainer().getCustomTag(requestKey("double"), ItemTagType.STRING), "1.33");
-    }
-
-    private CraftMetaItem createComplexItemMeta() {
-        CraftMetaItem itemMeta = (CraftMetaItem) createNewItemMeta();
-        itemMeta.setDisplayName("Item Display Name");
-
-        itemMeta.getCustomTagContainer().setCustomTag(requestKey("custom-long"), ItemTagType.LONG, 4L); //Add random primitive values
-        itemMeta.getCustomTagContainer().setCustomTag(requestKey("custom-byte-array"), ItemTagType.BYTE_ARRAY, new byte[]{
-            0, 1, 2, 10
-        });
-        itemMeta.getCustomTagContainer().setCustomTag(requestKey("custom-string"), ItemTagType.STRING, "Hello there world");
-        itemMeta.getCustomTagContainer().setCustomTag(requestKey("custom-int"), ItemTagType.INTEGER, 3);
-        itemMeta.getCustomTagContainer().setCustomTag(requestKey("custom-double"), ItemTagType.DOUBLE, 3.123);
-
-        CustomItemTagContainer innerContainer = itemMeta.getCustomTagContainer().getAdapterContext().newTagContainer(); //Add a inner container
-        innerContainer.setCustomTag(VALID_KEY, ItemTagType.LONG, 5L);
-        itemMeta.getCustomTagContainer().setCustomTag(requestKey("custom-inner-compound"), ItemTagType.TAG_CONTAINER, innerContainer);
-        return itemMeta;
-    }
-
-    /*
-        Test complex object storage
-     */
-    @Test
-    public void storeUUIDOnItemTest() {
-        ItemMeta itemMeta = createNewItemMeta();
-        UUIDItemTagType uuidItemTagType = new UUIDItemTagType();
-        UUID uuid = UUID.fromString("434eea72-22a6-4c61-b5ef-945874a5c478");
-
-        itemMeta.getCustomTagContainer().setCustomTag(VALID_KEY, uuidItemTagType, uuid);
-        assertTrue(itemMeta.getCustomTagContainer().hasCustomTag(VALID_KEY, uuidItemTagType));
-        assertEquals(uuid, itemMeta.getCustomTagContainer().getCustomTag(VALID_KEY, uuidItemTagType));
-    }
-
-    @Test
-    public void encapsulatedContainers() {
-        NamespacedKey innerKey = new NamespacedKey("plugin-a", "inner");
-
-        ItemMeta meta = createNewItemMeta();
-        ItemTagAdapterContext context = meta.getCustomTagContainer().getAdapterContext();
-
-        CustomItemTagContainer thirdContainer = context.newTagContainer();
-        thirdContainer.setCustomTag(VALID_KEY, ItemTagType.LONG, 3L);
-
-        CustomItemTagContainer secondContainer = context.newTagContainer();
-        secondContainer.setCustomTag(VALID_KEY, ItemTagType.LONG, 2L);
-        secondContainer.setCustomTag(innerKey, ItemTagType.TAG_CONTAINER, thirdContainer);
-
-        meta.getCustomTagContainer().setCustomTag(VALID_KEY, ItemTagType.LONG, 1L);
-        meta.getCustomTagContainer().setCustomTag(innerKey, ItemTagType.TAG_CONTAINER, secondContainer);
-
-        assertEquals(3L, meta.getCustomTagContainer()
-                .getCustomTag(innerKey, ItemTagType.TAG_CONTAINER)
-                .getCustomTag(innerKey, ItemTagType.TAG_CONTAINER)
-                .getCustomTag(VALID_KEY, ItemTagType.LONG).longValue());
-
-        assertEquals(2L, meta.getCustomTagContainer()
-                .getCustomTag(innerKey, ItemTagType.TAG_CONTAINER)
-                .getCustomTag(VALID_KEY, ItemTagType.LONG).longValue());
-
-        assertEquals(1L, meta.getCustomTagContainer()
-                .getCustomTag(VALID_KEY, ItemTagType.LONG).longValue());
-    }
-
-    class UUIDItemTagType implements ItemTagType<byte[], UUID> {
-
-        @Override
-        public Class<byte[]> getPrimitiveType() {
-            return byte[].class;
-        }
-
-        @Override
-        public Class<UUID> getComplexType() {
-            return UUID.class;
-        }
-
-        @Override
-        public byte[] toPrimitive(UUID complex, ItemTagAdapterContext context) {
-            ByteBuffer bb = ByteBuffer.wrap(new byte[16]);
-            bb.putLong(complex.getMostSignificantBits());
-            bb.putLong(complex.getLeastSignificantBits());
-            return bb.array();
-        }
-
-        @Override
-        public UUID fromPrimitive(byte[] primitive, ItemTagAdapterContext context) {
-            ByteBuffer bb = ByteBuffer.wrap(primitive);
-            long firstLong = bb.getLong();
-            long secondLong = bb.getLong();
-            return new UUID(firstLong, secondLong);
-        }
-    }
-
-    @Test
-    public void testPrimitiveCustomTags() {
-        ItemMeta itemMeta = createNewItemMeta();
-
-        testPrimitiveCustomTag(itemMeta, ItemTagType.BYTE, (byte) 1);
-        testPrimitiveCustomTag(itemMeta, ItemTagType.SHORT, (short) 1);
-        testPrimitiveCustomTag(itemMeta, ItemTagType.INTEGER, 1);
-        testPrimitiveCustomTag(itemMeta, ItemTagType.LONG, 1L);
-        testPrimitiveCustomTag(itemMeta, ItemTagType.FLOAT, 1.34F);
-        testPrimitiveCustomTag(itemMeta, ItemTagType.DOUBLE, 151.123);
-
-        testPrimitiveCustomTag(itemMeta, ItemTagType.STRING, "test");
-
-        testPrimitiveCustomTag(itemMeta, ItemTagType.BYTE_ARRAY, new byte[]{
-            1, 4, 2, Byte.MAX_VALUE
-        });
-        testPrimitiveCustomTag(itemMeta, ItemTagType.INTEGER_ARRAY, new int[]{
-            1, 4, 2, Integer.MAX_VALUE
-        });
-        testPrimitiveCustomTag(itemMeta, ItemTagType.LONG_ARRAY, new long[]{
-            1L, 4L, 2L, Long.MAX_VALUE
-        });
-    }
-
-    private <T, Z> void testPrimitiveCustomTag(ItemMeta meta, ItemTagType<T, Z> type, Z value) {
-        NamespacedKey tagKey = new NamespacedKey("test", String.valueOf(type.hashCode()));
-
-        meta.getCustomTagContainer().setCustomTag(tagKey, type, value);
-        assertTrue(meta.getCustomTagContainer().hasCustomTag(tagKey, type));
-
-        Z foundValue = meta.getCustomTagContainer().getCustomTag(tagKey, type);
-        if (foundValue.getClass().isArray()) { // Compare arrays using reflection access
-            int length = Array.getLength(foundValue);
-            int originalLength = Array.getLength(value);
-            for (int i = 0; i < length && i < originalLength; i++) {
-                assertEquals(Array.get(value, i), Array.get(foundValue, i));
-            }
-        } else {
-            assertEquals(foundValue, value);
-        }
-
-        meta.getCustomTagContainer().removeCustomTag(tagKey);
-        assertFalse(meta.getCustomTagContainer().hasCustomTag(tagKey, type));
-    }
-
-    class PrimitiveTagType<T> implements ItemTagType<T, T> {
-
-        private final Class<T> primitiveType;
-
-        PrimitiveTagType(Class<T> primitiveType) {
-            this.primitiveType = primitiveType;
-        }
-
-        @Override
-        public Class<T> getPrimitiveType() {
-            return primitiveType;
-        }
-
-        @Override
-        public Class<T> getComplexType() {
-            return primitiveType;
-        }
-
-        @Override
-        public T toPrimitive(T complex, ItemTagAdapterContext context) {
-            return complex;
-        }
-
-        @Override
-        public T fromPrimitive(T primitive, ItemTagAdapterContext context) {
-            return primitive;
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/FactoryItemMaterialTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/FactoryItemMaterialTest.java
deleted file mode 100644
index c279579c2bd54363090c6c99fbd92798a6b97c79..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/inventory/FactoryItemMaterialTest.java
+++ /dev/null
@@ -1,153 +0,0 @@
-package org.bukkit.craftbukkit.inventory;
-
-import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-import java.util.ArrayList;
-import java.util.List;
-import org.bukkit.Material;
-import org.bukkit.inventory.ItemFactory;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.inventory.meta.ItemMeta;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameter;
-import org.junit.runners.Parameterized.Parameters;
-
-@RunWith(Parameterized.class)
-public class FactoryItemMaterialTest extends AbstractTestingBase {
-    static final ItemFactory factory = CraftItemFactory.instance();
-    static final StringBuilder buffer = new StringBuilder();
-    static final Material[] materials;
-
-    static {
-        Material[] local_materials = Material.values();
-        List<Material> list = new ArrayList<Material>(local_materials.length);
-        for (Material material : local_materials) {
-            if (INVALIDATED_MATERIALS.contains(material)) {
-                continue;
-            }
-
-            list.add(material);
-        }
-        materials = list.toArray(new Material[list.size()]);
-    }
-
-    static String name(Enum<?> from, Enum<?> to) {
-        if (from.getClass() == to.getClass()) {
-            return buffer.delete(0, Integer.MAX_VALUE).append(from.getClass().getName()).append(' ').append(from.name()).append(" to ").append(to.name()).toString();
-        }
-        return buffer.delete(0, Integer.MAX_VALUE).append(from.getClass().getName()).append('(').append(from.name()).append(") to ").append(to.getClass().getName()).append('(').append(to.name()).append(')').toString();
-    }
-
-    @Parameters(name = "Material[{index}]:{0}")
-    public static List<Object[]> data() {
-        List<Object[]> list = new ArrayList<Object[]>();
-        for (Material material : materials) {
-            list.add(new Object[] {material});
-        }
-        return list;
-    }
-
-    @Parameter(0) public Material material;
-
-    @Test
-    public void itemStack() {
-        ItemStack bukkitStack = new ItemStack(material);
-        CraftItemStack craftStack = CraftItemStack.asCraftCopy(bukkitStack);
-        ItemMeta meta = factory.getItemMeta(material);
-        if (meta == null) {
-            assertThat(material, is(Material.AIR));
-        } else {
-            assertTrue(factory.isApplicable(meta, bukkitStack));
-            assertTrue(factory.isApplicable(meta, craftStack));
-        }
-    }
-
-    @Test
-    public void generalCase() {
-        CraftMetaItem meta = (CraftMetaItem) factory.getItemMeta(material);
-        if (meta == null) {
-            assertThat(material, is(Material.AIR));
-        } else {
-            assertTrue(factory.isApplicable(meta, material));
-            assertTrue(meta.applicableTo(material));
-
-            meta = meta.clone();
-            assertTrue(factory.isApplicable(meta, material));
-            assertTrue(meta.applicableTo(material));
-        }
-    }
-
-    @Test
-    public void asMetaFor() {
-        final CraftMetaItem baseMeta = (CraftMetaItem) factory.getItemMeta(material);
-        if (baseMeta == null) {
-            assertThat(material, is(Material.AIR));
-            return;
-        }
-
-        for (Material other : materials) {
-            final ItemStack bukkitStack = new ItemStack(other);
-            final CraftItemStack craftStack = CraftItemStack.asCraftCopy(bukkitStack);
-            final CraftMetaItem otherMeta = (CraftMetaItem) factory.asMetaFor(baseMeta, other);
-
-            final String testName = name(material, other);
-
-            if (otherMeta == null) {
-                assertThat(testName, other, is(Material.AIR));
-                continue;
-            }
-
-            assertTrue(testName, factory.isApplicable(otherMeta, craftStack));
-            assertTrue(testName, factory.isApplicable(otherMeta, bukkitStack));
-            assertTrue(testName, factory.isApplicable(otherMeta, other));
-            assertTrue(testName, otherMeta.applicableTo(other));
-        }
-    }
-
-    @Test
-    public void blankEqualities() {
-        if (material == Material.AIR) {
-            return;
-        }
-        final CraftMetaItem baseMeta = (CraftMetaItem) factory.getItemMeta(material);
-        final CraftMetaItem baseMetaClone = baseMeta.clone();
-
-        final ItemStack baseMetaStack = new ItemStack(material);
-        baseMetaStack.setItemMeta(baseMeta);
-
-        assertThat(baseMeta, is(not(sameInstance(baseMetaStack.getItemMeta()))));
-
-        assertTrue(factory.equals(baseMeta, null));
-        assertTrue(factory.equals(null, baseMeta));
-
-        assertTrue(factory.equals(baseMeta, baseMetaClone));
-        assertTrue(factory.equals(baseMetaClone, baseMeta));
-
-        assertThat(baseMeta, is(not(sameInstance(baseMetaClone))));
-
-        assertThat(baseMeta, is(baseMetaClone));
-        assertThat(baseMetaClone, is(baseMeta));
-
-        for (Material other : materials) {
-            final String testName = name(material, other);
-
-            final CraftMetaItem otherMeta = (CraftMetaItem) factory.asMetaFor(baseMetaClone, other);
-
-            if (otherMeta == null) {
-                assertThat(testName, other, is(Material.AIR));
-                continue;
-            }
-
-            assertTrue(testName, factory.equals(baseMeta, otherMeta));
-            assertTrue(testName, factory.equals(otherMeta, baseMeta));
-
-            assertThat(testName, baseMeta, is(otherMeta));
-            assertThat(testName, otherMeta, is(baseMeta));
-
-            assertThat(testName, baseMeta.hashCode(), is(otherMeta.hashCode()));
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaCloneTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaCloneTest.java
deleted file mode 100644
index cefedd7d1e568d046b2e6f2ee75ffcf13754c5bb..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaCloneTest.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package org.bukkit.craftbukkit.inventory;
-
-import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-import java.lang.reflect.Method;
-import org.bukkit.Material;
-import org.junit.Test;
-
-public class ItemMetaCloneTest {
-
-    @Test
-    public void testClone() throws Throwable {
-        for (Material material : ItemStackTest.COMPOUND_MATERIALS) {
-            Class<?> clazz = CraftItemFactory.instance().getItemMeta(material).getClass();
-
-            Method clone = clazz.getDeclaredMethod("clone");
-            assertNotNull("Class " + clazz + " does not override clone()", clone);
-            assertThat("Class " + clazz + " clone return type does not match", clone.getReturnType(), is(equalTo(clazz)));
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaImplementationOverrideTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaImplementationOverrideTest.java
deleted file mode 100644
index 61ac1fb7c5beee7b7adbaafd6ea20e2e6bc778e5..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaImplementationOverrideTest.java
+++ /dev/null
@@ -1,80 +0,0 @@
-package org.bukkit.craftbukkit.inventory;
-
-import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.Callable;
-import org.bukkit.Material;
-import org.bukkit.configuration.serialization.DelegateDeserialization;
-import org.bukkit.craftbukkit.Overridden;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameter;
-import org.junit.runners.Parameterized.Parameters;
-
-@RunWith(Parameterized.class)
-public class ItemMetaImplementationOverrideTest {
-    static final Class<CraftMetaItem> parent = CraftMetaItem.class;
-
-    @Parameters(name = "[{index}]:{1}")
-    public static List<Object[]> data() {
-        final List<Object[]> testData = new ArrayList<Object[]>();
-        List<Class<? extends CraftMetaItem>> classes = new ArrayList<Class<? extends CraftMetaItem>>();
-
-        for (Material material : ItemStackTest.COMPOUND_MATERIALS) {
-            Class<? extends CraftMetaItem> clazz = CraftItemFactory.instance().getItemMeta(material).getClass().asSubclass(parent);
-            if (clazz != parent) {
-                classes.add(clazz);
-            }
-        }
-
-        List<Method> list = new ArrayList<Method>();
-
-        for (Method method: parent.getDeclaredMethods()) {
-            if (method.isAnnotationPresent(Overridden.class)) {
-                list.add(method);
-            }
-        }
-
-        for (final Class<?> clazz : classes) {
-            for (final Method method : list) {
-                testData.add(
-                    new Object[] {
-                        new Callable<Method>() {
-                            @Override
-                            public Method call() throws Exception {
-                                return clazz.getDeclaredMethod(method.getName(), method.getParameterTypes());
-                            }
-                        },
-                        clazz.getSimpleName() + " contains " + method.getName()
-                    }
-                );
-            }
-
-            testData.add(
-                new Object[] {
-                    new Callable<DelegateDeserialization>() {
-                        @Override
-                        public DelegateDeserialization call() throws Exception {
-                            return clazz.getAnnotation(DelegateDeserialization.class);
-                        }
-                    },
-                    clazz.getSimpleName() + " contains annotation " + DelegateDeserialization.class
-                }
-            );
-        }
-
-        return testData;
-    }
-
-    @Parameter(0) public Callable<?> test;
-    @Parameter(1) public String name;
-
-    @Test
-    public void testClass() throws Throwable {
-        assertThat(name, test.call(), is(not(nullValue())));
-    }
-}
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaTest.java
deleted file mode 100644
index b85a0a4c4f134dd6012d9141244ecf97b4300b65..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaTest.java
+++ /dev/null
@@ -1,437 +0,0 @@
-package org.bukkit.craftbukkit.inventory;
-
-import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.UUID;
-import net.minecraft.core.IRegistry;
-import net.minecraft.nbt.NBTTagCompound;
-import net.minecraft.world.item.Item;
-import net.minecraft.world.item.ItemBlock;
-import net.minecraft.world.item.ItemBlockWallable;
-import net.minecraft.world.level.block.Block;
-import net.minecraft.world.level.block.ITileEntity;
-import org.bukkit.Bukkit;
-import org.bukkit.Color;
-import org.bukkit.DyeColor;
-import org.bukkit.FireworkEffect;
-import org.bukkit.FireworkEffect.Type;
-import org.bukkit.Material;
-import org.bukkit.NamespacedKey;
-import org.bukkit.attribute.Attribute;
-import org.bukkit.attribute.AttributeModifier;
-import org.bukkit.block.banner.Pattern;
-import org.bukkit.block.banner.PatternType;
-import org.bukkit.craftbukkit.block.data.CraftBlockData;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.BukkitWrapper;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.CraftWrapper;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.StackProvider;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.StackWrapper;
-import org.bukkit.enchantments.Enchantment;
-import org.bukkit.entity.TropicalFish;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.inventory.meta.BannerMeta;
-import org.bukkit.inventory.meta.BlockDataMeta;
-import org.bukkit.inventory.meta.BlockStateMeta;
-import org.bukkit.inventory.meta.BookMeta;
-import org.bukkit.inventory.meta.CrossbowMeta;
-import org.bukkit.inventory.meta.EnchantmentStorageMeta;
-import org.bukkit.inventory.meta.FireworkEffectMeta;
-import org.bukkit.inventory.meta.FireworkMeta;
-import org.bukkit.inventory.meta.ItemMeta;
-import org.bukkit.inventory.meta.KnowledgeBookMeta;
-import org.bukkit.inventory.meta.LeatherArmorMeta;
-import org.bukkit.inventory.meta.MapMeta;
-import org.bukkit.inventory.meta.PotionMeta;
-import org.bukkit.inventory.meta.TropicalFishBucketMeta;
-import org.bukkit.potion.PotionData;
-import org.bukkit.potion.PotionEffectType;
-import org.bukkit.potion.PotionType;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Test;
-
-public class ItemMetaTest extends AbstractTestingBase {
-
-    static final int MAX_FIREWORK_POWER = 127; // Please update ItemStackFireworkTest if/when this gets changed.
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testPowerLimitExact() {
-        newFireworkMeta().setPower(MAX_FIREWORK_POWER + 1);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testPowerLimitMax() {
-        newFireworkMeta().setPower(Integer.MAX_VALUE);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testPowerLimitMin() {
-        newFireworkMeta().setPower(Integer.MIN_VALUE);
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testPowerLimitNegative() {
-        newFireworkMeta().setPower(-1);
-    }
-
-    @Test
-    public void testPowers() {
-        for (int i = 0; i <= MAX_FIREWORK_POWER; i++) {
-            FireworkMeta firework = newFireworkMeta();
-            firework.setPower(i);
-            assertThat(String.valueOf(i), firework.getPower(), is(i));
-        }
-    }
-
-    @Test
-    public void testConflictingEnchantment() {
-        ItemMeta itemMeta = Bukkit.getItemFactory().getItemMeta(Material.DIAMOND_PICKAXE);
-        assertThat(itemMeta.hasConflictingEnchant(Enchantment.DURABILITY), is(false));
-
-        itemMeta.addEnchant(Enchantment.SILK_TOUCH, 1, false);
-        assertThat(itemMeta.hasConflictingEnchant(Enchantment.DURABILITY), is(false));
-        assertThat(itemMeta.hasConflictingEnchant(Enchantment.LOOT_BONUS_BLOCKS), is(true));
-        assertThat(itemMeta.hasConflictingEnchant(null), is(false));
-    }
-
-    // Paper start
-    private void testItemMeta(ItemStack stack) {
-        assertThat("Should not have ItemMeta", stack.hasItemMeta(), is(false));
-
-        stack.setDurability((short) 0);
-        assertThat("ItemStack with zero durability should not have ItemMeta", stack.hasItemMeta(), is(false));
-
-        stack.setDurability((short) 2);
-        assertThat("ItemStack with non-zero durability should have ItemMeta", stack.hasItemMeta(), is(true));
-
-        stack.setLore(java.util.Collections.singletonList("Lore"));
-        assertThat("ItemStack with lore and durability should have ItemMeta", stack.hasItemMeta(), is(true));
-
-        stack.setDurability((short) 0);
-        assertThat("ItemStack with lore should have ItemMeta", stack.hasItemMeta(), is(true));
-
-        stack.setLore(null);
-    }
-
-    @Test
-    public void testHasItemMeta() {
-        ItemStack itemStack = new ItemStack(Material.SHEARS);
-
-        testItemMeta(itemStack);
-        testItemMeta(CraftItemStack.asCraftCopy(itemStack));
-    }
-    // Paper end
-
-    @Test
-    public void testConflictingStoredEnchantment() {
-        EnchantmentStorageMeta itemMeta = (EnchantmentStorageMeta) Bukkit.getItemFactory().getItemMeta(Material.ENCHANTED_BOOK);
-        assertThat(itemMeta.hasConflictingStoredEnchant(Enchantment.DURABILITY), is(false));
-
-        itemMeta.addStoredEnchant(Enchantment.SILK_TOUCH, 1, false);
-        assertThat(itemMeta.hasConflictingStoredEnchant(Enchantment.DURABILITY), is(false));
-        assertThat(itemMeta.hasConflictingStoredEnchant(Enchantment.LOOT_BONUS_BLOCKS), is(true));
-        assertThat(itemMeta.hasConflictingStoredEnchant(null), is(false));
-    }
-
-    @Test
-    public void testConflictingEnchantments() {
-        ItemMeta itemMeta = Bukkit.getItemFactory().getItemMeta(Material.DIAMOND_PICKAXE);
-        itemMeta.addEnchant(Enchantment.DURABILITY, 6, true);
-        itemMeta.addEnchant(Enchantment.DIG_SPEED, 6, true);
-        assertThat(itemMeta.hasConflictingEnchant(Enchantment.LOOT_BONUS_BLOCKS), is(false));
-
-        itemMeta.addEnchant(Enchantment.SILK_TOUCH, 1, false);
-        assertThat(itemMeta.hasConflictingEnchant(Enchantment.LOOT_BONUS_BLOCKS), is(true));
-        assertThat(itemMeta.hasConflictingEnchant(null), is(false));
-    }
-
-    @Test
-    public void testConflictingStoredEnchantments() {
-        EnchantmentStorageMeta itemMeta = (EnchantmentStorageMeta) Bukkit.getItemFactory().getItemMeta(Material.ENCHANTED_BOOK);
-        itemMeta.addStoredEnchant(Enchantment.DURABILITY, 6, true);
-        itemMeta.addStoredEnchant(Enchantment.DIG_SPEED, 6, true);
-        assertThat(itemMeta.hasConflictingStoredEnchant(Enchantment.LOOT_BONUS_BLOCKS), is(false));
-
-        itemMeta.addStoredEnchant(Enchantment.SILK_TOUCH, 1, false);
-        assertThat(itemMeta.hasConflictingStoredEnchant(Enchantment.LOOT_BONUS_BLOCKS), is(true));
-        assertThat(itemMeta.hasConflictingStoredEnchant(null), is(false));
-    }
-
-    private static FireworkMeta newFireworkMeta() {
-        return ((FireworkMeta) Bukkit.getItemFactory().getItemMeta(Material.FIREWORK_ROCKET));
-    }
-
-    @Test
-    public void testCrazyEquality() {
-        CraftItemStack craft = CraftItemStack.asCraftCopy(new ItemStack(Material.STONE));
-        craft.setItemMeta(craft.getItemMeta());
-        ItemStack bukkit = new ItemStack(craft);
-        assertThat(craft, is(bukkit));
-        assertThat(bukkit, is((ItemStack) craft));
-    }
-
-    @Test
-    public void testBlockStateMeta() {
-        List<Block> queue = new ArrayList<>();
-
-        for (Item item : IRegistry.ITEM) {
-            if (item instanceof ItemBlock) {
-                queue.add(((ItemBlock) item).getBlock());
-            }
-            if (item instanceof ItemBlockWallable) {
-                queue.add(((ItemBlockWallable) item).wallBlock);
-            }
-        }
-
-        for (Block block : queue) {
-            if (block != null) {
-                ItemStack stack = CraftItemStack.asNewCraftStack(Item.getItemOf(block));
-
-                // Command blocks aren't unit testable atm
-                if (stack.getType() == Material.COMMAND_BLOCK || stack.getType() == Material.CHAIN_COMMAND_BLOCK || stack.getType() == Material.REPEATING_COMMAND_BLOCK) {
-                    return;
-                }
-
-                ItemMeta meta = stack.getItemMeta();
-                if (block instanceof ITileEntity) {
-                    assertTrue(stack + " has meta of type " + meta + " expected BlockStateMeta", meta instanceof BlockStateMeta);
-
-                    BlockStateMeta blockState = (BlockStateMeta) meta;
-                    assertNotNull(stack + " has null block state", blockState.getBlockState());
-
-                    blockState.setBlockState(blockState.getBlockState());
-                } else {
-                    assertTrue(stack + " has unexpected meta of type BlockStateMeta (but is not a tile)", !(meta instanceof BlockStateMeta));
-                }
-            }
-        }
-    }
-
-    @Test
-    public void testEachExtraData() {
-        final List<StackProvider> providers = Arrays.asList(
-            new StackProvider(Material.WRITABLE_BOOK) {
-                @Override ItemStack operate(final ItemStack cleanStack) {
-                    final BookMeta meta = (BookMeta) cleanStack.getItemMeta();
-                    meta.setAuthor("Some author");
-                    meta.setPages("Page 1", "Page 2");
-                    meta.setTitle("A title");
-                    cleanStack.setItemMeta(meta);
-                    return cleanStack;
-                }
-            },
-            new StackProvider(Material.WRITTEN_BOOK) {
-                @Override ItemStack operate(final ItemStack cleanStack) {
-                    final BookMeta meta = (BookMeta) cleanStack.getItemMeta();
-                    meta.setAuthor("Some author");
-                    meta.setPages("Page 1", "Page 2");
-                    meta.setTitle("A title");
-                    cleanStack.setItemMeta(meta);
-                    return cleanStack;
-                }
-            },
-            /* Skulls rely on a running server instance
-            new StackProvider(Material.SKULL_ITEM) {
-                @Override ItemStack operate(final ItemStack cleanStack) {
-                    final SkullMeta meta = (SkullMeta) cleanStack.getItemMeta();
-                    meta.setOwner("Notch");
-                    cleanStack.setItemMeta(meta);
-                    return cleanStack;
-                }
-            },
-            */
-            new StackProvider(Material.FILLED_MAP) {
-                @Override ItemStack operate(final ItemStack cleanStack) {
-                    final MapMeta meta = (MapMeta) cleanStack.getItemMeta();
-                    meta.setScaling(true);
-                    cleanStack.setItemMeta(meta);
-                    return cleanStack;
-                }
-            },
-            new StackProvider(Material.LEATHER_BOOTS) {
-                @Override ItemStack operate(final ItemStack cleanStack) {
-                    final LeatherArmorMeta meta = (LeatherArmorMeta) cleanStack.getItemMeta();
-                    meta.setColor(Color.FUCHSIA);
-                    cleanStack.setItemMeta(meta);
-                    return cleanStack;
-                }
-            },
-            new StackProvider(Material.POTION) {
-                @Override ItemStack operate(final ItemStack cleanStack) {
-                    final PotionMeta meta = (PotionMeta) cleanStack.getItemMeta();
-                    meta.setBasePotionData(new PotionData(PotionType.UNCRAFTABLE, false, false));
-                    meta.addCustomEffect(PotionEffectType.CONFUSION.createEffect(1, 1), false);
-                    cleanStack.setItemMeta(meta);
-                    return cleanStack;
-                }
-            },
-            new StackProvider(Material.FIREWORK_ROCKET) {
-                @Override ItemStack operate(final ItemStack cleanStack) {
-                    final FireworkMeta meta = (FireworkMeta) cleanStack.getItemMeta();
-                    meta.addEffect(FireworkEffect.builder().withColor(Color.GREEN).withFade(Color.OLIVE).with(Type.BALL_LARGE).build());
-                    cleanStack.setItemMeta(meta);
-                    return cleanStack;
-                }
-            },
-            new StackProvider(Material.ENCHANTED_BOOK) {
-                @Override ItemStack operate(final ItemStack cleanStack) {
-                    final EnchantmentStorageMeta meta = (EnchantmentStorageMeta) cleanStack.getItemMeta();
-                    meta.addStoredEnchant(Enchantment.ARROW_FIRE, 1, true);
-                    cleanStack.setItemMeta(meta);
-                    return cleanStack;
-                }
-            },
-            new StackProvider(Material.FIREWORK_STAR) {
-                @Override ItemStack operate(final ItemStack cleanStack) {
-                    final FireworkEffectMeta meta = (FireworkEffectMeta) cleanStack.getItemMeta();
-                    meta.setEffect(FireworkEffect.builder().withColor(Color.MAROON, Color.BLACK).with(Type.CREEPER).withFlicker().build());
-                    cleanStack.setItemMeta(meta);
-                    return cleanStack;
-                }
-            },
-            new StackProvider(Material.WHITE_BANNER) {
-                @Override ItemStack operate(ItemStack cleanStack) {
-                    final BannerMeta meta = (BannerMeta) cleanStack.getItemMeta();
-                    meta.setBaseColor(DyeColor.CYAN);
-                    meta.addPattern(new Pattern(DyeColor.WHITE, PatternType.BRICKS));
-                    cleanStack.setItemMeta(meta);
-                    return cleanStack;
-                }
-            },
-            /* No distinguishing features, add back with virtual entity API
-            new StackProvider(Material.ZOMBIE_SPAWN_EGG) {
-                @Override ItemStack operate(ItemStack cleanStack) {
-                    final SpawnEggMeta meta = (SpawnEggMeta) cleanStack.getItemMeta();
-                    meta.setSpawnedType(EntityType.ZOMBIE);
-                    cleanStack.setItemMeta(meta);
-                    return cleanStack;
-                }
-            },
-            */
-            new StackProvider(Material.KNOWLEDGE_BOOK) {
-                @Override ItemStack operate(ItemStack cleanStack) {
-                    final KnowledgeBookMeta meta = (KnowledgeBookMeta) cleanStack.getItemMeta();
-                    meta.addRecipe(new NamespacedKey("minecraft", "test"), new NamespacedKey("plugin", "test"));
-                    cleanStack.setItemMeta(meta);
-                    return cleanStack;
-                }
-            },
-            new StackProvider(Material.TROPICAL_FISH_BUCKET) {
-                @Override ItemStack operate(ItemStack cleanStack) {
-                    final TropicalFishBucketMeta meta = (TropicalFishBucketMeta) cleanStack.getItemMeta();
-                    meta.setBodyColor(DyeColor.ORANGE);
-                    meta.setPatternColor(DyeColor.BLACK);
-                    meta.setPattern(TropicalFish.Pattern.DASHER);
-                    cleanStack.setItemMeta(meta);
-                    return cleanStack;
-                }
-            },
-            new StackProvider(Material.CROSSBOW) {
-                @Override ItemStack operate(ItemStack cleanStack) {
-                    final CrossbowMeta meta = (CrossbowMeta) cleanStack.getItemMeta();
-                    meta.addChargedProjectile(new ItemStack(Material.ARROW));
-                    cleanStack.setItemMeta(meta);
-                    return cleanStack;
-                }
-            },
-            new StackProvider(Material.ARMOR_STAND) {
-                @Override ItemStack operate(ItemStack cleanStack) {
-                    final CraftMetaArmorStand meta = (CraftMetaArmorStand) cleanStack.getItemMeta();
-                    meta.entityTag = new NBTTagCompound();
-                    meta.entityTag.setBoolean("Small", true);
-                    meta.setInvisible(true); // Paper
-                    cleanStack.setItemMeta(meta);
-                    return cleanStack;
-                }
-            },
-            new StackProvider(Material.SUSPICIOUS_STEW) {
-                @Override ItemStack operate(ItemStack cleanStack) {
-                    final CraftMetaSuspiciousStew meta = ((CraftMetaSuspiciousStew) cleanStack.getItemMeta());
-                    meta.addCustomEffect(PotionEffectType.CONFUSION.createEffect(1, 0), false);
-                    cleanStack.setItemMeta(meta);
-                    return cleanStack;
-                }
-            },
-            new StackProvider(Material.ITEM_FRAME) {
-                @Override ItemStack operate(ItemStack cleanStack) {
-                    final CraftMetaEntityTag meta = ((CraftMetaEntityTag) cleanStack.getItemMeta());
-                    meta.entityTag = new NBTTagCompound();
-                    meta.entityTag.setBoolean("Invisible", true);
-                    cleanStack.setItemMeta(meta);
-                    return cleanStack;
-                }
-            },
-            new StackProvider(Material.COMPASS) {
-                @Override ItemStack operate(ItemStack cleanStack) {
-                    final CraftMetaCompass meta = ((CraftMetaCompass) cleanStack.getItemMeta());
-                    meta.setLodestoneTracked(true);
-                    cleanStack.setItemMeta(meta);
-                    return cleanStack;
-                }
-            }
-        );
-
-        assertThat("Forgotten test?", providers, hasSize(ItemStackTest.COMPOUND_MATERIALS.length - 4/* Normal item meta, skulls, eggs and tile entities */));
-
-        for (final StackProvider provider : providers) {
-            downCastTest(new BukkitWrapper(provider));
-            downCastTest(new CraftWrapper(provider));
-        }
-    }
-
-    @Test
-    public void testAttributeModifiers() {
-        UUID sameUUID = UUID.randomUUID();
-        ItemMeta itemMeta = Bukkit.getItemFactory().getItemMeta(Material.DIAMOND_PICKAXE);
-        itemMeta.addAttributeModifier(Attribute.GENERIC_ATTACK_SPEED, new AttributeModifier(sameUUID, "Test Modifier", 10, AttributeModifier.Operation.ADD_NUMBER));
-
-        ItemMeta equalMeta = Bukkit.getItemFactory().getItemMeta(Material.DIAMOND_PICKAXE);
-        equalMeta.addAttributeModifier(Attribute.GENERIC_ATTACK_SPEED, new AttributeModifier(sameUUID, "Test Modifier", 10, AttributeModifier.Operation.ADD_NUMBER));
-
-        assertThat(itemMeta.equals(equalMeta), is(true));
-
-        ItemMeta itemMeta2 = Bukkit.getItemFactory().getItemMeta(Material.DIAMOND_PICKAXE);
-        itemMeta2.addAttributeModifier(Attribute.GENERIC_ATTACK_SPEED, new AttributeModifier(sameUUID, "Test Modifier", 10, AttributeModifier.Operation.ADD_NUMBER));
-
-        ItemMeta notEqualMeta2 = Bukkit.getItemFactory().getItemMeta(Material.DIAMOND_PICKAXE);
-        notEqualMeta2.addAttributeModifier(Attribute.GENERIC_ATTACK_SPEED, new AttributeModifier(sameUUID, "Test Modifier", 11, AttributeModifier.Operation.ADD_NUMBER));
-
-        assertThat(itemMeta2.equals(notEqualMeta2), is(false));
-    }
-
-    @Test
-    public void testBlockData() {
-        BlockDataMeta itemMeta = (BlockDataMeta) Bukkit.getItemFactory().getItemMeta(Material.CHEST);
-        itemMeta.setBlockData(CraftBlockData.newData(null, "minecraft:chest[waterlogged=true]"));
-        assertThat(itemMeta.getBlockData(Material.CHEST), is(CraftBlockData.newData(null, "minecraft:chest[waterlogged=true]")));
-    }
-
-    private void downCastTest(final StackWrapper provider) {
-        final String name = provider.toString();
-        final ItemStack blank = new ItemStack(Material.STONE);
-        final ItemStack craftBlank = CraftItemStack.asCraftCopy(blank);
-
-        // Check that equality and similarity works for each meta implementation
-        assertThat(name, provider.stack(), is(provider.stack()));
-        assertThat(name, provider.stack().isSimilar(provider.stack()), is(true));
-
-        downCastTest(name, provider.stack(), blank);
-        blank.setItemMeta(blank.getItemMeta());
-        downCastTest(name, provider.stack(), blank);
-
-        downCastTest(name, provider.stack(), craftBlank);
-        craftBlank.setItemMeta(craftBlank.getItemMeta());
-        downCastTest(name, provider.stack(), craftBlank);
-    }
-
-    private void downCastTest(final String name, final ItemStack stack, final ItemStack blank) {
-        assertThat(name, stack, is(not(blank)));
-        assertThat(name, stack.getItemMeta(), is(not(blank.getItemMeta())));
-
-        stack.setType(Material.STONE);
-
-        assertThat(name, stack, is(blank));
-    }
-}
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackBookTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackBookTest.java
deleted file mode 100644
index 7b107a3c3b22a028f887c27ae2953a6b6674e705..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackBookTest.java
+++ /dev/null
@@ -1,234 +0,0 @@
-package org.bukkit.craftbukkit.inventory;
-
-import com.google.common.base.Joiner;
-import java.util.Arrays;
-import java.util.List;
-import org.bukkit.Material;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.CompoundOperator;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.Operator;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.StackProvider;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.inventory.meta.BookMeta;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
-
-@RunWith(Parameterized.class)
-public class ItemStackBookTest extends ItemStackTest {
-
-    @Parameters(name = "[{index}]:{" + NAME_PARAMETER + "}")
-    public static List<Object[]> data() {
-        return StackProvider.compound(operators(), "%s %s", NAME_PARAMETER, Material.WRITTEN_BOOK, Material.WRITABLE_BOOK);
-    }
-
-    @SuppressWarnings("unchecked")
-    static List<Object[]> operators() {
-        return CompoundOperator.compound(
-            Joiner.on('+'),
-            NAME_PARAMETER,
-            Long.parseLong("1110", 2),
-            ItemStackLoreEnchantmentTest.operators(),
-            Arrays.asList(
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            BookMeta meta = (BookMeta) cleanStack.getItemMeta();
-                            meta.addPage("Page 1", "Page 2");
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            return cleanStack;
-                        }
-                    },
-                    "Pages vs. Null"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            BookMeta meta = (BookMeta) cleanStack.getItemMeta();
-                            meta.addPage("Page 1", "Page 2");
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            cleanStack.setItemMeta(cleanStack.getItemMeta());
-                            return cleanStack;
-                        }
-                    },
-                    "Pages vs. blank"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            BookMeta meta = (BookMeta) cleanStack.getItemMeta();
-                            meta.addPage("Page 1", "Page 2");
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            BookMeta meta = (BookMeta) cleanStack.getItemMeta();
-                            meta.addPage("Page 2", "Page 1");
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Pages switched"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            BookMeta meta = (BookMeta) cleanStack.getItemMeta();
-                            meta.addPage("Page 1", "Page 2");
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            BookMeta meta = (BookMeta) cleanStack.getItemMeta();
-                            meta.addPage("Page 1");
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Pages short"
-                }
-            ),
-            Arrays.asList(
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            BookMeta meta = (BookMeta) cleanStack.getItemMeta();
-                            meta.setAuthor("AnAuthor");
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            return cleanStack;
-                        }
-                    },
-                    "Author vs. Null"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            BookMeta meta = (BookMeta) cleanStack.getItemMeta();
-                            meta.setAuthor("AnAuthor");
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            cleanStack.setItemMeta(cleanStack.getItemMeta());
-                            return cleanStack;
-                        }
-                    },
-                    "Author vs. blank"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            BookMeta meta = (BookMeta) cleanStack.getItemMeta();
-                            meta.setAuthor("AnAuthor");
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            BookMeta meta = (BookMeta) cleanStack.getItemMeta();
-                            meta.setAuthor("AnotherAuthor");
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Authors"
-                }
-            ),
-            Arrays.asList(
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            BookMeta meta = (BookMeta) cleanStack.getItemMeta();
-                            meta.setTitle("Some title");
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            return cleanStack;
-                        }
-                    },
-                    "Title vs. Null"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            BookMeta meta = (BookMeta) cleanStack.getItemMeta();
-                            meta.setTitle("Some title");
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            cleanStack.setItemMeta(cleanStack.getItemMeta());
-                            return cleanStack;
-                        }
-                    },
-                    "title vs. blank"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            BookMeta meta = (BookMeta) cleanStack.getItemMeta();
-                            meta.setTitle("Some title");
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            BookMeta meta = (BookMeta) cleanStack.getItemMeta();
-                            meta.setTitle("Different title");
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Titles"
-                }
-            )
-        );
-    }
-}
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackEnchantStorageTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackEnchantStorageTest.java
deleted file mode 100644
index 349c9c8aabffa512feba3f3b6f6c5797652a6394..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackEnchantStorageTest.java
+++ /dev/null
@@ -1,117 +0,0 @@
-package org.bukkit.craftbukkit.inventory;
-
-import com.google.common.base.Joiner;
-import java.util.Arrays;
-import java.util.List;
-import org.bukkit.Material;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.CompoundOperator;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.Operator;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.StackProvider;
-import org.bukkit.enchantments.Enchantment;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.inventory.meta.EnchantmentStorageMeta;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
-
-@RunWith(Parameterized.class)
-public class ItemStackEnchantStorageTest extends ItemStackTest {
-
-    @Parameters(name = "[{index}]:{" + NAME_PARAMETER + "}")
-    public static List<Object[]> data() {
-        return StackProvider.compound(operators(), "%s %s", NAME_PARAMETER, Material.ENCHANTED_BOOK);
-    }
-
-    @SuppressWarnings("unchecked")
-    static List<Object[]> operators() {
-        return CompoundOperator.compound(
-            Joiner.on('+'),
-            NAME_PARAMETER,
-            Long.parseLong("10", 2),
-            ItemStackLoreEnchantmentTest.operators(),
-            Arrays.asList(
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            EnchantmentStorageMeta meta = (EnchantmentStorageMeta) cleanStack.getItemMeta();
-                            meta.addStoredEnchant(Enchantment.DURABILITY, 1, true);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            EnchantmentStorageMeta meta = (EnchantmentStorageMeta) cleanStack.getItemMeta();
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Enchantable vs Blank"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            EnchantmentStorageMeta meta = (EnchantmentStorageMeta) cleanStack.getItemMeta();
-                            meta.addStoredEnchant(Enchantment.KNOCKBACK, 1, true);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            return cleanStack;
-                        }
-                    },
-                    "Enchantable vs Null"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            EnchantmentStorageMeta meta = (EnchantmentStorageMeta) cleanStack.getItemMeta();
-                            meta.addStoredEnchant(Enchantment.DAMAGE_UNDEAD, 1, true);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            EnchantmentStorageMeta meta = (EnchantmentStorageMeta) cleanStack.getItemMeta();
-                            meta.addStoredEnchant(Enchantment.DAMAGE_UNDEAD, 1, true);
-                            meta.addStoredEnchant(Enchantment.FIRE_ASPECT, 1, true);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Enchantable vs More"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            EnchantmentStorageMeta meta = (EnchantmentStorageMeta) cleanStack.getItemMeta();
-                            meta.addStoredEnchant(Enchantment.PROTECTION_FIRE, 1, true);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            EnchantmentStorageMeta meta = (EnchantmentStorageMeta) cleanStack.getItemMeta();
-                            meta.addEnchant(Enchantment.PROTECTION_FIRE, 2, true);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Enchantable vs Other"
-                }
-            )
-        );
-    }
-}
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackFireworkChargeTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackFireworkChargeTest.java
deleted file mode 100644
index 989a67ed29057a32119c69af4c9c80984d0bc769..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackFireworkChargeTest.java
+++ /dev/null
@@ -1,139 +0,0 @@
-package org.bukkit.craftbukkit.inventory;
-
-import com.google.common.base.Joiner;
-import java.util.Arrays;
-import java.util.List;
-import org.bukkit.Color;
-import org.bukkit.FireworkEffect;
-import org.bukkit.FireworkEffect.Type;
-import org.bukkit.Material;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.CompoundOperator;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.Operator;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.StackProvider;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.inventory.meta.FireworkEffectMeta;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
-
-@RunWith(Parameterized.class)
-public class ItemStackFireworkChargeTest extends ItemStackTest {
-
-    @Parameters(name = "[{index}]:{" + NAME_PARAMETER + "}")
-    public static List<Object[]> data() {
-        return StackProvider.compound(operators(), "%s %s", NAME_PARAMETER, Material.FIREWORK_STAR);
-    }
-
-    @SuppressWarnings("unchecked")
-    static List<Object[]> operators() {
-        return CompoundOperator.compound(
-            Joiner.on('+'),
-            NAME_PARAMETER,
-            Long.parseLong("10", 2),
-            ItemStackLoreEnchantmentTest.operators(),
-            Arrays.asList(
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            FireworkEffectMeta meta = (FireworkEffectMeta) cleanStack.getItemMeta();
-                            meta.setEffect(FireworkEffect.builder().withColor(Color.WHITE).build());
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            FireworkEffectMeta meta = (FireworkEffectMeta) cleanStack.getItemMeta();
-                            meta.setEffect(FireworkEffect.builder().withColor(Color.BLACK).build());
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Effect Color 1 vs. Effect Color 2"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            FireworkEffectMeta meta = (FireworkEffectMeta) cleanStack.getItemMeta();
-                            meta.setEffect(FireworkEffect.builder().withColor(Color.WHITE).with(Type.CREEPER).build());
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            FireworkEffectMeta meta = (FireworkEffectMeta) cleanStack.getItemMeta();
-                            meta.setEffect(FireworkEffect.builder().withColor(Color.WHITE).with(Type.BURST).build());
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Effect type 1 vs. Effect type 2"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            FireworkEffectMeta meta = (FireworkEffectMeta) cleanStack.getItemMeta();
-                            meta.setEffect(FireworkEffect.builder().withColor(Color.WHITE).withFade(Color.BLUE).build());
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            FireworkEffectMeta meta = (FireworkEffectMeta) cleanStack.getItemMeta();
-                            meta.setEffect(FireworkEffect.builder().withColor(Color.WHITE).withFade(Color.RED).build());
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Effect fade 1 vs. Effect fade 2"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            FireworkEffectMeta meta = (FireworkEffectMeta) cleanStack.getItemMeta();
-                            meta.setEffect(FireworkEffect.builder().withColor(Color.WHITE).withFlicker().build());
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            FireworkEffectMeta meta = (FireworkEffectMeta) cleanStack.getItemMeta();
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Effect vs. Null"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            FireworkEffectMeta meta = (FireworkEffectMeta) cleanStack.getItemMeta();
-                            meta.setEffect(FireworkEffect.builder().withColor(Color.WHITE).withTrail().build());
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            return cleanStack;
-                        }
-                    },
-                    "Effect vs. None"
-                }
-            )
-        );
-    }
-}
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackFireworkTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackFireworkTest.java
deleted file mode 100644
index 028b7e3591718fad883572fe8ddb8df189b67dc6..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackFireworkTest.java
+++ /dev/null
@@ -1,201 +0,0 @@
-package org.bukkit.craftbukkit.inventory;
-
-import com.google.common.base.Joiner;
-import java.util.Arrays;
-import java.util.List;
-import org.bukkit.Color;
-import org.bukkit.FireworkEffect;
-import org.bukkit.FireworkEffect.Type;
-import org.bukkit.Material;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.CompoundOperator;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.Operator;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.StackProvider;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.inventory.meta.FireworkMeta;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
-
-@RunWith(Parameterized.class)
-public class ItemStackFireworkTest extends ItemStackTest {
-
-    @Parameters(name = "[{index}]:{" + NAME_PARAMETER + "}")
-    public static List<Object[]> data() {
-        return StackProvider.compound(operators(), "%s %s", NAME_PARAMETER, Material.FIREWORK_ROCKET);
-    }
-
-    @SuppressWarnings("unchecked")
-    static List<Object[]> operators() {
-        return CompoundOperator.compound(
-            Joiner.on('+'),
-            NAME_PARAMETER,
-            Long.parseLong("110", 2),
-            ItemStackLoreEnchantmentTest.operators(),
-            Arrays.asList(
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            FireworkMeta meta = (FireworkMeta) cleanStack.getItemMeta();
-                            meta.addEffect(FireworkEffect.builder().withColor(Color.WHITE).build());
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            FireworkMeta meta = (FireworkMeta) cleanStack.getItemMeta();
-                            meta.addEffect(FireworkEffect.builder().withColor(Color.BLACK).build());
-                            meta.addEffect(FireworkEffect.builder().withColor(Color.GREEN).build());
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Effect Color 1 vs. Effect Color 2"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            FireworkMeta meta = (FireworkMeta) cleanStack.getItemMeta();
-                            meta.addEffect(FireworkEffect.builder().withColor(Color.WHITE).with(Type.CREEPER).build());
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            FireworkMeta meta = (FireworkMeta) cleanStack.getItemMeta();
-                            meta.addEffect(FireworkEffect.builder().withColor(Color.WHITE).with(Type.BURST).build());
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Effect type 1 vs. Effect type 2"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            FireworkMeta meta = (FireworkMeta) cleanStack.getItemMeta();
-                            meta.addEffect(FireworkEffect.builder().withColor(Color.WHITE).withFade(Color.BLUE).build());
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            FireworkMeta meta = (FireworkMeta) cleanStack.getItemMeta();
-                            meta.addEffect(FireworkEffect.builder().withColor(Color.WHITE).withFade(Color.RED).build());
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Effect fade 1 vs. Effect fade 2"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            FireworkMeta meta = (FireworkMeta) cleanStack.getItemMeta();
-                            meta.addEffect(FireworkEffect.builder().withColor(Color.WHITE).withFlicker().build());
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            FireworkMeta meta = (FireworkMeta) cleanStack.getItemMeta();
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Effect vs. Null"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            FireworkMeta meta = (FireworkMeta) cleanStack.getItemMeta();
-                            meta.addEffect(FireworkEffect.builder().withColor(Color.WHITE).withTrail().build());
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            return cleanStack;
-                        }
-                    },
-                    "Effect vs. None"
-                }
-            ),
-            Arrays.asList(
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            FireworkMeta meta = (FireworkMeta) cleanStack.getItemMeta();
-                            meta.setPower(127);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            FireworkMeta meta = (FireworkMeta) cleanStack.getItemMeta();
-                            meta.setPower(100);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Height vs. Other"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            FireworkMeta meta = (FireworkMeta) cleanStack.getItemMeta();
-                            meta.setPower(42);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            FireworkMeta meta = (FireworkMeta) cleanStack.getItemMeta();
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Height vs. Null"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            FireworkMeta meta = (FireworkMeta) cleanStack.getItemMeta();
-                            meta.setPower(10);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            return cleanStack;
-                        }
-                    },
-                    "Height vs. None"
-                }
-            )
-        );
-    }
-}
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackLeatherTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackLeatherTest.java
deleted file mode 100644
index 99ec53dec9803a08fab4320e4a39cd2fd859d395..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackLeatherTest.java
+++ /dev/null
@@ -1,95 +0,0 @@
-package org.bukkit.craftbukkit.inventory;
-
-import com.google.common.base.Joiner;
-import java.util.Arrays;
-import java.util.List;
-import org.bukkit.Color;
-import org.bukkit.Material;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.CompoundOperator;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.Operator;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.StackProvider;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.inventory.meta.LeatherArmorMeta;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
-
-@RunWith(Parameterized.class)
-public class ItemStackLeatherTest extends ItemStackTest {
-
-    @Parameters(name = "[{index}]:{" + NAME_PARAMETER + "}")
-    public static List<Object[]> data() {
-        return StackProvider.compound(operators(), "%s %s", NAME_PARAMETER, Material.LEATHER_BOOTS, Material.LEATHER_CHESTPLATE, Material.LEATHER_HELMET, Material.LEATHER_LEGGINGS);
-    }
-
-    @SuppressWarnings("unchecked")
-    static List<Object[]> operators() {
-        return CompoundOperator.compound(
-            Joiner.on('+'),
-            NAME_PARAMETER,
-            Long.parseLong("10", 2),
-            ItemStackLoreEnchantmentTest.operators(),
-            Arrays.asList(
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            LeatherArmorMeta meta = (LeatherArmorMeta) cleanStack.getItemMeta();
-                            meta.setColor(Color.FUCHSIA);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            return cleanStack;
-                        }
-                    },
-                    "Color vs Null"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            LeatherArmorMeta meta = (LeatherArmorMeta) cleanStack.getItemMeta();
-                            meta.setColor(Color.GRAY);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            LeatherArmorMeta meta = (LeatherArmorMeta) cleanStack.getItemMeta();
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Color vs Blank"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            LeatherArmorMeta meta = (LeatherArmorMeta) cleanStack.getItemMeta();
-                            meta.setColor(Color.MAROON);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            LeatherArmorMeta meta = (LeatherArmorMeta) cleanStack.getItemMeta();
-                            meta.setColor(Color.ORANGE);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Color vs Other"
-                }
-            )
-        );
-    }
-}
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackLoreEnchantmentTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackLoreEnchantmentTest.java
deleted file mode 100644
index a9e3de37cc0b024e2fe2e1ea074c36b49b0b2f63..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackLoreEnchantmentTest.java
+++ /dev/null
@@ -1,328 +0,0 @@
-package org.bukkit.craftbukkit.inventory;
-
-import com.google.common.base.Joiner;
-import java.util.Arrays;
-import java.util.List;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.CompoundOperator;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.Operator;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.StackProvider;
-import org.bukkit.enchantments.Enchantment;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.inventory.meta.ItemMeta;
-import org.bukkit.inventory.meta.Repairable;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
-
-@RunWith(Parameterized.class)
-public class ItemStackLoreEnchantmentTest extends ItemStackTest {
-
-    @Parameters(name = "[{index}]:{" + NAME_PARAMETER + "}")
-    public static List<Object[]> data() {
-        return StackProvider.compound(operators(), "%s %s", NAME_PARAMETER, ItemStackTest.COMPOUND_MATERIALS);
-    }
-
-    @SuppressWarnings("unchecked")
-    static List<Object[]> operators() {
-        return CompoundOperator.compound(
-            Joiner.on('+'),
-            NAME_PARAMETER,
-            ~0L,
-            Arrays.asList(
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            ItemMeta meta = cleanStack.getItemMeta();
-                            meta.setLore(Arrays.asList("First Lore", "Second Lore"));
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            return cleanStack;
-                        }
-                    },
-                    "Lore vs Null"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            ItemMeta meta = cleanStack.getItemMeta();
-                            meta.setLore(Arrays.asList("Some lore"));
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            ItemMeta meta = cleanStack.getItemMeta();
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Lore vs Blank"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            ItemMeta meta = cleanStack.getItemMeta();
-                            meta.setLore(Arrays.asList("Some more lore", "Another lore"));
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            ItemMeta meta = cleanStack.getItemMeta();
-                            meta.setLore(Arrays.asList("Some more lore"));
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Lore vs Other"
-                }
-            ),
-            Arrays.asList(
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            ItemMeta meta = cleanStack.getItemMeta();
-                            meta.setDisplayName("TestItemName");
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            return cleanStack;
-                        }
-                    },
-                    "Name vs Null"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            ItemMeta meta = cleanStack.getItemMeta();
-                            meta.setDisplayName("AnotherItemName");
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            ItemMeta meta = cleanStack.getItemMeta();
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Name vs Blank"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            ItemMeta meta = cleanStack.getItemMeta();
-                            meta.setDisplayName("The original ItemName");
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            ItemMeta meta = cleanStack.getItemMeta();
-                            meta.setDisplayName("The other name");
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Name vs Other"
-                }
-            ),
-            Arrays.asList(
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            cleanStack.addUnsafeEnchantment(Enchantment.DIG_SPEED, 2);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            return cleanStack;
-                        }
-                    },
-                    "EnchantStack vs Null"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            cleanStack.addUnsafeEnchantment(Enchantment.OXYGEN, 1);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            ItemMeta meta = cleanStack.getItemMeta();
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "EnchantStack vs Blank"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            cleanStack.addUnsafeEnchantment(Enchantment.ARROW_DAMAGE, 1);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            cleanStack.addUnsafeEnchantment(Enchantment.ARROW_FIRE, 1);
-                            return cleanStack;
-                        }
-                    },
-                    "EnchantStack vs OtherEnchantStack"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            ItemMeta meta = cleanStack.getItemMeta();
-                            meta.addEnchant(Enchantment.DURABILITY, 1, true);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            ItemMeta meta = cleanStack.getItemMeta();
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Enchant vs Blank"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            ItemMeta meta = cleanStack.getItemMeta();
-                            meta.addEnchant(Enchantment.KNOCKBACK, 1, true);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            return cleanStack;
-                        }
-                    },
-                    "Enchant vs Null"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            ItemMeta meta = cleanStack.getItemMeta();
-                            meta.addEnchant(Enchantment.PROTECTION_FIRE, 1, true);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            ItemMeta meta = cleanStack.getItemMeta();
-                            meta.addEnchant(Enchantment.PROTECTION_FIRE, 2, true);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Enchant vs Other"
-                }
-            ),
-            Arrays.asList(
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            ItemMeta meta = cleanStack.getItemMeta();
-                            ((Repairable) meta).setRepairCost(42);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            return cleanStack;
-                        }
-                    },
-                    "Repair vs Null"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            ItemMeta meta = cleanStack.getItemMeta();
-                            ((Repairable) meta).setRepairCost(36);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            ItemMeta meta = cleanStack.getItemMeta();
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Repair vs Blank"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            ItemMeta meta = cleanStack.getItemMeta();
-                            ((Repairable) meta).setRepairCost(89);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            ItemMeta meta = cleanStack.getItemMeta();
-                            ((Repairable) meta).setRepairCost(88);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Repair vs Other"
-                }
-            )
-        );
-    }
-}
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackMapTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackMapTest.java
deleted file mode 100644
index 70285d999c791d4285528140b75e36a316927b3f..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackMapTest.java
+++ /dev/null
@@ -1,132 +0,0 @@
-package org.bukkit.craftbukkit.inventory;
-
-import com.google.common.base.Joiner;
-import java.util.Arrays;
-import java.util.List;
-import org.bukkit.Material;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.CompoundOperator;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.Operator;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.StackProvider;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.inventory.meta.MapMeta;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
-
-@RunWith(Parameterized.class)
-public class ItemStackMapTest extends ItemStackTest {
-
-    @Parameters(name = "[{index}]:{" + NAME_PARAMETER + "}")
-    public static List<Object[]> data() {
-        return StackProvider.compound(operators(), "%s %s", NAME_PARAMETER, Material.FILLED_MAP);
-    }
-
-    @SuppressWarnings("unchecked")
-    static List<Object[]> operators() {
-        return CompoundOperator.compound(
-            Joiner.on('+'),
-            NAME_PARAMETER,
-            Long.parseLong("10", 2),
-            ItemStackLoreEnchantmentTest.operators(),
-            Arrays.asList(
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            MapMeta meta = (MapMeta) cleanStack.getItemMeta();
-                            meta.setScaling(true);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            MapMeta meta = (MapMeta) cleanStack.getItemMeta();
-                            meta.setScaling(false);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Scale vs. Unscale"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            MapMeta meta = (MapMeta) cleanStack.getItemMeta();
-                            meta.setScaling(true);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            MapMeta meta = (MapMeta) cleanStack.getItemMeta();
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Scale vs. Blank"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            MapMeta meta = (MapMeta) cleanStack.getItemMeta();
-                            meta.setScaling(false);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            MapMeta meta = (MapMeta) cleanStack.getItemMeta();
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Unscale vs. Blank"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            MapMeta meta = (MapMeta) cleanStack.getItemMeta();
-                            meta.setScaling(true);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            return cleanStack;
-                        }
-                    },
-                    "Scale vs. None"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            MapMeta meta = (MapMeta) cleanStack.getItemMeta();
-                            meta.setScaling(false);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            return cleanStack;
-                        }
-                    },
-                    "Unscale vs. None"
-                }
-            )
-        );
-    }
-}
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackPotionsTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackPotionsTest.java
deleted file mode 100644
index cf2f3b5ab74078035a95f618979584548e24238d..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackPotionsTest.java
+++ /dev/null
@@ -1,159 +0,0 @@
-package org.bukkit.craftbukkit.inventory;
-
-import com.google.common.base.Joiner;
-import java.util.Arrays;
-import java.util.List;
-import org.bukkit.Material;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.CompoundOperator;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.Operator;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.StackProvider;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.inventory.meta.PotionMeta;
-import org.bukkit.potion.PotionEffectType;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
-
-@RunWith(Parameterized.class)
-public class ItemStackPotionsTest extends ItemStackTest {
-
-    @Parameters(name = "[{index}]:{" + NAME_PARAMETER + "}")
-    public static List<Object[]> data() {
-        return StackProvider.compound(operators(), "%s %s", NAME_PARAMETER, Material.POTION);
-    }
-
-    @SuppressWarnings("unchecked")
-    static List<Object[]> operators() {
-        return CompoundOperator.compound(
-            Joiner.on('+'),
-            NAME_PARAMETER,
-            Long.parseLong("10", 2),
-            ItemStackLoreEnchantmentTest.operators(),
-            Arrays.asList(
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            final PotionMeta meta = (PotionMeta) cleanStack.getItemMeta();
-                            meta.addCustomEffect(PotionEffectType.CONFUSION.createEffect(1, 1), false);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            return cleanStack;
-                        }
-                    },
-                    "Potion vs Null"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            final PotionMeta meta = (PotionMeta) cleanStack.getItemMeta();
-                            meta.addCustomEffect(PotionEffectType.HARM.createEffect(2, 1), false);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            final PotionMeta meta = (PotionMeta) cleanStack.getItemMeta();
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Potion vs Blank"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            final PotionMeta meta = (PotionMeta) cleanStack.getItemMeta();
-                            meta.addCustomEffect(PotionEffectType.SLOW_DIGGING.createEffect(1, 1), false);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            final PotionMeta meta = (PotionMeta) cleanStack.getItemMeta();
-                            meta.addCustomEffect(PotionEffectType.FAST_DIGGING.createEffect(1, 1), false);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Potion vs Harder"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            final PotionMeta meta = (PotionMeta) cleanStack.getItemMeta();
-                            meta.addCustomEffect(PotionEffectType.JUMP.createEffect(1, 1), false);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            final PotionMeta meta = (PotionMeta) cleanStack.getItemMeta();
-                            meta.addCustomEffect(PotionEffectType.JUMP.createEffect(1, 1), false);
-                            meta.addCustomEffect(PotionEffectType.REGENERATION.createEffect(1, 1), false);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Potion vs Better"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            final PotionMeta meta = (PotionMeta) cleanStack.getItemMeta();
-                            meta.addCustomEffect(PotionEffectType.SPEED.createEffect(10, 1), false);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            final PotionMeta meta = (PotionMeta) cleanStack.getItemMeta();
-                            meta.addCustomEffect(PotionEffectType.SPEED.createEffect(5, 1), false);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Potion vs Faster"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            final PotionMeta meta = (PotionMeta) cleanStack.getItemMeta();
-                            meta.addCustomEffect(PotionEffectType.INCREASE_DAMAGE.createEffect(1, 1), false);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            final PotionMeta meta = (PotionMeta) cleanStack.getItemMeta();
-                            meta.addCustomEffect(PotionEffectType.INCREASE_DAMAGE.createEffect(1, 2), false);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Potion vs Stronger"
-                }
-            )
-        );
-    }
-}
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackSkullTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackSkullTest.java
deleted file mode 100644
index 2040942bde810e2c37873a54fff8c0f12da8a510..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackSkullTest.java
+++ /dev/null
@@ -1,95 +0,0 @@
-package org.bukkit.craftbukkit.inventory;
-
-import com.google.common.base.Joiner;
-import java.util.Arrays;
-import java.util.List;
-import org.bukkit.Material;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.CompoundOperator;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.Operator;
-import org.bukkit.craftbukkit.inventory.ItemStackTest.StackProvider;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.inventory.meta.SkullMeta;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
-
-@RunWith(Parameterized.class)
-public class ItemStackSkullTest extends ItemStackTest {
-
-    @Parameters(name = "[{index}]:{" + NAME_PARAMETER + "}")
-    public static List<Object[]> data() {
-        return StackProvider.compound(operators(), "%s %s", NAME_PARAMETER, Material.PLAYER_HEAD);
-    }
-
-    @SuppressWarnings("unchecked")
-    static List<Object[]> operators() {
-        return CompoundOperator.compound(
-            Joiner.on('+'),
-            NAME_PARAMETER,
-            Long.parseLong("10", 2),
-            ItemStackLoreEnchantmentTest.operators(),
-            Arrays.asList(
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            SkullMeta meta = (SkullMeta) cleanStack.getItemMeta();
-                            meta.setOwner("Notch");
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            SkullMeta meta = (SkullMeta) cleanStack.getItemMeta();
-                            meta.setOwner("Dinnerbone");
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Name 1 vs. Name 2"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            SkullMeta meta = (SkullMeta) cleanStack.getItemMeta();
-                            meta.setOwner("Notch");
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            SkullMeta meta = (SkullMeta) cleanStack.getItemMeta();
-                            meta.setOwner(null);
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    "Name vs. Null"
-                },
-                new Object[] {
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            SkullMeta meta = (SkullMeta) cleanStack.getItemMeta();
-                            meta.setOwner("Notch");
-                            cleanStack.setItemMeta(meta);
-                            return cleanStack;
-                        }
-                    },
-                    new Operator() {
-                        @Override
-                        public ItemStack operate(ItemStack cleanStack) {
-                            return cleanStack;
-                        }
-                    },
-                    "Name vs. None"
-                }
-            )
-        );
-    }
-}
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackTest.java
deleted file mode 100644
index 1add9c7d39c9e02c9dcdfe14e204d9a1e32d68b0..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/inventory/ItemStackTest.java
+++ /dev/null
@@ -1,494 +0,0 @@
-package org.bukkit.craftbukkit.inventory;
-
-import static org.bukkit.support.Matchers.*;
-import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-import com.google.common.base.Joiner;
-import com.google.common.collect.ImmutableList;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import org.bukkit.Material;
-import org.bukkit.configuration.InvalidConfigurationException;
-import org.bukkit.configuration.file.YamlConfiguration;
-import org.bukkit.inventory.ItemFactory;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.inventory.meta.ItemMeta;
-import org.bukkit.support.AbstractTestingBase;
-import org.bukkit.util.io.BukkitObjectInputStream;
-import org.bukkit.util.io.BukkitObjectOutputStream;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameter;
-import org.junit.runners.Parameterized.Parameters;
-import org.yaml.snakeyaml.external.biz.base64Coder.Base64Coder;
-
-@RunWith(Parameterized.class)
-public class ItemStackTest extends AbstractTestingBase {
-    abstract static class StackProvider {
-        final Material material;
-
-        StackProvider(Material material) {
-            this.material = material;
-        }
-
-        ItemStack bukkit() {
-            return operate(cleanStack(material, false));
-        }
-
-        ItemStack craft() {
-            return operate(cleanStack(material, true));
-        }
-
-        abstract ItemStack operate(ItemStack cleanStack);
-
-        static ItemStack cleanStack(Material material, boolean craft) {
-            final ItemStack stack = new ItemStack(material);
-            return craft ? CraftItemStack.asCraftCopy(stack) : stack;
-        }
-
-        @Override
-        public String toString() {
-            return material.toString();
-        }
-
-        /**
-         * For each item in parameterList, it will apply nameFormat at nameIndex.
-         * For each item in parameterList for each item in materials, it will create a stack provider at each array index that contains an Operator.
-         *
-         * @param parameterList
-         * @param nameFormat
-         * @param nameIndex
-         * @param materials
-         * @return
-         */
-        static List<Object[]> compound(final List<Object[]> parameterList, final String nameFormat, final int nameIndex, final Material...materials) {
-            final List<Object[]> out = new ArrayList<Object[]>();
-            for (Object[] params : parameterList) {
-                final int len = params.length;
-                for (final Material material : materials) {
-                    final Object[] paramsOut = params.clone();
-                    for (int i = 0; i < len; i++) {
-                        final Object param = paramsOut[i];
-                        if (param instanceof Operator) {
-                            final Operator operator = (Operator) param;
-                            paramsOut[i] = new StackProvider(material) {
-                                @Override
-                                ItemStack operate(ItemStack cleanStack) {
-                                    return operator.operate(cleanStack);
-                                }
-                            };
-                        }
-                    }
-                    paramsOut[nameIndex] = String.format(nameFormat, paramsOut[nameIndex], material);
-                    out.add(paramsOut);
-                }
-            }
-            return out;
-        }
-    }
-
-    interface Operator {
-        ItemStack operate(ItemStack cleanStack);
-    }
-
-    static class CompoundOperator implements Operator {
-        static class RecursiveContainer {
-            final Joiner joiner;
-            final Object[] strings;
-            final int nameParameter;
-            final List<Object[]> stack;
-            final List<Object[]> out;
-            final List<Object[]>[] lists;
-
-            RecursiveContainer(Joiner joiner, Object[] strings, int nameParameter, List<Object[]> stack, List<Object[]> out, List<Object[]>[] lists) {
-                this.joiner = joiner;
-                this.strings = strings;
-                this.nameParameter = nameParameter;
-                this.stack = stack;
-                this.out = out;
-                this.lists = lists;
-            }
-        }
-        final Operator[] operators;
-
-        CompoundOperator(Operator...operators) {
-            this.operators = operators;
-        }
-
-        @Override
-        public ItemStack operate(ItemStack cleanStack) {
-            for (Operator operator : operators) {
-                operator.operate(cleanStack);
-            }
-            return cleanStack;
-        }
-
-        @Override
-        public String toString() {
-            return Arrays.toString(operators);
-        }
-
-
-        /**
-         * This combines different tests into one large collection, combining no two tests from the same list.
-         * @param joiner used to join names
-         * @param nameParameter index of the name parameter
-         * @param singletonBitmask a list of bits representing the 'singletons' located in your originalLists. Lowest order bits represent the first items in originalLists.
-         *      Singletons are exponentially linked with each other, such that,
-         *      the output will contain every unique subset of only items from the singletons,
-         *      as well as every unique subset that contains at least one item from each non-singleton.
-         * @param originalLists
-         * @return
-         */
-        static List<Object[]> compound(final Joiner joiner, final int nameParameter, final long singletonBitmask, final List<Object[]>...originalLists) {
-
-            final List<Object[]> out = new ArrayList<Object[]>();
-            final List<List<Object[]>> singletons = new ArrayList<List<Object[]>>();
-            final List<List<Object[]>> notSingletons = new ArrayList<List<Object[]>>();
-
-            { // Separate and prime the 'singletons'
-                int i = 0;
-                for (List<Object[]> list : originalLists) {
-                    (((singletonBitmask >>> i++) & 0x1) == 0x1 ? singletons : notSingletons).add(list);
-                }
-            }
-
-            for (final List<Object[]> primarySingleton : singletons) {
-                // Iterate over our singletons, to multiply the 'out' each time
-                for (final Object[] entry : out.toArray(EMPTY_ARRAY)) {
-                    // Iterate over a snapshot of 'out' to prevent CMEs / infinite iteration
-                    final int len = entry.length;
-                    for (final Object[] singleton : primarySingleton) {
-                        // Iterate over each item in our singleton for the current 'out' entry
-                        final Object[] toOut = entry.clone();
-                        for (int i = 0; i < len; i++) {
-                            // Iterate over each parameter
-                            if (i == nameParameter) {
-                                toOut[i] = joiner.join(toOut[i], singleton[i]);
-                            } else if (toOut[i] instanceof Operator) {
-                                final Operator op1 = (Operator) toOut[i];
-                                final Operator op2 = (Operator) singleton[i];
-                                toOut[i] = new Operator() {
-                                    @Override
-                                    public ItemStack operate(final ItemStack cleanStack) {
-                                        return op2.operate(op1.operate(cleanStack));
-                                    }
-                                };
-                            }
-                        }
-                        out.add(toOut);
-                    }
-                }
-                out.addAll(primarySingleton);
-            }
-
-            @SuppressWarnings("unchecked")
-            final List<Object[]>[] lists = new List[notSingletons.size() + 1];
-            notSingletons.toArray(lists);
-            lists[lists.length - 1] = out;
-
-            final RecursiveContainer methodParams = new RecursiveContainer(joiner, new Object[lists.length], nameParameter, new ArrayList<Object[]>(lists.length), new ArrayList<Object[]>(), lists);
-
-            recursivelyCompound(methodParams, 0);
-            methodParams.out.addAll(out);
-
-            return methodParams.out;
-        }
-
-        private static void recursivelyCompound(final RecursiveContainer methodParams, final int level) {
-            final List<Object[]> stack = methodParams.stack;
-
-            if (level == methodParams.lists.length) {
-                final Object[] firstParams = stack.get(0);
-                final int len = firstParams.length;
-                final int stackSize = stack.size();
-                final Object[] params = new Object[len];
-
-                for (int i = 0; i < len; i++) {
-                    final Object firstParam = firstParams[i];
-
-                    if (firstParam instanceof Operator) {
-                        final Operator[] operators = new Operator[stackSize];
-                        for (int j = 0; j < stackSize; j++) {
-                            operators[j] = (Operator) stack.get(j)[i];
-                        }
-
-                        params[i] = new CompoundOperator(operators);
-                    } else if (i == methodParams.nameParameter) {
-                        final Object[] strings = methodParams.strings;
-                        for (int j = 0; j < stackSize; j++) {
-                            strings[j] = stack.get(j)[i];
-                        }
-
-                        params[i] = methodParams.joiner.join(strings);
-                    } else {
-                        params[i] = firstParam;
-                    }
-                }
-
-                methodParams.out.add(params);
-            } else {
-                final int marker = stack.size();
-
-                for (final Object[] params : methodParams.lists[level]) {
-                    stack.add(params);
-                    recursivelyCompound(methodParams, level + 1);
-                    stack.remove(marker);
-                }
-            }
-        }
-    }
-
-    interface StackWrapper {
-        ItemStack stack();
-    }
-
-    static class CraftWrapper implements StackWrapper {
-        final StackProvider provider;
-
-        CraftWrapper(StackProvider provider) {
-            this.provider = provider;
-        }
-
-        @Override
-        public ItemStack stack() {
-            return provider.craft();
-        }
-
-        @Override
-        public String toString() {
-            return "Craft " + provider;
-        }
-    }
-
-    static class BukkitWrapper implements StackWrapper {
-        final StackProvider provider;
-
-        BukkitWrapper(StackProvider provider) {
-            this.provider = provider;
-        }
-
-        @Override
-        public ItemStack stack() {
-            return provider.bukkit();
-        }
-
-        @Override
-        public String toString() {
-            return "Bukkit " + provider;
-        }
-    }
-
-    static class NoOpProvider extends StackProvider {
-
-        NoOpProvider(Material material) {
-            super(material);
-        }
-
-        @Override
-        ItemStack operate(ItemStack cleanStack) {
-            return cleanStack;
-        }
-
-        @Override
-        public String toString() {
-            return "NoOp " + super.toString();
-        }
-    }
-
-    @Parameters(name = "[{index}]:{" + NAME_PARAMETER + "}")
-    public static List<Object[]> data() {
-        return ImmutableList.of(); // TODO, test basic durability issues
-    }
-
-    static final Object[][] EMPTY_ARRAY = new Object[0][];
-    /**
-     * Materials that generate unique item meta types.
-     */
-    static final Material[] COMPOUND_MATERIALS;
-    static final int NAME_PARAMETER = 2;
-    static {
-        final ItemFactory factory = CraftItemFactory.instance();
-        final Map<Class<? extends ItemMeta>, Material> possibleMaterials = new HashMap<Class<? extends ItemMeta>, Material>();
-        ItemMeta meta;
-        for (final Material material : Material.values()) {
-            meta = factory.getItemMeta(material);
-            if (meta == null || possibleMaterials.containsKey(meta.getClass()))
-                continue;
-            possibleMaterials.put(meta.getClass(), material);
-
-        }
-        COMPOUND_MATERIALS = possibleMaterials.values().toArray(new Material[possibleMaterials.size()]);
-    }
-
-    @Parameter(0) public StackProvider provider;
-    @Parameter(1) public StackProvider unequalProvider;
-    @Parameter(NAME_PARAMETER) public String name;
-
-    @Test
-    public void testBukkitInequality() {
-        final StackWrapper bukkitWrapper = new CraftWrapper(provider);
-        testInequality(bukkitWrapper, new BukkitWrapper(unequalProvider));
-        testInequality(bukkitWrapper, new BukkitWrapper(new NoOpProvider(provider.material)));
-    }
-
-    @Test
-    public void testCraftInequality() {
-        final StackWrapper craftWrapper = new CraftWrapper(provider);
-        testInequality(craftWrapper, new CraftWrapper(unequalProvider));
-        testInequality(craftWrapper, new CraftWrapper(new NoOpProvider(provider.material)));
-    }
-
-    @Test
-    public void testMixedInequality() {
-        final StackWrapper craftWrapper = new CraftWrapper(provider);
-        testInequality(craftWrapper, new BukkitWrapper(unequalProvider));
-        testInequality(craftWrapper, new BukkitWrapper(new NoOpProvider(provider.material)));
-
-        final StackWrapper bukkitWrapper = new CraftWrapper(provider);
-        testInequality(bukkitWrapper, new CraftWrapper(unequalProvider));
-        testInequality(bukkitWrapper, new CraftWrapper(new NoOpProvider(provider.material)));
-    }
-
-    static void testInequality(StackWrapper provider, StackWrapper unequalProvider) {
-        final ItemStack stack = provider.stack();
-        final ItemStack stack2 = provider.stack();
-        assertThat(stack, allOf(equalTo(stack), sameHash(stack)));
-        assertThat(stack, is(not(sameInstance(stack2))));
-        assertThat(stack, allOf(equalTo(stack2), sameHash(stack2)));
-
-        final ItemStack unequalStack = unequalProvider.stack();
-        final ItemStack unequalStack2 = unequalProvider.stack();
-        assertThat(unequalStack, allOf(equalTo(unequalStack), sameHash(unequalStack)));
-        assertThat(unequalStack, is(not(sameInstance(unequalStack2))));
-        assertThat(unequalStack, allOf(equalTo(unequalStack2), sameHash(unequalStack2)));
-
-        assertThat(stack, is(not(unequalStack)));
-        assertThat(unequalStack, is(not(stack)));
-
-        final ItemStack newStack = new ItemStack(stack2);
-        assertThat(newStack, allOf(equalTo(stack), sameHash(stack)));
-        assertThat(newStack, is(not(unequalStack)));
-        assertThat(newStack.getItemMeta(), allOf(equalTo(stack.getItemMeta()), sameHash(stack.getItemMeta())));
-        assertThat(newStack.getItemMeta(), is(not(unequalStack.getItemMeta())));
-
-        final ItemStack craftStack = CraftItemStack.asCraftCopy(stack2);
-        assertThat(craftStack, allOf(equalTo(stack), sameHash(stack)));
-        assertThat(craftStack, is(not(unequalStack)));
-        assertThat(craftStack.getItemMeta(), allOf(equalTo(stack.getItemMeta()), sameHash(stack.getItemMeta())));
-        assertThat(craftStack.getItemMeta(), is(not(unequalStack.getItemMeta())));
-
-        final ItemStack newUnequalStack = new ItemStack(unequalStack2);
-        assertThat(newUnequalStack, allOf(equalTo(unequalStack), sameHash(unequalStack)));
-        assertThat(newUnequalStack, is(not(stack)));
-        assertThat(newUnequalStack.getItemMeta(), allOf(equalTo(unequalStack.getItemMeta()), sameHash(unequalStack.getItemMeta())));
-        assertThat(newUnequalStack.getItemMeta(), is(not(stack.getItemMeta())));
-
-        final ItemStack newUnequalCraftStack = CraftItemStack.asCraftCopy(unequalStack2);
-        assertThat(newUnequalCraftStack, allOf(equalTo(unequalStack), sameHash(unequalStack)));
-        assertThat(newUnequalCraftStack, is(not(stack)));
-        assertThat(newUnequalCraftStack.getItemMeta(), allOf(equalTo(unequalStack.getItemMeta()), sameHash(unequalStack.getItemMeta())));
-        assertThat(newUnequalCraftStack.getItemMeta(), is(not(stack.getItemMeta())));
-    }
-
-    @Test
-    public void testBukkitYamlDeserialize() throws Throwable {
-        testYamlDeserialize(new BukkitWrapper(provider), new BukkitWrapper(unequalProvider));
-    }
-
-    @Test
-    public void testCraftYamlDeserialize() throws Throwable {
-        testYamlDeserialize(new CraftWrapper(provider), new CraftWrapper(unequalProvider));
-    }
-
-    @Test
-    public void testBukkitStreamDeserialize() throws Throwable {
-        testStreamDeserialize(new BukkitWrapper(provider), new BukkitWrapper(unequalProvider));
-    }
-
-    @Test
-    public void testCraftStreamDeserialize() throws Throwable {
-        testStreamDeserialize(new CraftWrapper(provider), new CraftWrapper(unequalProvider));
-    }
-
-    static void testStreamDeserialize(StackWrapper provider, StackWrapper unequalProvider) throws Throwable {
-        final ItemStack stack = provider.stack();
-        final ItemStack unequalStack = unequalProvider.stack();
-
-        ByteArrayOutputStream out = new ByteArrayOutputStream();
-        ObjectOutputStream oos = null;
-        try {
-            oos = new BukkitObjectOutputStream(out);
-
-            oos.writeObject(stack);
-            oos.writeObject(unequalStack);
-        } finally {
-            if (oos != null) {
-                try {
-                    oos.close();
-                } catch (IOException ex) {
-                }
-            }
-        }
-
-        final String data = new String(Base64Coder.encode(out.toByteArray()));
-
-        ObjectInputStream ois = null;
-
-        final ItemStack readFirst;
-        final ItemStack readSecond;
-
-        try {
-            ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());
-            ois = new BukkitObjectInputStream(in);
-
-            readFirst = (ItemStack) ois.readObject();
-            readSecond = (ItemStack) ois.readObject();
-        } finally {
-            if (ois != null) {
-                try {
-                    ois.close();
-                } catch (IOException ex) {
-                }
-            }
-        }
-
-        testEqualities(data, readFirst, readSecond, stack, unequalStack);
-    }
-
-    static void testYamlDeserialize(StackWrapper provider, StackWrapper unequalProvider) {
-        final ItemStack stack = provider.stack();
-        final ItemStack unequalStack = unequalProvider.stack();
-        final YamlConfiguration configOut = new YamlConfiguration();
-
-        configOut.set("provider", stack);
-        configOut.set("unequal", unequalStack);
-
-        final String out = '\n' + configOut.saveToString();
-        final YamlConfiguration configIn = new YamlConfiguration();
-
-        try {
-            configIn.loadFromString(out);
-        } catch (InvalidConfigurationException ex) {
-            throw new RuntimeException(out, ex);
-        }
-
-        testEqualities(out, configIn.getItemStack("provider"), configIn.getItemStack("unequal"), stack, unequalStack);
-    }
-
-    static void testEqualities(String information, ItemStack primaryRead, ItemStack unequalRead, ItemStack primaryOriginal, ItemStack unequalOriginal) {
-        assertThat(information, primaryRead, allOf(equalTo(primaryOriginal), sameHash(primaryOriginal)));
-        assertThat(information, unequalRead, allOf(equalTo(unequalOriginal), sameHash(unequalOriginal)));
-        assertThat(information, primaryRead, is(not(unequalOriginal)));
-        assertThat(information, primaryRead, is(not(unequalRead)));
-    }
-}
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/NMSCraftItemStackTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/NMSCraftItemStackTest.java
deleted file mode 100644
index 8718e457094d16eed92691a63ac22c8233f48f70..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/inventory/NMSCraftItemStackTest.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package org.bukkit.craftbukkit.inventory;
-
-import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-import net.minecraft.world.item.enchantment.Enchantments;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Test;
-
-public class NMSCraftItemStackTest extends AbstractTestingBase {
-
-    @Test
-    public void testCloneEnchantedItem() throws Exception {
-        net.minecraft.world.item.ItemStack nmsItemStack = new net.minecraft.world.item.ItemStack(net.minecraft.world.item.Items.POTION);
-        nmsItemStack.addEnchantment(Enchantments.DAMAGE_ALL, 1);
-        ItemStack itemStack = CraftItemStack.asCraftMirror(nmsItemStack);
-        ItemStack clone = itemStack.clone();
-        assertThat(clone.getType(), is(itemStack.getType()));
-        assertThat(clone.getAmount(), is(itemStack.getAmount()));
-        assertThat(clone.getDurability(), is(itemStack.getDurability()));
-        assertThat(clone.getEnchantments(), is(itemStack.getEnchantments()));
-        assertThat(clone.getData(), is(itemStack.getData()));
-        assertThat(clone, is(itemStack));
-    }
-
-    @Test
-    public void testCloneNullItem() throws Exception {
-        net.minecraft.world.item.ItemStack nmsItemStack = null;
-        ItemStack itemStack = CraftItemStack.asCraftMirror(nmsItemStack);
-        ItemStack clone = itemStack.clone();
-        assertThat(clone, is(itemStack));
-    }
-}
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/PersistentDataContainerTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/PersistentDataContainerTest.java
deleted file mode 100644
index ff9cc59c37ade5a75af48dfedf99b5e19e254b84..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/inventory/PersistentDataContainerTest.java
+++ /dev/null
@@ -1,329 +0,0 @@
-package org.bukkit.craftbukkit.inventory;
-
-import static org.junit.Assert.*;
-import java.io.StringReader;
-import java.lang.reflect.Array;
-import java.nio.ByteBuffer;
-import java.util.Map;
-import java.util.UUID;
-import net.minecraft.nbt.NBTTagCompound;
-import org.bukkit.Bukkit;
-import org.bukkit.Material;
-import org.bukkit.NamespacedKey;
-import org.bukkit.configuration.file.YamlConfiguration;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.inventory.meta.ItemMeta;
-import org.bukkit.persistence.PersistentDataAdapterContext;
-import org.bukkit.persistence.PersistentDataContainer;
-import org.bukkit.persistence.PersistentDataType;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Before;
-import org.junit.Test;
-
-public class PersistentDataContainerTest extends AbstractTestingBase {
-
-    private static NamespacedKey VALID_KEY;
-
-    @Before
-    public void setup() {
-        VALID_KEY = new NamespacedKey("test", "validkey");
-    }
-
-    /*
-        Sets a test
-     */
-    @Test(expected = IllegalArgumentException.class)
-    public void testSetNoAdapter() {
-        ItemMeta itemMeta = createNewItemMeta();
-        itemMeta.getPersistentDataContainer().set(VALID_KEY, new PrimitiveTagType<>(boolean.class), true);
-    }
-
-    /*
-        Contains a tag
-     */
-    @Test(expected = IllegalArgumentException.class)
-    public void testHasNoAdapter() {
-        ItemMeta itemMeta = createNewItemMeta();
-        itemMeta.getPersistentDataContainer().set(VALID_KEY, PersistentDataType.INTEGER, 1); // We gotta set this so we at least try to compare it
-        itemMeta.getPersistentDataContainer().has(VALID_KEY, new PrimitiveTagType<>(boolean.class));
-    }
-
-    /*
-        Getting a tag
-     */
-    @Test(expected = IllegalArgumentException.class)
-    public void testGetNoAdapter() {
-        ItemMeta itemMeta = createNewItemMeta();
-        itemMeta.getPersistentDataContainer().set(VALID_KEY, PersistentDataType.INTEGER, 1); //We gotta set this so we at least try to compare it
-        itemMeta.getPersistentDataContainer().get(VALID_KEY, new PrimitiveTagType<>(boolean.class));
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testGetWrongType() {
-        ItemMeta itemMeta = createNewItemMeta();
-        itemMeta.getPersistentDataContainer().set(VALID_KEY, PersistentDataType.INTEGER, 1);
-        itemMeta.getPersistentDataContainer().get(VALID_KEY, PersistentDataType.STRING);
-    }
-
-    @Test
-    public void testDifferentNamespace() {
-        NamespacedKey namespacedKeyA = new NamespacedKey("plugin-a", "damage");
-        NamespacedKey namespacedKeyB = new NamespacedKey("plugin-b", "damage");
-
-        ItemMeta meta = createNewItemMeta();
-        meta.getPersistentDataContainer().set(namespacedKeyA, PersistentDataType.LONG, 15L);
-        meta.getPersistentDataContainer().set(namespacedKeyB, PersistentDataType.LONG, 160L);
-
-        assertEquals(15L, (long) meta.getPersistentDataContainer().get(namespacedKeyA, PersistentDataType.LONG));
-        assertEquals(160L, (long) meta.getPersistentDataContainer().get(namespacedKeyB, PersistentDataType.LONG));
-    }
-
-    private ItemMeta createNewItemMeta() {
-        return Bukkit.getItemFactory().getItemMeta(Material.DIAMOND_PICKAXE);
-    }
-
-    private NamespacedKey requestKey(String keyName) {
-        return new NamespacedKey("test-plugin", keyName.toLowerCase());
-    }
-
-    /*
-        Removing a tag
-     */
-    @Test
-    public void testNBTTagStoring() {
-        CraftMetaItem itemMeta = createComplexItemMeta();
-
-        NBTTagCompound compound = new NBTTagCompound();
-        itemMeta.applyToItem(compound);
-
-        assertEquals(itemMeta, new CraftMetaItem(compound));
-    }
-
-    @Test
-    public void testMapStoring() {
-        CraftMetaItem itemMeta = createComplexItemMeta();
-
-        Map<String, Object> serialize = itemMeta.serialize();
-        assertEquals(itemMeta, new CraftMetaItem(serialize));
-    }
-
-    @Test
-    public void testYAMLStoring() {
-        ItemStack stack = new ItemStack(Material.DIAMOND);
-        CraftMetaItem meta = createComplexItemMeta();
-        stack.setItemMeta(meta);
-
-        YamlConfiguration configuration = new YamlConfiguration();
-        configuration.set("testpath", stack);
-
-        String configValue = configuration.saveToString();
-        YamlConfiguration loadedConfig = YamlConfiguration.loadConfiguration(new StringReader(configValue));
-
-        assertEquals(stack, loadedConfig.getSerializable("testpath", ItemStack.class));
-        assertNotEquals(new ItemStack(Material.DIAMOND), loadedConfig.getSerializable("testpath", ItemStack.class));
-    }
-
-    @Test
-    public void testCorrectType() {
-        ItemStack stack = new ItemStack(Material.DIAMOND);
-        CraftMetaItem meta = createComplexItemMeta();
-
-        meta.getPersistentDataContainer().set(requestKey("int"), PersistentDataType.STRING, "1");
-        meta.getPersistentDataContainer().set(requestKey("double"), PersistentDataType.STRING, "1.33");
-        stack.setItemMeta(meta);
-
-        YamlConfiguration configuration = new YamlConfiguration();
-        configuration.set("testpath", stack);
-
-        String configValue = configuration.saveToString();
-        YamlConfiguration loadedConfig = YamlConfiguration.loadConfiguration(new StringReader(configValue));
-        ItemStack newStack = loadedConfig.getSerializable("testpath", ItemStack.class);
-
-        assertTrue(newStack.getItemMeta().getPersistentDataContainer().has(requestKey("int"), PersistentDataType.STRING));
-        assertEquals(newStack.getItemMeta().getPersistentDataContainer().get(requestKey("int"), PersistentDataType.STRING), "1");
-
-        assertTrue(newStack.getItemMeta().getPersistentDataContainer().has(requestKey("double"), PersistentDataType.STRING));
-        assertEquals(newStack.getItemMeta().getPersistentDataContainer().get(requestKey("double"), PersistentDataType.STRING), "1.33");
-    }
-
-    private CraftMetaItem createComplexItemMeta() {
-        CraftMetaItem itemMeta = (CraftMetaItem) createNewItemMeta();
-        itemMeta.setDisplayName("Item Display Name");
-
-        itemMeta.getPersistentDataContainer().set(requestKey("custom-long"), PersistentDataType.LONG, 4L); //Add random primitive values
-        itemMeta.getPersistentDataContainer().set(requestKey("custom-byte-array"), PersistentDataType.BYTE_ARRAY, new byte[]{
-            0, 1, 2, 10
-        });
-        itemMeta.getPersistentDataContainer().set(requestKey("custom-string"), PersistentDataType.STRING, "Hello there world");
-        itemMeta.getPersistentDataContainer().set(requestKey("custom-int"), PersistentDataType.INTEGER, 3);
-        itemMeta.getPersistentDataContainer().set(requestKey("custom-double"), PersistentDataType.DOUBLE, 3.123);
-
-        PersistentDataContainer innerContainer = itemMeta.getPersistentDataContainer().getAdapterContext().newPersistentDataContainer(); //Add a inner container
-        innerContainer.set(VALID_KEY, PersistentDataType.LONG, 5L);
-        itemMeta.getPersistentDataContainer().set(requestKey("custom-inner-compound"), PersistentDataType.TAG_CONTAINER, innerContainer);
-        return itemMeta;
-    }
-
-    /*
-        Test complex object storage
-     */
-    @Test
-    public void storeUUIDOnItemTest() {
-        ItemMeta itemMeta = createNewItemMeta();
-        UUIDPersistentDataType uuidPersistentDataType = new UUIDPersistentDataType();
-        UUID uuid = UUID.fromString("434eea72-22a6-4c61-b5ef-945874a5c478");
-
-        itemMeta.getPersistentDataContainer().set(VALID_KEY, uuidPersistentDataType, uuid);
-        assertTrue(itemMeta.getPersistentDataContainer().has(VALID_KEY, uuidPersistentDataType));
-        assertEquals(uuid, itemMeta.getPersistentDataContainer().get(VALID_KEY, uuidPersistentDataType));
-    }
-
-    @Test
-    public void encapsulatedContainers() {
-        NamespacedKey innerKey = new NamespacedKey("plugin-a", "inner");
-
-        ItemMeta meta = createNewItemMeta();
-        PersistentDataAdapterContext context = meta.getPersistentDataContainer().getAdapterContext();
-
-        PersistentDataContainer thirdContainer = context.newPersistentDataContainer();
-        thirdContainer.set(VALID_KEY, PersistentDataType.LONG, 3L);
-
-        PersistentDataContainer secondContainer = context.newPersistentDataContainer();
-        secondContainer.set(VALID_KEY, PersistentDataType.LONG, 2L);
-        secondContainer.set(innerKey, PersistentDataType.TAG_CONTAINER, thirdContainer);
-
-        meta.getPersistentDataContainer().set(VALID_KEY, PersistentDataType.LONG, 1L);
-        meta.getPersistentDataContainer().set(innerKey, PersistentDataType.TAG_CONTAINER, secondContainer);
-
-        assertEquals(3L, meta.getPersistentDataContainer()
-                .get(innerKey, PersistentDataType.TAG_CONTAINER)
-                .get(innerKey, PersistentDataType.TAG_CONTAINER)
-                .get(VALID_KEY, PersistentDataType.LONG).longValue());
-
-        assertEquals(2L, meta.getPersistentDataContainer()
-                .get(innerKey, PersistentDataType.TAG_CONTAINER)
-                .get(VALID_KEY, PersistentDataType.LONG).longValue());
-
-        assertEquals(1L, meta.getPersistentDataContainer()
-                .get(VALID_KEY, PersistentDataType.LONG).longValue());
-    }
-
-    class UUIDPersistentDataType implements PersistentDataType<byte[], UUID> {
-
-        @Override
-        public Class<byte[]> getPrimitiveType() {
-            return byte[].class;
-        }
-
-        @Override
-        public Class<UUID> getComplexType() {
-            return UUID.class;
-        }
-
-        @Override
-        public byte[] toPrimitive(UUID complex, PersistentDataAdapterContext context) {
-            ByteBuffer bb = ByteBuffer.wrap(new byte[16]);
-            bb.putLong(complex.getMostSignificantBits());
-            bb.putLong(complex.getLeastSignificantBits());
-            return bb.array();
-        }
-
-        @Override
-        public UUID fromPrimitive(byte[] primitive, PersistentDataAdapterContext context) {
-            ByteBuffer bb = ByteBuffer.wrap(primitive);
-            long firstLong = bb.getLong();
-            long secondLong = bb.getLong();
-            return new UUID(firstLong, secondLong);
-        }
-    }
-
-    @Test
-    public void testPrimitiveCustomTags() {
-        ItemMeta itemMeta = createNewItemMeta();
-
-        testPrimitiveCustomTag(itemMeta, PersistentDataType.BYTE, (byte) 1);
-        testPrimitiveCustomTag(itemMeta, PersistentDataType.SHORT, (short) 1);
-        testPrimitiveCustomTag(itemMeta, PersistentDataType.INTEGER, 1);
-        testPrimitiveCustomTag(itemMeta, PersistentDataType.LONG, 1L);
-        testPrimitiveCustomTag(itemMeta, PersistentDataType.FLOAT, 1.34F);
-        testPrimitiveCustomTag(itemMeta, PersistentDataType.DOUBLE, 151.123);
-
-        testPrimitiveCustomTag(itemMeta, PersistentDataType.STRING, "test");
-
-        testPrimitiveCustomTag(itemMeta, PersistentDataType.BYTE_ARRAY, new byte[]{
-            1, 4, 2, Byte.MAX_VALUE
-        });
-        testPrimitiveCustomTag(itemMeta, PersistentDataType.INTEGER_ARRAY, new int[]{
-            1, 4, 2, Integer.MAX_VALUE
-        });
-        testPrimitiveCustomTag(itemMeta, PersistentDataType.LONG_ARRAY, new long[]{
-            1L, 4L, 2L, Long.MAX_VALUE
-        });
-    }
-
-    private <T, Z> void testPrimitiveCustomTag(ItemMeta meta, PersistentDataType<T, Z> type, Z value) {
-        NamespacedKey tagKey = new NamespacedKey("test", String.valueOf(type.hashCode()));
-
-        meta.getPersistentDataContainer().set(tagKey, type, value);
-        assertTrue(meta.getPersistentDataContainer().has(tagKey, type));
-
-        Z foundValue = meta.getPersistentDataContainer().get(tagKey, type);
-        if (foundValue.getClass().isArray()) { // Compare arrays using reflection access
-            int length = Array.getLength(foundValue);
-            int originalLength = Array.getLength(value);
-            for (int i = 0; i < length && i < originalLength; i++) {
-                assertEquals(Array.get(value, i), Array.get(foundValue, i));
-            }
-        } else {
-            assertEquals(foundValue, value);
-        }
-
-        meta.getPersistentDataContainer().remove(tagKey);
-        assertFalse(meta.getPersistentDataContainer().has(tagKey, type));
-    }
-
-    class PrimitiveTagType<T> implements PersistentDataType<T, T> {
-
-        private final Class<T> primitiveType;
-
-        PrimitiveTagType(Class<T> primitiveType) {
-            this.primitiveType = primitiveType;
-        }
-
-        @Override
-        public Class<T> getPrimitiveType() {
-            return primitiveType;
-        }
-
-        @Override
-        public Class<T> getComplexType() {
-            return primitiveType;
-        }
-
-        @Override
-        public T toPrimitive(T complex, PersistentDataAdapterContext context) {
-            return complex;
-        }
-
-        @Override
-        public T fromPrimitive(T primitive, PersistentDataAdapterContext context) {
-            return primitive;
-        }
-    }
-
-    @Test
-    public void testItemMetaClone() {
-        ItemMeta itemMeta = createNewItemMeta();
-        PersistentDataContainer container = itemMeta.getPersistentDataContainer();
-        itemMeta.getPersistentDataContainer().set(VALID_KEY, PersistentDataType.STRING, "notch");
-
-        ItemMeta clonedMeta = itemMeta.clone();
-        PersistentDataContainer clonedContainer = clonedMeta.getPersistentDataContainer();
-
-        assertNotSame(container, clonedContainer);
-        assertEquals(container, clonedContainer);
-
-        clonedContainer.set(VALID_KEY, PersistentDataType.STRING, "dinnerbone");
-        assertNotEquals(container, clonedContainer);
-    }
-}
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/PlayerInventoryTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/PlayerInventoryTest.java
deleted file mode 100644
index 724290302b90a4ba2b67a25b59fe63560fb7e686..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/inventory/PlayerInventoryTest.java
+++ /dev/null
@@ -1,77 +0,0 @@
-package org.bukkit.craftbukkit.inventory;
-
-import static org.junit.Assert.*;
-import net.minecraft.world.entity.player.PlayerInventory;
-import net.minecraft.world.item.ItemStack;
-import net.minecraft.world.item.Items;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Test;
-
-public class PlayerInventoryTest extends AbstractTestingBase {
-
-    @Test
-    public void testCanHold() throws Exception {
-        ItemStack itemStackApple = new ItemStack(Items.APPLE);
-        ItemStack itemStack1Coal = new ItemStack(Items.COAL);
-        ItemStack itemStack32Coal = new ItemStack(Items.COAL, 32);
-        ItemStack itemStack63Coal = new ItemStack(Items.COAL, 63);
-        ItemStack itemStack64Coal = new ItemStack(Items.COAL, 64);
-
-        // keep one slot empty
-        PlayerInventory inventory = new PlayerInventory(null);
-        for (int i = 0; i < inventory.items.size() - 1; i++) {
-            inventory.setItem(i, itemStackApple);
-        }
-
-        // one slot empty
-        assertEquals(1, inventory.canHold(itemStack1Coal));
-        assertEquals(32, inventory.canHold(itemStack32Coal));
-        assertEquals(64, inventory.canHold(itemStack64Coal));
-
-        // no free space with a stack of the item to check in the inventory
-        inventory.setItem(inventory.items.size() - 1, itemStack64Coal);
-
-        assertEquals(0, inventory.canHold(itemStack1Coal));
-        assertEquals(0, inventory.canHold(itemStack32Coal));
-        assertEquals(0, inventory.canHold(itemStack64Coal));
-
-        // no free space without a stack of the item to check in the inventory
-        inventory.setItem(inventory.items.size() - 1, itemStackApple);
-
-        assertEquals(0, inventory.canHold(itemStack1Coal));
-        assertEquals(0, inventory.canHold(itemStack32Coal));
-        assertEquals(0, inventory.canHold(itemStack64Coal));
-
-        // free space for 32 items in one slot
-        inventory.setItem(inventory.items.size() - 1, itemStack32Coal);
-
-        assertEquals(1, inventory.canHold(itemStack1Coal));
-        assertEquals(32, inventory.canHold(itemStack32Coal));
-        assertEquals(32, inventory.canHold(itemStack64Coal));
-
-        // free space for 1 item in two slots
-        inventory.setItem(inventory.items.size() - 1, itemStack63Coal);
-        inventory.setItem(inventory.items.size() - 2, itemStack63Coal);
-
-        assertEquals(1, inventory.canHold(itemStack1Coal));
-        assertEquals(2, inventory.canHold(itemStack32Coal));
-        assertEquals(2, inventory.canHold(itemStack64Coal));
-
-        // free space for 32 items in non-empty off-hand slot
-        inventory.setItem(inventory.items.size() - 1, itemStackApple);
-        inventory.setItem(inventory.items.size() - 2, itemStackApple);
-        inventory.setItem(inventory.items.size() + inventory.armor.size(), itemStack32Coal);
-
-        assertEquals(1, inventory.canHold(itemStack1Coal));
-        assertEquals(32, inventory.canHold(itemStack32Coal));
-        assertEquals(32, inventory.canHold(itemStack64Coal));
-
-        // free space for 1 item in non-empty off-hand slot and another slot
-        inventory.setItem(inventory.items.size() - 1, itemStack63Coal);
-        inventory.setItem(inventory.items.size() + inventory.armor.size(), itemStack63Coal);
-
-        assertEquals(1, inventory.canHold(itemStack1Coal));
-        assertEquals(2, inventory.canHold(itemStack32Coal));
-        assertEquals(2, inventory.canHold(itemStack64Coal));
-    }
-}
diff --git a/src/test/java/org/bukkit/craftbukkit/legacy/EvilTest.java b/src/test/java/org/bukkit/craftbukkit/legacy/EvilTest.java
deleted file mode 100644
index 23e5d98cf72d8bccd56087d71507036046cd1104..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/legacy/EvilTest.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package org.bukkit.craftbukkit.legacy;
-
-import org.bukkit.Material;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class EvilTest {
-
-    @Test
-    public void testFrom() {
-        Assert.assertEquals(Material.LEGACY_STONE, CraftEvil.getMaterial(1));
-    }
-
-    @Test
-    public void testTo() {
-        Assert.assertEquals(1, CraftEvil.getId(Material.LEGACY_STONE));
-    }
-
-    @Test(expected = IllegalArgumentException.class)
-    public void testIllegal() {
-        Material.STONE.getId();
-    }
-}
diff --git a/src/test/java/org/bukkit/craftbukkit/legacy/LegacyTest.java b/src/test/java/org/bukkit/craftbukkit/legacy/LegacyTest.java
deleted file mode 100644
index 5ce268bb253df25f7a51e3ed3a8d0b676666cf0f..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/legacy/LegacyTest.java
+++ /dev/null
@@ -1,128 +0,0 @@
-package org.bukkit.craftbukkit.legacy;
-
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.Set;
-import org.bukkit.Material;
-import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.bukkit.material.MaterialData;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class LegacyTest extends AbstractTestingBase {
-
-    private final Set<Material> INVALIDATED_MATERIALS = new HashSet<>(Arrays.asList(Material.ACACIA_BUTTON, Material.ACACIA_PRESSURE_PLATE, Material.ACACIA_TRAPDOOR, Material.AIR, Material.ATTACHED_MELON_STEM, Material.ATTACHED_PUMPKIN_STEM,
-            Material.BIRCH_BUTTON, Material.BIRCH_PRESSURE_PLATE, Material.BIRCH_TRAPDOOR, Material.BLACK_WALL_BANNER, Material.BLUE_WALL_BANNER, Material.BROWN_WALL_BANNER, Material.BUBBLE_COLUMN, Material.CAVE_AIR, Material.CREEPER_WALL_HEAD,
-            Material.CYAN_WALL_BANNER, Material.DARK_OAK_BUTTON, Material.DARK_OAK_PRESSURE_PLATE, Material.DARK_OAK_TRAPDOOR, Material.DARK_PRISMARINE_SLAB, Material.DARK_PRISMARINE_STAIRS, Material.DEBUG_STICK, Material.DONKEY_SPAWN_EGG,
-            Material.DRAGON_WALL_HEAD, Material.DRIED_KELP, Material.DRIED_KELP_BLOCK, Material.ELDER_GUARDIAN_SPAWN_EGG, Material.EVOKER_SPAWN_EGG, Material.GRAY_WALL_BANNER, Material.GREEN_WALL_BANNER, Material.HUSK_SPAWN_EGG,
-            Material.JUNGLE_BUTTON, Material.JUNGLE_PRESSURE_PLATE, Material.JUNGLE_TRAPDOOR, Material.KELP, Material.KELP_PLANT, Material.LIGHT_BLUE_WALL_BANNER, Material.LIGHT_GRAY_WALL_BANNER, Material.LIME_WALL_BANNER, Material.LLAMA_SPAWN_EGG,
-            Material.MAGENTA_WALL_BANNER, Material.MULE_SPAWN_EGG, Material.ORANGE_WALL_BANNER, Material.PARROT_SPAWN_EGG, Material.PHANTOM_SPAWN_EGG, Material.PINK_WALL_BANNER, Material.PLAYER_WALL_HEAD, Material.POLAR_BEAR_SPAWN_EGG,
-            Material.POTTED_ACACIA_SAPLING, Material.POTTED_ALLIUM, Material.POTTED_AZURE_BLUET, Material.POTTED_BIRCH_SAPLING, Material.POTTED_BLUE_ORCHID, Material.POTTED_BROWN_MUSHROOM, Material.POTTED_DANDELION, Material.POTTED_DARK_OAK_SAPLING,
-            Material.POTTED_DEAD_BUSH, Material.POTTED_FERN, Material.POTTED_JUNGLE_SAPLING, Material.POTTED_OAK_SAPLING, Material.POTTED_ORANGE_TULIP, Material.POTTED_OXEYE_DAISY, Material.POTTED_PINK_TULIP, Material.POTTED_POPPY,
-            Material.POTTED_RED_MUSHROOM, Material.POTTED_RED_TULIP, Material.POTTED_SPRUCE_SAPLING, Material.POTTED_WHITE_TULIP, Material.PRISMARINE_BRICK_SLAB, Material.PRISMARINE_BRICK_STAIRS, Material.PRISMARINE_SLAB, Material.PRISMARINE_STAIRS,
-            Material.PUMPKIN, Material.PURPLE_SHULKER_BOX, Material.PURPLE_WALL_BANNER, Material.RED_WALL_BANNER, Material.SEAGRASS, Material.SKELETON_HORSE_SPAWN_EGG, Material.SKELETON_WALL_SKULL, Material.SPRUCE_BUTTON, Material.SPRUCE_PRESSURE_PLATE, Material.SPRUCE_TRAPDOOR,
-            Material.STRAY_SPAWN_EGG, Material.STRIPPED_ACACIA_LOG, Material.STRIPPED_BIRCH_LOG, Material.STRIPPED_DARK_OAK_LOG, Material.STRIPPED_JUNGLE_LOG, Material.STRIPPED_OAK_LOG, Material.STRIPPED_SPRUCE_LOG, Material.TALL_SEAGRASS,
-            Material.TRIDENT, Material.TURTLE_EGG, Material.TURTLE_HELMET, Material.SCUTE, Material.TURTLE_SPAWN_EGG, Material.VEX_SPAWN_EGG, Material.VINDICATOR_SPAWN_EGG, Material.VOID_AIR, Material.WHITE_BED,
-            Material.WITHER_SKELETON_SPAWN_EGG, Material.WITHER_SKELETON_WALL_SKULL, Material.YELLOW_WALL_BANNER, Material.ZOMBIE_HORSE_SPAWN_EGG, Material.ZOMBIE_VILLAGER_SPAWN_EGG, Material.ZOMBIE_WALL_HEAD,
-            Material.COD_BUCKET, Material.COD_SPAWN_EGG, Material.PUFFERFISH_BUCKET, Material.PUFFERFISH_SPAWN_EGG, Material.SALMON_BUCKET, Material.SALMON_SPAWN_EGG,
-            Material.TROPICAL_FISH_BUCKET, Material.DROWNED_SPAWN_EGG, Material.TROPICAL_FISH_SPAWN_EGG,
-            Material.BLUE_ICE, Material.BRAIN_CORAL, Material.BRAIN_CORAL_BLOCK, Material.BRAIN_CORAL_FAN, Material.BUBBLE_CORAL, Material.BUBBLE_CORAL_BLOCK, Material.BUBBLE_CORAL_FAN, Material.CONDUIT, Material.DEAD_BRAIN_CORAL_BLOCK,
-            Material.DEAD_BUBBLE_CORAL_BLOCK, Material.DEAD_FIRE_CORAL_BLOCK, Material.DEAD_HORN_CORAL_BLOCK, Material.DEAD_TUBE_CORAL_BLOCK, Material.DOLPHIN_SPAWN_EGG, Material.FIRE_CORAL, Material.FIRE_CORAL_BLOCK, Material.FIRE_CORAL_FAN,
-            Material.HEART_OF_THE_SEA, Material.HORN_CORAL, Material.HORN_CORAL_BLOCK, Material.HORN_CORAL_FAN, Material.NAUTILUS_SHELL, Material.PHANTOM_MEMBRANE, Material.SEA_PICKLE, Material.TUBE_CORAL, Material.TUBE_CORAL_BLOCK,
-            Material.TUBE_CORAL_FAN, Material.STRIPPED_ACACIA_WOOD, Material.STRIPPED_BIRCH_WOOD, Material.STRIPPED_DARK_OAK_WOOD, Material.STRIPPED_JUNGLE_WOOD, Material.STRIPPED_OAK_WOOD, Material.STRIPPED_SPRUCE_WOOD,
-            Material.ACACIA_WOOD, Material.BIRCH_WOOD, Material.DARK_OAK_WOOD, Material.JUNGLE_WOOD, Material.OAK_WOOD, Material.SPRUCE_WOOD,
-            Material.TUBE_CORAL_WALL_FAN, Material.BRAIN_CORAL_WALL_FAN, Material.BUBBLE_CORAL_WALL_FAN, Material.FIRE_CORAL_WALL_FAN, Material.HORN_CORAL_WALL_FAN, Material.DEAD_TUBE_CORAL_WALL_FAN, Material.DEAD_BRAIN_CORAL_WALL_FAN,
-            Material.DEAD_BUBBLE_CORAL_WALL_FAN, Material.DEAD_FIRE_CORAL_WALL_FAN, Material.DEAD_HORN_CORAL_WALL_FAN, Material.DEAD_TUBE_CORAL_FAN, Material.DEAD_BRAIN_CORAL_FAN, Material.DEAD_BUBBLE_CORAL_FAN, Material.DEAD_FIRE_CORAL_FAN,
-            Material.DEAD_HORN_CORAL_FAN, Material.DEAD_BRAIN_CORAL, Material.DEAD_BUBBLE_CORAL, Material.DEAD_FIRE_CORAL, Material.DEAD_HORN_CORAL, Material.DEAD_TUBE_CORAL,
-            // 1.14
-            Material.ACACIA_SIGN, Material.ACACIA_WALL_SIGN, Material.ANDESITE_SLAB, Material.ANDESITE_STAIRS, Material.ANDESITE_WALL, Material.BAMBOO, Material.BAMBOO_SAPLING, Material.BARREL, Material.BELL, Material.BIRCH_SIGN, Material.BIRCH_WALL_SIGN,
-            Material.BLACK_DYE, Material.BLAST_FURNACE, Material.BLUE_DYE, Material.BRICK_WALL, Material.BROWN_DYE, Material.CAMPFIRE, Material.CARTOGRAPHY_TABLE, Material.CAT_SPAWN_EGG, Material.CORNFLOWER, Material.CREEPER_BANNER_PATTERN, Material.CROSSBOW,
-            Material.DARK_OAK_SIGN, Material.DARK_OAK_WALL_SIGN, Material.DIORITE_SLAB, Material.DIORITE_STAIRS, Material.DIORITE_WALL, Material.END_STONE_BRICK_SLAB, Material.END_STONE_BRICK_STAIRS, Material.END_STONE_BRICK_WALL, Material.FLETCHING_TABLE,
-            Material.FLOWER_BANNER_PATTERN, Material.GRANITE_SLAB, Material.GRANITE_STAIRS, Material.GRANITE_WALL, Material.GREEN_DYE, Material.GRINDSTONE, Material.RAVAGER_SPAWN_EGG, Material.JIGSAW, Material.JUNGLE_SIGN, Material.JUNGLE_WALL_SIGN,
-            Material.LANTERN, Material.LECTERN, Material.LILY_OF_THE_VALLEY, Material.LOOM, Material.MOJANG_BANNER_PATTERN, Material.MOSSY_COBBLESTONE_SLAB, Material.MOSSY_COBBLESTONE_STAIRS, Material.MOSSY_STONE_BRICK_SLAB, Material.MOSSY_STONE_BRICK_STAIRS,
-            Material.MOSSY_STONE_BRICK_WALL, Material.NETHER_BRICK_WALL, Material.OAK_SIGN, Material.OAK_WALL_SIGN, Material.PANDA_SPAWN_EGG, Material.PILLAGER_SPAWN_EGG, Material.POLISHED_ANDESITE_SLAB, Material.POLISHED_ANDESITE_STAIRS, Material.POLISHED_DIORITE_SLAB,
-            Material.POLISHED_DIORITE_STAIRS, Material.POLISHED_GRANITE_SLAB, Material.POLISHED_GRANITE_STAIRS, Material.POTTED_BAMBOO, Material.POTTED_CORNFLOWER, Material.POTTED_LILY_OF_THE_VALLEY, Material.POTTED_WITHER_ROSE, Material.PRISMARINE_WALL, Material.RED_DYE,
-            Material.RED_NETHER_BRICK_SLAB, Material.RED_NETHER_BRICK_STAIRS, Material.RED_NETHER_BRICK_WALL, Material.RED_SANDSTONE_WALL, Material.SANDSTONE_WALL, Material.SCAFFOLDING, Material.SKULL_BANNER_PATTERN, Material.SMITHING_TABLE, Material.SMOKER,
-            Material.SMOOTH_QUARTZ_SLAB, Material.SMOOTH_QUARTZ_STAIRS, Material.SMOOTH_RED_SANDSTONE_SLAB, Material.SMOOTH_RED_SANDSTONE_STAIRS, Material.SMOOTH_SANDSTONE_SLAB, Material.SMOOTH_SANDSTONE_STAIRS, Material.STONE_SLAB, Material.SPRUCE_SIGN,
-            Material.SPRUCE_WALL_SIGN, Material.STONECUTTER, Material.STONE_BRICK_WALL, Material.STONE_STAIRS, Material.SUSPICIOUS_STEW, Material.SWEET_BERRIES, Material.SWEET_BERRY_BUSH, Material.WHITE_DYE, Material.WITHER_ROSE, Material.YELLOW_DYE,
-            Material.COMPOSTER, Material.TRADER_LLAMA_SPAWN_EGG, Material.WANDERING_TRADER_SPAWN_EGG, Material.FOX_SPAWN_EGG, Material.LEATHER_HORSE_ARMOR, Material.GLOBE_BANNER_PATTERN, Material.CUT_RED_SANDSTONE_SLAB, Material.CUT_SANDSTONE_SLAB,
-            // 1.15
-            Material.BEEHIVE, Material.BEE_NEST, Material.BEE_SPAWN_EGG, Material.HONEYCOMB, Material.HONEYCOMB_BLOCK, Material.HONEY_BLOCK, Material.HONEY_BOTTLE,
-            // 1.16
-            Material.ANCIENT_DEBRIS, Material.BASALT, Material.CRIMSON_BUTTON, Material.CRIMSON_DOOR, Material.CRIMSON_FENCE, Material.CRIMSON_FENCE_GATE, Material.CRIMSON_NYLIUM, Material.CRIMSON_PLANKS, Material.CRIMSON_PRESSURE_PLATE,
-            Material.CRIMSON_ROOTS, Material.CRIMSON_SIGN, Material.CRIMSON_SLAB, Material.CRIMSON_STAIRS, Material.CRIMSON_STEM, Material.CRIMSON_TRAPDOOR, Material.CRIMSON_WALL_SIGN, Material.HOGLIN_SPAWN_EGG, Material.NETHERITE_AXE, Material.NETHERITE_BLOCK,
-            Material.NETHERITE_BOOTS, Material.NETHERITE_CHESTPLATE, Material.NETHERITE_HELMET, Material.NETHERITE_HOE, Material.NETHERITE_INGOT, Material.NETHERITE_LEGGINGS, Material.NETHERITE_PICKAXE, Material.NETHERITE_SCRAP, Material.NETHERITE_SHOVEL,
-            Material.NETHERITE_SWORD, Material.NETHER_SPROUTS, Material.PIGLIN_SPAWN_EGG, Material.SHROOMLIGHT, Material.SOUL_FIRE, Material.SOUL_LANTERN, Material.SOUL_TORCH, Material.SOUL_WALL_TORCH, Material.SOUL_SOIL, Material.STRIPPED_CRIMSON_STEM,
-            Material.STRIPPED_WARPED_STEM, Material.WARPED_BUTTON, Material.WARPED_DOOR, Material.WARPED_FENCE, Material.WARPED_FENCE_GATE, Material.WARPED_FUNGUS, Material.WARPED_NYLIUM, Material.WARPED_PLANKS, Material.WARPED_PRESSURE_PLATE, Material.WARPED_ROOTS,
-            Material.WARPED_SIGN, Material.WARPED_SLAB, Material.WARPED_STAIRS, Material.WARPED_STEM, Material.WARPED_TRAPDOOR, Material.WARPED_WALL_SIGN, Material.WARPED_WART_BLOCK, Material.WEEPING_VINES, Material.WEEPING_VINES_PLANT,
-            Material.CRIMSON_FUNGUS, Material.CRIMSON_HYPHAE, Material.CRYING_OBSIDIAN, Material.NETHER_GOLD_ORE, Material.POLISHED_BASALT, Material.POTTED_CRIMSON_FUNGUS, Material.POTTED_CRIMSON_ROOTS, Material.POTTED_WARPED_FUNGUS, Material.POTTED_WARPED_ROOTS,
-            Material.RESPAWN_ANCHOR, Material.SLIME_SPAWN_EGG, Material.STRIPPED_CRIMSON_HYPHAE, Material.STRIPPED_WARPED_HYPHAE, Material.TARGET, Material.TWISTING_VINES, Material.TWISTING_VINES_PLANT, Material.WARPED_FUNGUS, Material.WARPED_HYPHAE,
-            Material.BLACKSTONE, Material.BLACKSTONE_SLAB, Material.BLACKSTONE_STAIRS, Material.BLACKSTONE_WALL, Material.CHISELED_NETHER_BRICKS, Material.CHISELED_POLISHED_BLACKSTONE, Material.CRACKED_NETHER_BRICKS, Material.CRACKED_POLISHED_BLACKSTONE_BRICKS,
-            Material.GILDED_BLACKSTONE, Material.LODESTONE, Material.PIGLIN_BANNER_PATTERN, Material.POLISHED_BLACKSTONE, Material.POLISHED_BLACKSTONE_BRICKS, Material.POLISHED_BLACKSTONE_BRICK_SLAB, Material.POLISHED_BLACKSTONE_BRICK_STAIRS,
-            Material.POLISHED_BLACKSTONE_BRICK_WALL, Material.POLISHED_BLACKSTONE_BUTTON, Material.POLISHED_BLACKSTONE_PRESSURE_PLATE, Material.POLISHED_BLACKSTONE_SLAB, Material.POLISHED_BLACKSTONE_STAIRS, Material.POLISHED_BLACKSTONE_WALL, Material.QUARTZ_BRICKS,
-            Material.SOUL_CAMPFIRE, Material.STRIDER_SPAWN_EGG, Material.WARPED_FUNGUS_ON_A_STICK, Material.ZOGLIN_SPAWN_EGG, Material.CHAIN, Material.MUSIC_DISC_PIGSTEP,
-            // 1.16.2
-            Material.PIGLIN_BRUTE_SPAWN_EGG,
-            //
-            Material.LEGACY_AIR, Material.LEGACY_DEAD_BUSH, Material.LEGACY_BURNING_FURNACE, Material.LEGACY_WALL_SIGN, Material.LEGACY_REDSTONE_TORCH_OFF, Material.LEGACY_SKULL, Material.LEGACY_REDSTONE_COMPARATOR_ON, Material.LEGACY_WALL_BANNER, Material.LEGACY_MONSTER_EGG));
-
-    private final Set<Material> INVERSION_FAILS = new HashSet<>(Arrays.asList(Material.LEGACY_DOUBLE_STEP, Material.LEGACY_GLOWING_REDSTONE_ORE, Material.LEGACY_DIODE_BLOCK_ON, Material.LEGACY_REDSTONE_LAMP_ON, Material.LEGACY_WOOD_DOUBLE_STEP,
-            Material.LEGACY_DAYLIGHT_DETECTOR_INVERTED, Material.LEGACY_DOUBLE_STONE_SLAB2, Material.LEGACY_PURPUR_DOUBLE_SLAB, Material.LEGACY_WHEAT, Material.LEGACY_SIGN, Material.LEGACY_WOOD_DOOR, Material.LEGACY_IRON_DOOR, Material.LEGACY_SUGAR_CANE,
-            Material.LEGACY_CAKE, Material.LEGACY_BED, Material.LEGACY_DIODE, Material.LEGACY_NETHER_STALK, Material.LEGACY_BREWING_STAND_ITEM, Material.LEGACY_CAULDRON_ITEM, Material.LEGACY_REDSTONE_COMPARATOR, Material.LEGACY_SPRUCE_DOOR_ITEM,
-            Material.LEGACY_BIRCH_DOOR_ITEM, Material.LEGACY_JUNGLE_DOOR_ITEM, Material.LEGACY_ACACIA_DOOR_ITEM, Material.LEGACY_DARK_OAK_DOOR_ITEM, Material.LEGACY_STATIONARY_LAVA, Material.LEGACY_STATIONARY_WATER));
-
-    @Test
-    public void toLegacyMaterial() {
-        for (Material material : Material.values()) {
-            if (!INVALIDATED_MATERIALS.contains(material) && !material.isLegacy()) {
-                MaterialData converted = CraftLegacy.toLegacyData(material);
-
-                Assert.assertNotEquals("Could not toLegacy " + material, Material.LEGACY_AIR, converted.getItemType());
-
-                if (!INVALIDATED_MATERIALS.contains(converted.getItemType())) {
-                    Assert.assertNotEquals("Could not fromLegacy(toLegacy) " + converted + "(" + material + ")", Material.AIR, CraftLegacy.fromLegacy(converted));
-                }
-                if (!INVERSION_FAILS.contains(material)) {
-                    Assert.assertEquals("Could not fromLegacy(toLegacy) " + converted + "(" + material + ")", material, CraftLegacy.fromLegacy(converted));
-                }
-            }
-        }
-
-        Assert.assertEquals("Could not toLegacy Air", Material.LEGACY_AIR, CraftLegacy.toLegacy(Material.AIR));
-    }
-
-    @Test
-    public void fromLegacyMaterial() {
-        for (Material material : Material.values()) {
-            if (!INVALIDATED_MATERIALS.contains(material) && material.isLegacy()) {
-                Material converted = CraftLegacy.fromLegacy(material);
-                Assert.assertNotEquals("Could not fromLegacy " + material, Material.AIR, converted);
-
-                Assert.assertNotEquals("Could not toLegacy(fromLegacy) " + converted + "(" + material + ")", Material.AIR, CraftLegacy.toLegacy(converted));
-                if (!INVERSION_FAILS.contains(material)) {
-                    Assert.assertEquals("Could not toLegacy(fromLegacy) " + converted + "(" + material + ")", material, CraftLegacy.toLegacy(converted));
-                }
-            }
-        }
-
-        Assert.assertEquals("Could not fromLegacy Air", Material.AIR, CraftLegacy.fromLegacy(Material.LEGACY_AIR));
-    }
-
-    @Test
-    public void testRestricted() {
-        for (Material material : CraftLegacy.values()) {
-            Assert.assertTrue("Must iterate only legacy materials", material.isLegacy());
-        }
-
-        for (Material material : org.bukkit.craftbukkit.util.CraftLegacy.modern_values()) {
-            Assert.assertFalse("Must iterate only modern materials", material.isLegacy());
-        }
-    }
-
-    @Test
-    public void testManual() {
-        Assert.assertEquals(Material.YELLOW_DYE, CraftMagicNumbers.INSTANCE.getMaterial("dandelion_yellow", 1631));
-        Assert.assertEquals(Material.OAK_WALL_SIGN, CraftMagicNumbers.INSTANCE.getMaterial("wall_sign", 1631));
-    }
-}
diff --git a/src/test/java/org/bukkit/craftbukkit/util/CraftChatMessageTest.java b/src/test/java/org/bukkit/craftbukkit/util/CraftChatMessageTest.java
deleted file mode 100644
index acbaa8206b89d79a9ee9a79055b8c934ed2def49..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/craftbukkit/util/CraftChatMessageTest.java
+++ /dev/null
@@ -1,114 +0,0 @@
-package org.bukkit.craftbukkit.util;
-
-import static org.junit.Assert.*;
-import net.minecraft.network.chat.ChatComponentText;
-import net.minecraft.network.chat.IChatBaseComponent;
-import net.minecraft.network.chat.IChatMutableComponent;
-import org.junit.Test;
-
-public class CraftChatMessageTest {
-
-    @Test
-    public void testSimpleStrings() {
-        // These should be able to go from legacy to comp to legacy back without data changing
-        testString("fFoo");
-        testString("fFoofl"); // Keeps empty format at end
-        testString("Foo");
-        // testString("roFoo"); // Retains reset at start (item names can use this to get rid of italics)
-        testString("FoobBar");
-        testString("FlooboBablr"); // any non color formatting code implies previous color code.
-        // So l at start has no inherited color code, so that's fine, but the one at the end,
-        // while Bal would work visually, serializing back will include the implied color
-
-        testString("FloorBalr"); // But if reset was used before.... then it can be standalone
-        testString("fFoobBar");
-        testString("fFoobBarrBaz");
-    }
-
-    @Test
-    public void testNewLineBehavior() {
-        // new line retain should stay as 1 comp
-        testString("Hello0\nrFoo\n5Test", true);
-        testString("0Foo!\n", true);
-        testString("0Foo!0\\n0\\n0Bar\n", true);
-
-        // dont retain line returns multiple components
-        IChatBaseComponent[] components = CraftChatMessage.fromString("Hello0\nrFoo\n5Test");
-        assertEquals("Has 3 components", 3, components.length);
-        assertEquals("Hello0", CraftChatMessage.fromComponent(components[0]));
-        assertEquals(/*r*/"Foo", CraftChatMessage.fromComponent(components[1]));
-        assertEquals("5Test", CraftChatMessage.fromComponent(components[2]));
-    }
-
-    @Test
-    public void testComponents() {
-        testComponent("FoobBarrBaz", create("Foo", "bBar", "Baz"));
-        testComponent("fFoobBarrBaz", create("", "fFoo", "bBar", "Baz"));
-        testComponent("fFoobBarrBaz", create("", "fFoo", "bBar", "", "Baz"));
-        testComponent("fFoobBarrBaz", create("fFoo", "bBar", "Baz"));
-        testComponent("FoobBarrBaz", create("", "Foo", "bBar", "Baz"));
-        testComponent("fFoobBarrBaz", create("fFoo", "bBar", "Baz"));
-        testComponent("FfoobBarrBaz", create("Ffoo", "bBar", "Baz"));
-    }
-
-    @Test
-    public void testPlainText() {
-        testPlainString("");
-        testPlainString("FoofmBar0");
-        testPlainString("Link to https://www.spigotmc.org/ ...");
-        testPlainString("Link to http://www.spigotmc.org/ ...");
-        testPlainString("Link to www.spigotmc.org ...");
-    }
-
-    private IChatBaseComponent create(String txt, String... rest) {
-        IChatMutableComponent cmp = CraftChatMessage.fromString(txt, false)[0].mutableCopy();
-        for (String s : rest) {
-            cmp.addSibling(CraftChatMessage.fromString(s, true)[0]);
-        }
-
-        return cmp;
-    }
-
-    private void testString(String expected) {
-        testString(expected, false);
-    }
-
-    private void testString(String expected, boolean keepNewLines) {
-        testString(expected, expected, keepNewLines);
-    }
-
-    private void testString(String input, String expected) {
-        testString(input, expected, false);
-    }
-
-    private void testString(String input, String expected, boolean keepNewLines) {
-        IChatBaseComponent cmp = CraftChatMessage.fromString(input, keepNewLines)[0];
-        String actual = CraftChatMessage.fromComponent(cmp);
-        assertEquals("\nComponent: " + cmp + "\n", expected, actual);
-    }
-
-    private void testPlainString(String expected) {
-        IChatBaseComponent component = CraftChatMessage.fromString(expected, false, true)[0];
-        String actual = CraftChatMessage.fromComponent(component);
-        assertEquals("fromComponent does not match input: " + component, expected, actual);
-        assertTrue("Non-plain component: " + component, !containsNonPlainComponent(component));
-    }
-
-    private boolean containsNonPlainComponent(IChatBaseComponent component) {
-        for (IChatBaseComponent c : component) {
-            if (!(c instanceof ChatComponentText)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private void testComponent(String expected, IChatBaseComponent cmp) {
-        String actual = CraftChatMessage.fromComponent(cmp);
-        assertEquals("\nComponent: " + cmp + "\n", expected, actual);
-
-        IChatBaseComponent expectedCmp = CraftChatMessage.fromString(expected, true)[0];
-        String actualExpectedCmp = CraftChatMessage.fromComponent(expectedCmp);
-        assertEquals("\nComponent: " + expectedCmp + "\n", expected, actualExpectedCmp);
-    }
-}
diff --git a/src/test/java/org/bukkit/enchantments/EnchantmentTargetTest.java b/src/test/java/org/bukkit/enchantments/EnchantmentTargetTest.java
deleted file mode 100644
index 2a0507866703c6bfd5307ab151b0862695497b24..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/enchantments/EnchantmentTargetTest.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package org.bukkit.enchantments;
-
-import net.minecraft.core.IRegistry;
-import net.minecraft.world.item.Item;
-import net.minecraft.world.item.enchantment.EnchantmentSlotType;
-import org.bukkit.Material;
-import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class EnchantmentTargetTest {
-
-    @Test
-    public void test() {
-        for (EnchantmentSlotType nmsSlot : EnchantmentSlotType.values()) {
-            EnchantmentTarget bukkitTarget;
-            switch (nmsSlot) {
-                case ARMOR_CHEST:
-                    bukkitTarget = EnchantmentTarget.ARMOR_TORSO;
-                    break;
-                case DIGGER:
-                    bukkitTarget = EnchantmentTarget.TOOL;
-                    break;
-                default:
-                    bukkitTarget = EnchantmentTarget.valueOf(nmsSlot.name());
-                    break;
-            }
-
-            Assert.assertNotNull("No bukkit target for slot " + nmsSlot, bukkitTarget);
-
-            for (Item item : IRegistry.ITEM) {
-                Material material = CraftMagicNumbers.getMaterial(item);
-
-                boolean nms = nmsSlot.canEnchant(item);
-                boolean bukkit = bukkitTarget.includes(material);
-
-                Assert.assertEquals("Slot mismatch for " + bukkitTarget + " and " + material, nms, bukkit);
-            }
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/entity/EnderDragonPhaseTest.java b/src/test/java/org/bukkit/entity/EnderDragonPhaseTest.java
deleted file mode 100644
index d51a0c15b14cc0e30bb95b8966242faa1c8b1a93..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/entity/EnderDragonPhaseTest.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package org.bukkit.entity;
-
-import net.minecraft.world.entity.boss.enderdragon.phases.DragonControllerPhase;
-import org.bukkit.craftbukkit.entity.CraftEnderDragon;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class EnderDragonPhaseTest {
-
-    @Test
-    public void testNotNull() {
-        for (EnderDragon.Phase phase : EnderDragon.Phase.values()) {
-            DragonControllerPhase dragonControllerPhase = CraftEnderDragon.getMinecraftPhase(phase);
-            Assert.assertNotNull(phase.name(), dragonControllerPhase);
-            Assert.assertNotNull(phase.name(), CraftEnderDragon.getBukkitPhase(dragonControllerPhase));
-        }
-    }
-
-    @Test
-    public void testBukkitToMinecraft() {
-        Assert.assertEquals("CIRCLING", CraftEnderDragon.getMinecraftPhase(EnderDragon.Phase.CIRCLING), DragonControllerPhase.HOLDING_PATTERN);
-        Assert.assertEquals("STRAFING", CraftEnderDragon.getMinecraftPhase(EnderDragon.Phase.STRAFING), DragonControllerPhase.STRAFE_PLAYER);
-        Assert.assertEquals("FLY_TO_PORTAL", CraftEnderDragon.getMinecraftPhase(EnderDragon.Phase.FLY_TO_PORTAL), DragonControllerPhase.LANDING_APPROACH);
-        Assert.assertEquals("LAND_ON_PORTAL", CraftEnderDragon.getMinecraftPhase(EnderDragon.Phase.LAND_ON_PORTAL), DragonControllerPhase.LANDING);
-        Assert.assertEquals("LEAVE_PORTAL", CraftEnderDragon.getMinecraftPhase(EnderDragon.Phase.LEAVE_PORTAL), DragonControllerPhase.TAKEOFF);
-        Assert.assertEquals("BREATH_ATTACK", CraftEnderDragon.getMinecraftPhase(EnderDragon.Phase.BREATH_ATTACK), DragonControllerPhase.SITTING_FLAMING);
-        Assert.assertEquals("SEARCH_FOR_BREATH_ATTACK_TARGET", CraftEnderDragon.getMinecraftPhase(EnderDragon.Phase.SEARCH_FOR_BREATH_ATTACK_TARGET), DragonControllerPhase.SITTING_SCANNING);
-        Assert.assertEquals("ROAR_BEFORE_ATTACK", CraftEnderDragon.getMinecraftPhase(EnderDragon.Phase.ROAR_BEFORE_ATTACK), DragonControllerPhase.SITTING_ATTACKING);
-        Assert.assertEquals("CHARGE_PLAYER", CraftEnderDragon.getMinecraftPhase(EnderDragon.Phase.CHARGE_PLAYER), DragonControllerPhase.CHARGING_PLAYER);
-        Assert.assertEquals("DYING", CraftEnderDragon.getMinecraftPhase(EnderDragon.Phase.DYING), DragonControllerPhase.DYING);
-        Assert.assertEquals("HOVER", CraftEnderDragon.getMinecraftPhase(EnderDragon.Phase.HOVER), DragonControllerPhase.HOVER);
-    }
-
-    @Test
-    public void testMinecraftToBukkit() {
-        Assert.assertEquals("CIRCLING", CraftEnderDragon.getBukkitPhase(DragonControllerPhase.HOLDING_PATTERN), EnderDragon.Phase.CIRCLING);
-        Assert.assertEquals("STRAFING", CraftEnderDragon.getBukkitPhase(DragonControllerPhase.STRAFE_PLAYER), EnderDragon.Phase.STRAFING);
-        Assert.assertEquals("FLY_TO_PORTAL", CraftEnderDragon.getBukkitPhase(DragonControllerPhase.LANDING_APPROACH), EnderDragon.Phase.FLY_TO_PORTAL);
-        Assert.assertEquals("LAND_ON_PORTAL", CraftEnderDragon.getBukkitPhase(DragonControllerPhase.LANDING), EnderDragon.Phase.LAND_ON_PORTAL);
-        Assert.assertEquals("LEAVE_PORTAL", CraftEnderDragon.getBukkitPhase(DragonControllerPhase.TAKEOFF), EnderDragon.Phase.LEAVE_PORTAL);
-        Assert.assertEquals("BREATH_ATTACK", CraftEnderDragon.getBukkitPhase(DragonControllerPhase.SITTING_FLAMING), EnderDragon.Phase.BREATH_ATTACK);
-        Assert.assertEquals("SEARCH_FOR_BREATH_ATTACK_TARGET", CraftEnderDragon.getBukkitPhase(DragonControllerPhase.SITTING_SCANNING), EnderDragon.Phase.SEARCH_FOR_BREATH_ATTACK_TARGET);
-        Assert.assertEquals("ROAR_BEFORE_ATTACK", CraftEnderDragon.getBukkitPhase(DragonControllerPhase.SITTING_ATTACKING), EnderDragon.Phase.ROAR_BEFORE_ATTACK);
-        Assert.assertEquals("CHARGE_PLAYER", CraftEnderDragon.getBukkitPhase(DragonControllerPhase.CHARGING_PLAYER), EnderDragon.Phase.CHARGE_PLAYER);
-        Assert.assertEquals("DYING", CraftEnderDragon.getBukkitPhase(DragonControllerPhase.DYING), EnderDragon.Phase.DYING);
-        Assert.assertEquals("HOVER", CraftEnderDragon.getBukkitPhase(DragonControllerPhase.HOVER), EnderDragon.Phase.HOVER);
-    }
-}
diff --git a/src/test/java/org/bukkit/entity/EntityTypesTest.java b/src/test/java/org/bukkit/entity/EntityTypesTest.java
deleted file mode 100644
index 7ed98bb679301e93a69776fb73942c62709b9c67..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/entity/EntityTypesTest.java
+++ /dev/null
@@ -1,30 +0,0 @@
-package org.bukkit.entity;
-
-import java.util.Arrays;
-import java.util.Set;
-import java.util.stream.Collectors;
-import net.minecraft.core.IRegistry;
-import net.minecraft.resources.MinecraftKey;
-import net.minecraft.world.entity.EntityTypes;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class EntityTypesTest extends AbstractTestingBase {
-
-    @Test
-    public void testMaps() {
-        Set<EntityType> allBukkit = Arrays.stream(EntityType.values()).filter((b) -> b.getName() != null).collect(Collectors.toSet());
-
-        for (EntityTypes<?> nms : IRegistry.ENTITY_TYPE) {
-            MinecraftKey key = EntityTypes.getName(nms);
-
-            EntityType bukkit = EntityType.fromName(key.getKey());
-            Assert.assertNotNull("Missing nms->bukkit " + key, bukkit);
-
-            Assert.assertTrue("Duplicate entity nms->" + bukkit, allBukkit.remove(bukkit));
-        }
-
-        Assert.assertTrue("Unmapped bukkit entities " + allBukkit, allBukkit.isEmpty());
-    }
-}
diff --git a/src/test/java/org/bukkit/entity/PandaGeneTest.java b/src/test/java/org/bukkit/entity/PandaGeneTest.java
deleted file mode 100644
index 0b8e214b25ac484e26c1224993d599a810a3cea2..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/entity/PandaGeneTest.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package org.bukkit.entity;
-
-import net.minecraft.world.entity.animal.EntityPanda;
-import org.bukkit.craftbukkit.entity.CraftPanda;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class PandaGeneTest {
-
-    @Test
-    public void testBukkit() {
-        for (Panda.Gene gene : Panda.Gene.values()) {
-            EntityPanda.Gene nms = CraftPanda.toNms(gene);
-
-            Assert.assertNotNull("NMS gene null for " + gene, nms);
-            Assert.assertEquals("Recessive status did not match " + gene, gene.isRecessive(), nms.isRecessive());
-            Assert.assertEquals("Gene did not convert back " + gene, gene, CraftPanda.fromNms(nms));
-        }
-    }
-
-    @Test
-    public void testNMS() {
-        for (EntityPanda.Gene gene : EntityPanda.Gene.values()) {
-            Panda.Gene bukkit = CraftPanda.fromNms(gene);
-
-            Assert.assertNotNull("Bukkit gene null for " + gene, bukkit);
-            Assert.assertEquals("Recessive status did not match " + gene, gene.isRecessive(), bukkit.isRecessive());
-            Assert.assertEquals("Gene did not convert back " + gene, gene, CraftPanda.toNms(bukkit));
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/entity/TropicalFishTest.java b/src/test/java/org/bukkit/entity/TropicalFishTest.java
deleted file mode 100644
index aa70881a77fd7c2d6b1058d9dba4d70e3ae12ba8..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/entity/TropicalFishTest.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package org.bukkit.entity;
-
-import static org.hamcrest.Matchers.*;
-import static org.junit.Assert.*;
-import org.bukkit.DyeColor;
-import org.bukkit.craftbukkit.entity.CraftTropicalFish;
-import org.bukkit.entity.TropicalFish.Pattern;
-import org.junit.Test;
-
-public class TropicalFishTest {
-
-    @Test
-    public void testVariants() {
-        testVariant(65536, DyeColor.ORANGE, DyeColor.WHITE, Pattern.KOB);
-        testVariant(917504, DyeColor.RED, DyeColor.WHITE, Pattern.KOB);
-        testVariant(918273, DyeColor.RED, DyeColor.WHITE, Pattern.BLOCKFISH);
-        testVariant(918529, DyeColor.RED, DyeColor.WHITE, Pattern.BETTY);
-        testVariant(16778497, DyeColor.WHITE, DyeColor.ORANGE, Pattern.CLAYFISH);
-        testVariant(50660352, DyeColor.LIME, DyeColor.LIGHT_BLUE, Pattern.BRINELY);
-        testVariant(50726144, DyeColor.PINK, DyeColor.LIGHT_BLUE, Pattern.SPOTTY);
-        testVariant(50790656, DyeColor.GRAY, DyeColor.LIGHT_BLUE, Pattern.SUNSTREAK);
-        testVariant(67108865, DyeColor.WHITE, DyeColor.YELLOW, Pattern.FLOPPER);
-        testVariant(67110144, DyeColor.WHITE, DyeColor.YELLOW, Pattern.SPOTTY);
-        testVariant(67371265, DyeColor.YELLOW, DyeColor.YELLOW, Pattern.STRIPEY);
-        testVariant(67764993, DyeColor.PURPLE, DyeColor.YELLOW, Pattern.BLOCKFISH);
-        testVariant(101253888, DyeColor.CYAN, DyeColor.PINK, Pattern.DASHER);
-        testVariant(117441025, DyeColor.WHITE, DyeColor.GRAY, Pattern.GLITTER);
-        testVariant(117441280, DyeColor.WHITE, DyeColor.GRAY, Pattern.DASHER);
-        testVariant(117441536, DyeColor.WHITE, DyeColor.GRAY, Pattern.BRINELY);
-        testVariant(117506305, DyeColor.ORANGE, DyeColor.GRAY, Pattern.STRIPEY);
-        testVariant(117899265, DyeColor.GRAY, DyeColor.GRAY, Pattern.FLOPPER);
-        testVariant(118161664, DyeColor.BLUE, DyeColor.GRAY, Pattern.SUNSTREAK);
-        testVariant(134217984, DyeColor.WHITE, DyeColor.LIGHT_GRAY, Pattern.SUNSTREAK);
-        testVariant(234882305, DyeColor.WHITE, DyeColor.RED, Pattern.CLAYFISH);
-        testVariant(235340288, DyeColor.GRAY, DyeColor.RED, Pattern.SNOOPER);
-    }
-
-    private void testVariant(int variant, DyeColor bodyColor, DyeColor patternColor, Pattern pattern) {
-        assertThat("variant write", CraftTropicalFish.getData(patternColor, bodyColor, pattern), is(variant));
-        assertThat("pattern colour read", CraftTropicalFish.getPatternColor(variant), is(patternColor));
-        assertThat("body colour read", CraftTropicalFish.getBodyColor(variant), is(bodyColor));
-        assertThat("pattern read", CraftTropicalFish.getPattern(variant), is(pattern));
-    }
-}
diff --git a/src/test/java/org/bukkit/entity/memory/CraftMemoryKeyTest.java b/src/test/java/org/bukkit/entity/memory/CraftMemoryKeyTest.java
deleted file mode 100644
index afbbaa60d29eaf1544d025b225226936c68392da..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/entity/memory/CraftMemoryKeyTest.java
+++ /dev/null
@@ -1,75 +0,0 @@
-package org.bukkit.entity.memory;
-
-import net.minecraft.core.GlobalPos;
-import net.minecraft.core.IRegistry;
-import net.minecraft.world.entity.ai.memory.MemoryModuleType;
-import org.bukkit.Location;
-import org.bukkit.craftbukkit.entity.memory.CraftMemoryKey;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class CraftMemoryKeyTest extends AbstractTestingBase {
-
-    @Test
-    public void shouldConvertBukkitHomeKeyToNMSRepresentation() {
-        MemoryModuleType<GlobalPos> nmsHomeKey = CraftMemoryKey.fromMemoryKey(MemoryKey.HOME);
-        Assert.assertEquals("MemoryModuleType should be HOME", MemoryModuleType.HOME, nmsHomeKey);
-    }
-
-    @Test
-    public void shouldConvertBukkitJobSiteKeyToNMSRepresentation() {
-        MemoryModuleType<GlobalPos> nmsHomeKey = CraftMemoryKey.fromMemoryKey(MemoryKey.JOB_SITE);
-        Assert.assertEquals("MemoryModuleType should be JOB_SITE", MemoryModuleType.JOB_SITE, nmsHomeKey);
-    }
-
-    @Test
-    public void shouldConvertBukkitMeetingPointKeyToNMSRepresentation() {
-        MemoryModuleType<GlobalPos> nmsHomeKey = CraftMemoryKey.fromMemoryKey(MemoryKey.MEETING_POINT);
-        Assert.assertEquals("MemoryModuleType should be MEETING_POINT", MemoryModuleType.MEETING_POINT, nmsHomeKey);
-    }
-
-    @Test
-    public void shouldConvertNMSHomeKeyToBukkitRepresentation() {
-        MemoryKey<Location> bukkitHomeKey = CraftMemoryKey.toMemoryKey(MemoryModuleType.HOME);
-        Assert.assertEquals("MemoryModuleType should be HOME", MemoryKey.HOME, bukkitHomeKey);
-    }
-
-    @Test
-    public void shouldConvertNMSJobSiteKeyToBukkitRepresentation() {
-        MemoryKey<Location> bukkitJobSiteKey = CraftMemoryKey.toMemoryKey(MemoryModuleType.JOB_SITE);
-        Assert.assertEquals("MemoryKey should be JOB_SITE", MemoryKey.JOB_SITE, bukkitJobSiteKey);
-    }
-
-    @Test
-    public void shouldConvertNMSMeetingPointKeyToBukkitRepresentation() {
-        MemoryKey<Location> bukkitHomeKey = CraftMemoryKey.toMemoryKey(MemoryModuleType.MEETING_POINT);
-        Assert.assertEquals("MemoryKey should be MEETING_POINT", MemoryKey.MEETING_POINT, bukkitHomeKey);
-    }
-
-    @Test
-    public void shouldReturnNullWhenBukkitRepresentationOfKeyisNotAvailable() {
-        MemoryKey bukkitNoKey = CraftMemoryKey.toMemoryKey(MemoryModuleType.MOBS);
-        Assert.assertNull("MemoryModuleType should be null", bukkitNoKey);
-    }
-
-    @Test
-    public void shouldReturnNullWhenBukkitRepresentationOfKeyisNotAvailableAndSerializerIsNotPresent() {
-        for (MemoryModuleType<?> memoryModuleType : IRegistry.MEMORY_MODULE_TYPE) {
-            if (!memoryModuleType.getSerializer().isPresent()) {
-                MemoryKey bukkitNoKey = CraftMemoryKey.toMemoryKey(memoryModuleType);
-                Assert.assertNull("MemoryModuleType should be null", bukkitNoKey);
-            }
-        }
-    }
-
-    @Test
-    public void shouldReturnAnInstanceOfMemoryKeyWhenBukkitRepresentationOfKeyisAvailableAndSerializerIsPresent() {
-        for (MemoryModuleType<?> memoryModuleType : IRegistry.MEMORY_MODULE_TYPE) {
-            if (memoryModuleType.getSerializer().isPresent()) {
-                MemoryKey bukkitNoKey = CraftMemoryKey.toMemoryKey(memoryModuleType);
-                Assert.assertNotNull("MemoryModuleType should not be null " + IRegistry.MEMORY_MODULE_TYPE.getKey(memoryModuleType), bukkitNoKey);
-            }
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/map/MapTest.java b/src/test/java/org/bukkit/map/MapTest.java
deleted file mode 100644
index 37cae0859847df4d8dce38ba0d596c7fe7acde40..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/map/MapTest.java
+++ /dev/null
@@ -1,61 +0,0 @@
-package org.bukkit.map;
-
-import java.awt.Color;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import net.minecraft.world.level.material.MaterialMapColor;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class MapTest {
-
-    private static final Logger logger = Logger.getLogger("MapTest");
-
-    private static final int[] modifiers = {180, 220, 255, 135};
-
-    @Test
-    public void testColors() {
-        MaterialMapColor[] nmsColors = MaterialMapColor.a;
-        Color[] bukkitColors = MapPalette.colors;
-
-        boolean fail = false;
-        for (int i = 0; i < nmsColors.length; i++) {
-            if (nmsColors[i] == null) {
-                break;
-            }
-            int rgb = nmsColors[i].rgb;
-
-            int r = (rgb >> 16) & 0xFF;
-            int g = (rgb >> 8) & 0xFF;
-            int b = rgb & 0xFF;
-
-            if (i + 1 > bukkitColors.length / 4) {
-                for (int modi : modifiers) {
-                    int mr = (r * modi) / 255;
-                    int mg = (g * modi) / 255;
-                    int mb = (b * modi) / 255;
-                    logger.log(Level.WARNING, "Missing color: c({0}, {1}, {2})", new Object[]{mr, mg, mb});
-                }
-                fail = true;
-            } else {
-                for (int j = 0; j < modifiers.length; j++) {
-                    int modi = modifiers[j];
-                    Color bukkit = bukkitColors[i * 4 + j];
-                    int mr = (r * modi) / 255;
-                    int mg = (g * modi) / 255;
-                    int mb = (b * modi) / 255;
-
-                    if (bukkit.getRed() != mr || bukkit.getGreen() != mg || bukkit.getBlue() != mb) {
-                        logger.log(Level.WARNING, "Incorrect color: {6} {7} c({0}, {1}, {2}) != c({3}, {4}, {5})", new Object[]{
-                            bukkit.getRed(), bukkit.getGreen(), bukkit.getBlue(),
-                            mr, mg, mb,
-                            i, j
-                        });
-                        fail = true;
-                    }
-                }
-            }
-        }
-        Assert.assertFalse(fail);
-    }
-}
diff --git a/src/test/java/org/bukkit/potion/PotionTest.java b/src/test/java/org/bukkit/potion/PotionTest.java
deleted file mode 100644
index 95eb6bbe33fa1bacfb6dbf6a8e5c71eb7eab62e1..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/potion/PotionTest.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package org.bukkit.potion;
-
-import static org.junit.Assert.*;
-import java.util.EnumMap;
-import java.util.List;
-import java.util.Map;
-import net.minecraft.core.IRegistry;
-import net.minecraft.resources.MinecraftKey;
-import net.minecraft.world.effect.MobEffect;
-import net.minecraft.world.effect.MobEffectList;
-import net.minecraft.world.item.alchemy.PotionRegistry;
-import org.bukkit.support.AbstractTestingBase;
-import org.junit.Test;
-
-public class PotionTest extends AbstractTestingBase {
-    @Test
-    public void testEffectCompleteness() throws Throwable {
-        Map<PotionType, String> effects = new EnumMap(PotionType.class);
-        for (Object reg : IRegistry.POTION) {
-            List<MobEffect> eff = ((PotionRegistry) reg).a();
-            if (eff.size() != 1) continue;
-            int id = MobEffectList.getId(eff.get(0).getMobEffect());
-            PotionEffectType type = PotionEffectType.getById(id);
-            assertNotNull(String.valueOf(id), PotionEffectType.getById(id));
-
-            PotionType enumType = PotionType.getByEffect(type);
-            assertNotNull(type.getName(), enumType);
-
-            effects.put(enumType, enumType.name());
-        }
-
-        assertEquals(effects.entrySet().size(), PotionType.values().length - /* PotionTypes with no/shared Effects */ 6);
-    }
-
-    @Test
-    public void testEffectType() {
-        for (MobEffectList nms : IRegistry.MOB_EFFECT) {
-            MinecraftKey key = IRegistry.MOB_EFFECT.getKey(nms);
-
-            int id = MobEffectList.getId(nms);
-            PotionEffectType bukkit = PotionEffectType.getById(id);
-
-            assertNotNull("No Bukkit type for " + key, bukkit);
-            assertFalse("No name for " + key, bukkit.getName().contains("UNKNOWN"));
-
-            PotionEffectType byName = PotionEffectType.getByName(bukkit.getName());
-            assertEquals("Same type not returned by name " + key, bukkit, byName);
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/support/AbstractTestingBase.java b/src/test/java/org/bukkit/support/AbstractTestingBase.java
deleted file mode 100644
index 5831d6d38186266c4f978b32ec4b12ddabee4910..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/support/AbstractTestingBase.java
+++ /dev/null
@@ -1,59 +0,0 @@
-package org.bukkit.support;
-
-import com.google.common.collect.ImmutableList;
-import com.google.common.util.concurrent.MoreExecutors;
-import java.util.Collections;
-import java.util.List;
-import java.util.concurrent.CompletableFuture;
-import net.minecraft.server.DispenserRegistry;
-import net.minecraft.server.packs.EnumResourcePackType;
-import net.minecraft.server.packs.ResourcePackVanilla;
-import net.minecraft.server.packs.resources.ResourceManager;
-import net.minecraft.tags.TagRegistry;
-import net.minecraft.util.Unit;
-import net.minecraft.world.level.storage.loot.LootPredicateManager;
-import net.minecraft.world.level.storage.loot.LootTableRegistry;
-import org.bukkit.Material;
-import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.junit.Assert;
-
-/**
- *  If you are getting: java.lang.ExceptionInInitializerError
- *    at net.minecraft.server.StatisticList.&lt;clinit&gt;(SourceFile:58)
- *    at net.minecraft.server.Item.&lt;clinit&gt;(SourceFile:252)
- *    at net.minecraft.server.Block.&lt;clinit&gt;(Block.java:577)
- *
- *  extend this class to solve it.
- */
-public abstract class AbstractTestingBase {
-    // Materials that only exist in block form (or are legacy)
-    public static final List<Material> INVALIDATED_MATERIALS;
-
-    public static final LootTableRegistry LOOT_TABLE_REGISTRY;
-    public static final TagRegistry TAG_REGISTRY;
-
-    static {
-        DispenserRegistry.init();
-        // Set up resource manager
-        ResourceManager resourceManager = new ResourceManager(EnumResourcePackType.SERVER_DATA);
-        // add tags and loot tables for unit tests
-        resourceManager.a(TAG_REGISTRY = new TagRegistry());
-        resourceManager.a(LOOT_TABLE_REGISTRY = new LootTableRegistry(new LootPredicateManager()));
-        // Register vanilla pack
-        resourceManager.a(MoreExecutors.directExecutor(), MoreExecutors.directExecutor(), Collections.singletonList(new ResourcePackVanilla("minecraft")), CompletableFuture.completedFuture(Unit.INSTANCE)).join();
-        // Bind tags
-        TAG_REGISTRY.a().bind();
-
-        DummyServer.setup();
-        DummyEnchantments.setup();
-
-        ImmutableList.Builder<Material> builder = ImmutableList.builder();
-        for (Material m : Material.values()) {
-            if (m.isLegacy() || CraftMagicNumbers.getItem(m) == null) {
-                builder.add(m);
-            }
-        }
-        INVALIDATED_MATERIALS = builder.build();
-        Assert.assertEquals("Expected 564 invalidated materials (got " + INVALIDATED_MATERIALS.size() + ")", 564, INVALIDATED_MATERIALS.size());
-    }
-}
diff --git a/src/test/java/org/bukkit/support/DummyEnchantments.java b/src/test/java/org/bukkit/support/DummyEnchantments.java
deleted file mode 100644
index 7a6b74e19950a747880711473f838ed98bea83ad..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/support/DummyEnchantments.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package org.bukkit.support;
-
-import net.minecraft.world.item.enchantment.Enchantments;
-
-public class DummyEnchantments {
-    static {
-        Enchantments.DAMAGE_ALL.getClass();
-        org.bukkit.enchantments.Enchantment.stopAcceptingRegistrations();
-    }
-
-    public static void setup() {}
-}
diff --git a/src/test/java/org/bukkit/support/DummyServer.java b/src/test/java/org/bukkit/support/DummyServer.java
deleted file mode 100644
index 886e462defb4bd15063e4a1ce04fd7bb0df75b2a..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/support/DummyServer.java
+++ /dev/null
@@ -1,118 +0,0 @@
-package org.bukkit.support;
-
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.Method;
-import java.lang.reflect.Proxy;
-import java.util.HashMap;
-import java.util.logging.Logger;
-import org.bukkit.Bukkit;
-import org.bukkit.Material;
-import org.bukkit.NamespacedKey;
-import org.bukkit.Server;
-import org.bukkit.craftbukkit.CraftLootTable;
-import org.bukkit.craftbukkit.block.data.CraftBlockData;
-import org.bukkit.craftbukkit.inventory.CraftItemFactory;
-import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.bukkit.craftbukkit.util.CraftNamespacedKey;
-import org.bukkit.craftbukkit.util.Versioning;
-
-public final class DummyServer implements InvocationHandler {
-    private static interface MethodHandler {
-        Object handle(DummyServer server, Object[] args);
-    }
-    private static final HashMap<Method, MethodHandler> methods = new HashMap<Method, MethodHandler>();
-    static {
-        try {
-            methods.put(
-                    Server.class.getMethod("getItemFactory"),
-                    new MethodHandler() {
-                        @Override
-                        public Object handle(DummyServer server, Object[] args) {
-                            return CraftItemFactory.instance();
-                        }
-                    }
-                );
-            methods.put(
-                    Server.class.getMethod("getName"),
-                    new MethodHandler() {
-                        @Override
-                        public Object handle(DummyServer server, Object[] args) {
-                            return DummyServer.class.getName();
-                        }
-                    }
-                );
-            methods.put(
-                    Server.class.getMethod("getVersion"),
-                    new MethodHandler() {
-                        @Override
-                        public Object handle(DummyServer server, Object[] args) {
-                            return DummyServer.class.getPackage().getImplementationVersion();
-                        }
-                    }
-                );
-            methods.put(
-                    Server.class.getMethod("getBukkitVersion"),
-                    new MethodHandler() {
-                        @Override
-                        public Object handle(DummyServer server, Object[] args) {
-                            return Versioning.getBukkitVersion();
-                        }
-                    }
-                );
-            methods.put(
-                    Server.class.getMethod("getLogger"),
-                    new MethodHandler() {
-                        final Logger logger = Logger.getLogger(DummyServer.class.getCanonicalName());
-                        @Override
-                        public Object handle(DummyServer server, Object[] args) {
-                            return logger;
-                        }
-                    }
-                );
-            methods.put(
-                    Server.class.getMethod("getUnsafe"),
-                    new MethodHandler() {
-                        @Override
-                        public Object handle(DummyServer server, Object[] args) {
-                            return CraftMagicNumbers.INSTANCE;
-                        }
-                    }
-                );
-            methods.put(
-                    Server.class.getMethod("createBlockData", Material.class),
-                    new MethodHandler() {
-                        final Logger logger = Logger.getLogger(DummyServer.class.getCanonicalName());
-                        @Override
-                        public Object handle(DummyServer server, Object[] args) {
-                            return CraftBlockData.newData((Material) args[0], null);
-                        }
-                    }
-                );
-            methods.put(Server.class.getMethod("getLootTable", NamespacedKey.class),
-                    new MethodHandler() {
-                        @Override
-                        public Object handle(DummyServer server, Object[] args) {
-                            NamespacedKey key = (NamespacedKey) args[0];
-                            return new CraftLootTable(key, AbstractTestingBase.LOOT_TABLE_REGISTRY.getLootTable(CraftNamespacedKey.toMinecraft(key)));
-                        }
-                    }
-                );
-            Bukkit.setServer(Proxy.getProxyClass(Server.class.getClassLoader(), Server.class).asSubclass(Server.class).getConstructor(InvocationHandler.class).newInstance(new DummyServer()));
-        } catch (Throwable t) {
-            throw new Error(t);
-        }
-    }
-
-    public static void setup() {}
-
-    private DummyServer() {};
-
-    @Override
-    public Object invoke(Object proxy, Method method, Object[] args) {
-        MethodHandler handler = methods.get(method);
-        if (handler != null) {
-            return handler.handle(this, args);
-        }
-        throw new UnsupportedOperationException(String.valueOf(method));
-    }
-}
diff --git a/src/test/java/org/bukkit/support/Matchers.java b/src/test/java/org/bukkit/support/Matchers.java
deleted file mode 100644
index 324bbc7367199b28b07deb622c3c8ce1e16dfac0..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/support/Matchers.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package org.bukkit.support;
-
-import org.hamcrest.BaseMatcher;
-import org.hamcrest.Description;
-import org.hamcrest.Matcher;
-
-public final class Matchers {
-
-    private Matchers() {}
-
-    public static <T> Matcher<T> sameHash(T value) {
-        return new SameHash<T>(value);
-    }
-
-    static class SameHash<T> extends BaseMatcher<T> {
-        private final int expected;
-
-        SameHash(T object) {
-            expected = object.hashCode();
-        }
-
-        @Override
-        public boolean matches(Object item) {
-            return item.hashCode() == expected;
-        }
-
-        @Override
-        public void describeTo(Description description) {
-            description.appendValue(expected);
-        }
-    }
-}
diff --git a/src/test/java/org/bukkit/support/Util.java b/src/test/java/org/bukkit/support/Util.java
deleted file mode 100644
index 2f24d9a4083665b42bb439434c64158dc14fcaf1..0000000000000000000000000000000000000000
--- a/src/test/java/org/bukkit/support/Util.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package org.bukkit.support;
-
-import java.lang.reflect.Field;
-
-public class Util {
-    /*
-    public static <T> T getInternalState(Object object, String fieldName) {
-        return getInternalState(object.getClass(), object, fieldName);
-    }
-    */
-
-    @SuppressWarnings("unchecked")
-    public static <T> T getInternalState(Class<?> clazz, Object object, String fieldName) {
-        Field field;
-        try {
-            field = clazz.getDeclaredField(fieldName);
-        } catch (SecurityException e) {
-            throw new RuntimeException("Not allowed to access " + clazz, e);
-        } catch (NoSuchFieldException e) {
-            throw new RuntimeException("Unable to find field " + fieldName, e);
-        }
-
-        field.setAccessible(true);
-        try {
-            return (T) field.get(object);
-        } catch (IllegalArgumentException e) {
-        } catch (IllegalAccessException e) {
-        }
-        throw new RuntimeException("Unable to get internal value");
-    }
-}
